<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yaohwu</title>
  
  <subtitle>notes</subtitle>
  <link href="https://notes.yaohwu.xyz/atom.xml" rel="self"/>
  
  <link href="https://notes.yaohwu.xyz/"/>
  <updated>2024-05-19T10:48:19.945Z</updated>
  <id>https://notes.yaohwu.xyz/</id>
  
  <author>
    <name>yaohwu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>幕布读书笔记笔记</title>
    <link href="https://notes.yaohwu.xyz/2024/05/19/reads/"/>
    <id>https://notes.yaohwu.xyz/2024/05/19/reads/</id>
    <published>2024-05-19T09:05:48.000Z</published>
    <updated>2024-05-19T10:48:19.945Z</updated>
    
    <content type="html"><![CDATA[<p>使用幕布记录的读书笔记</p><span id="more"></span><ol><li><a href="https://yaohwu.xyz/">笔记内容</a> 进度 最近一次阅读的时间</li><li><a href="https://www.mubu.com/doc/5kP0RnKbg0Y">亲密关系三十讲</a> 6&#x2F;31 2024-05-19</li><li><a href="https://www.mubu.com/doc/47GoX0foLEY">梁宁产品三十讲</a> 5&#x2F;7 2023-12-12</li><li><a href="https://www.mubu.com/doc/35VA5tn9CEY">新任管理者:一线员工到主管-学习</a> 1&#x2F;1</li><li><a href="https://www.mubu.com/doc/4OYBZWqMQ8Y">ClickHouse Principle and Practice 笔记</a> 1&#x2F;5</li><li><a href="https://www.mubu.com/doc/2CsWtcrN4Is">How Prometheus Store the Data</a> 1&#x2F;1</li><li><a href="https://www.mubu.com/doc/3irolRwGW9c">DDIA</a> 3&#x2F;14</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;使用幕布记录的读书笔记&lt;/p&gt;</summary>
    
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/categories/read/"/>
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>8 Data Structures That Power Your Databases</title>
    <link href="https://notes.yaohwu.xyz/2023/02/07/8-Data-Structures-That-Power-Your-Databases/"/>
    <id>https://notes.yaohwu.xyz/2023/02/07/8-Data-Structures-That-Power-Your-Databases/</id>
    <published>2023-02-07T06:08:23.000Z</published>
    <updated>2023-04-11T02:22:04.781Z</updated>
    
    <content type="html"><![CDATA[<p>介绍学习一下 8 种支撑起数据库的数据结构。</p><span id="more"></span><h2 id="Guide"><a href="#Guide" class="headerlink" title="Guide"></a>Guide</h2><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/202301302010209-8-data-structures-database.png" alt="8 Data Structures That Power Your Databases"></p><p>由于到可能回到算法层面，内容会变得很多，我准备的也比较仓促，有很多也没搞懂，因此我们尽可能避免实现层面的问题。</p><p>将结构示意和原理示意，然后将优劣势，再最后将实际的应用场景。总结来说，就是上图稍微扩展扩展。</p><h2 id="SkipList-跳表"><a href="#SkipList-跳表" class="headerlink" title="SkipList 跳表"></a>SkipList 跳表</h2><p>SkipList ( 跳表 ) 这种数据结构是由<em>William Pugh</em>于1990年在在 <a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/w/index.php?title=Communications_of_the_ACM&action=edit&redlink=1">Communications of the ACM</a> June 1990, 33(6) 668-676 发表了<em>Skip lists: a probabilistic alternative to balanced trees</em>，在其中详细描述了他的工作。由论文标题可知，SkipList的设计初衷是作为替换平衡树的一种选择。</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>讲到平衡树，那么就得稍微展开介绍介绍。</p><p>树到二叉树到二叉搜索树到平衡树或者跳表，这算是树结构的一个优化链条。</p><p><strong>树结构</strong>，现实生活应该很常见。到计算机领域，最多的是<strong>二叉树</strong>。</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/202302071539522-tree-binary-tree.png" alt="tree-and-binary-tree"></p><ul><li>将一棵树转换为二叉树的方法：<ul><li>在兄弟之间加一连线；</li><li>对每个结点，除了其左孩子外，去除其与其馀孩子之间的联系；</li><li>以树的根结点为轴心，将整树顺时针转45度。</li></ul></li></ul><p>二叉树有很多的性能问题，这很显而易见。</p><p>因此演变出来，二叉搜索树。</p><p><strong>二叉搜索树</strong>（英语：Binary Search Tree），是指一棵空树或者具有下列性质的<a href="https://zh.wikipedia.org/zh-hans/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>：</p><ol><li>若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li></ol><p>二叉搜索树相比于其他数据结构的优势在于查找、插入的时间复杂度较低，为O(logn)。</p><h4 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a>性能优化方案</h4><p>二叉树到二叉搜索树的这优化很容易理解，有序的嘛，有序的对于搜索和排序就很友好，性能就好。</p><p>二叉搜索树到平衡树，大致讲一下。</p><p>搜索、插入、删除的复杂度等于树高，期望O(logn)，最坏退化为偏斜二元树O(n)，树太深了。对于可能形成偏斜二元树的问题可以经由树高改良后的平衡树将搜寻、插入、删除的时间复杂度都维持在 O(log n)，如AVL树、红黑树等。</p><p>但是</p><blockquote><p>那么，狗蛋，代价是什么呢？–地狱咆哮《WOW》</p><p>团结是需要付出代价的。–周喆直《流浪地球2》</p></blockquote><p>举个例子，<strong>扁平化管理</strong>。</p><p>旋转：几乎所有平衡树的操作都基于树旋转操作（也有部分基于重构，如替罪羊树），通过旋转操作可以使得树趋于平衡。对一棵搜索树进行查询、新增、删除等动作，所花的时间与树的高度h成比例，并不与树的容量n成比例。如果可以让树维持平衡，也就是让h维持在O(logn)的左右，就可以在O(logn)的复杂度内完成各种基本操作。</p><p>由于插入过程中可能需要多次旋转，导致插入效率较低，因而才有了在工程界更加实用的红黑树。</p><p>但是红黑树有一个问题就是在并发环境下使用不方便，比如需要更新数据时，Skip需要更新的部分比较少，锁的东西也更少，而红黑树有个平衡的过程，在这个过程中会涉及到较多的节点，需要锁住更多的节点，从而降低了并发性能。</p><blockquote><p>SkipList还有一个优势就是实现简单，SkipList的实现只花了2个小时，而红黑树，我可能得2天。</p></blockquote><h3 id="原理示意"><a href="#原理示意" class="headerlink" title="原理示意"></a>原理示意</h3><p>先看几个树结构的示意动画</p><p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">visualization&#x2F;Algorithms</a></p><p>看跳表的原理，跳表使用概率均衡技术而不是使用强制性均衡，因此，对于插入和删除结点比传统上的平衡树算法更为简洁高效。</p><p>这也就是 probabilistic  的来源。</p><p>基础跳表</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/202302071615993-skiplist-1.png" alt="basic"></p><p>查找 19 的过程</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/202302071616650-sliplist-2.png" alt="find 19"></p><p>随机生成的跳表</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/202302071617885-skiplist-3.png" alt="random generacted skiplist"></p><h3 id="典型的应用场景"><a href="#典型的应用场景" class="headerlink" title="典型的应用场景"></a>典型的应用场景</h3><h4 id="redis-的有序集合，为什么-redis-里面要使用跳表来实现？"><a href="#redis-的有序集合，为什么-redis-里面要使用跳表来实现？" class="headerlink" title="redis 的有序集合，为什么 redis 里面要使用跳表来实现？"></a>redis 的有序集合，<a href="https://news.ycombinator.com/item?id=1171423">为什么 redis 里面要使用跳表来实现</a>？</h4><p>There are a few reasons:</p><p>\1) They are not very memory intensive. It’s up to you basically. Changing parameters about the probability of a node to have a given number of levels will make then <em>less</em> memory intensive than btrees.</p><p>\2) A sorted set is often target of many ZRANGE or ZREVRANGE operations, that is, traversing the skip list as a linked list. With this operation the cache locality of skip lists is at least as good as with other kind of balanced trees.</p><p>\3) They are simpler to implement, debug, and so forth. For instance thanks to the skip list simplicity I received a patch (already in Redis master) with augmented skip lists implementing ZRANK in O(log(N)). It required little changes to the code.</p><p>About the Append Only durability &amp; speed, I don’t think it is a good idea to optimize Redis at cost of more code and more complexity for a use case that IMHO should be rare for the Redis target (fsync() at every command). Almost no one is using this feature even with ACID SQL databases, as the performance hint is big anyway.</p><p>About threads: our experience shows that Redis is mostly I&#x2F;O bound. I’m using threads to serve things from Virtual Memory. The long term solution to exploit all the cores, assuming your link is so fast that you can saturate a single core, is running multiple instances of Redis (no locks, almost fully scalable linearly with number of cores), and using the “Redis Cluster” solution that I plan to develop in the future.</p><p>简单够用。跳表足够简单 Antirez 很喜欢很满意，除此之外因为内存中的 IO 相对于磁盘来说足够快 所以相对于 IO 次数多并不会造成速度上过大的差距。</p><h2 id="Hash-Index"><a href="#Hash-Index" class="headerlink" title="Hash Index"></a>Hash Index</h2><h3 id="Hash-Index-原理示意"><a href="#Hash-Index-原理示意" class="headerlink" title="Hash Index 原理示意"></a>Hash Index 原理示意</h3><p>基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。</p><h4 id="静态-hash"><a href="#静态-hash" class="headerlink" title="静态 hash"></a>静态 hash</h4><p>云端 swift 的 bucket hash，针对 appid 和 yearmonth 的 hash 索引，用于加速指定 appid 和 yearmonth 的查询，使用的就是静态的 hash。</p><p>缺点：<br>一旦确定，是不能够修改的，<strong>必须在实现系统时选择确定的散列函数</strong>。</p><h4 id="动态-hash"><a href="#动态-hash" class="headerlink" title="动态 hash"></a>动态 hash</h4><p>允许散列函数动态改变，以适应数据库增大或缩小的需要。</p><p>当数据库增大或缩小时，可扩充散列可以通过桶的分裂或合并来适应数据库大小的变化，这样可以保持空间的使用效率。此外，由于重组每次仅作用于一个桶，因此所带来的性能开销较低。</p><ul><li>选择一个具有均匀性和随机性特性的散列函数 h。此散列函数产生的值范围相对较大，是 b 位二进制整数，一个典型的 b 值是 32。</li><li>把记录插入文件时按需建桶，用小于等于 b 的 i 个位用作附加桶地址表中的偏移量，i 的值会随着数据库大小的变化而增大或者减少。</li></ul><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/202302071736441-dynamic-index.png" alt="dynamic-index"></p><p>优点</p><ul><li>随着记录的增加, 动态散列的性能并不会下降；</li><li>动态散列有着最小的空间开销。</li></ul><p>缺点</p><ul><li>会增加一次额外的查询定位, 因为在查询桶本身之前还需要查找目录来定位桶；</li><li>存储区地址表本身可能变得很大；</li><li>更改存储区地址表的大小是一项代价昂贵的操作。</li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="非常常用的内存索引方案"><a href="#非常常用的内存索引方案" class="headerlink" title="非常常用的内存索引方案"></a>非常常用的内存索引方案</h4><h2 id="Sorted-String-Table-SSTable"><a href="#Sorted-String-Table-SSTable" class="headerlink" title="Sorted String Table(SSTable)"></a>Sorted String Table(SSTable)</h2><p>ref <a href="https://www.cnblogs.com/Jack47/p/sstable-1.html">https://www.cnblogs.com/Jack47/p/sstable-1.html</a></p><h2 id="LSM-TREE"><a href="#LSM-TREE" class="headerlink" title="LSM TREE"></a>LSM TREE</h2><p>ref <a href="https://zhuanlan.zhihu.com/p/181498475">https://zhuanlan.zhihu.com/p/181498475</a></p><h2 id="B-tree"><a href="#B-tree" class="headerlink" title="B-tree"></a>B-tree</h2><p>ref <a href="https://www.yiibai.com/data_structure/b-tree.html">https://www.yiibai.com/data_structure/b-tree.html</a></p><h2 id="Inverted-Index"><a href="#Inverted-Index" class="headerlink" title="Inverted Index"></a>Inverted Index</h2><p>ref <a href="https://www.mubucm.com/doc/2CsWtcrN4Is">https://www.mubucm.com/doc/2CsWtcrN4Is</a></p><p>ref <a href="https://www.jianshu.com/p/3d0fc2e77620">https://www.jianshu.com/p/3d0fc2e77620</a></p><h2 id="Suffix-Tree"><a href="#Suffix-Tree" class="headerlink" title="Suffix Tree"></a>Suffix Tree</h2><p>ref <a href="https://www.cnblogs.com/luosongchao/p/3247478.html">https://www.cnblogs.com/luosongchao/p/3247478.html</a></p><h2 id="R-Tree"><a href="#R-Tree" class="headerlink" title="R-Tree"></a>R-Tree</h2><p>ref <a href="https://zhuanlan.zhihu.com/p/62639268">https://zhuanlan.zhihu.com/p/62639268</a></p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ol><li><a href="https://github.com/HiWong/SkipListPro">https://github.com/HiWong/SkipListPro</a></li><li><a href="https://blog.csdn.net/ict2014/article/details/17394259">https://blog.csdn.net/ict2014/article/details/17394259</a></li><li><a href="https://rasmuspagh.net/courses/DBT08/">https://rasmuspagh.net/courses/DBT08/</a></li><li><a href="https://rasmuspagh.net/courses/DBT08/02-hashing.pdf">https://rasmuspagh.net/courses/DBT08/02-hashing.pdf</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;介绍学习一下 8 种支撑起数据库的数据结构。&lt;/p&gt;</summary>
    
    
    
    
    <category term="data structures" scheme="https://notes.yaohwu.xyz/tags/data-structures/"/>
    
    <category term="database" scheme="https://notes.yaohwu.xyz/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>merge-two-git-repo-with-history-left</title>
    <link href="https://notes.yaohwu.xyz/2023/02/07/merge-two-git-repo-with-history-left/"/>
    <id>https://notes.yaohwu.xyz/2023/02/07/merge-two-git-repo-with-history-left/</id>
    <published>2023-02-07T06:08:23.000Z</published>
    <updated>2023-04-10T12:20:02.456Z</updated>
    
    <content type="html"><![CDATA[<p>有两个不同地址的库，现在需要把这两个git仓库的dev分支合并到一个新的git仓库的dev分支。</p><span id="more"></span><p>两个不同地址的库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://127.0.0.1/mygroup/project1.git，分支dev</span><br><span class="line">https://127.0.0.1/mygroup/project2.git，分支dev</span><br></pre></td></tr></table></figure><p>现在需要把这两个git仓库的dev分支合并到一个新的git仓库的dev分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://127.0.0.1/mygroup/allprojects.git</span><br></pre></td></tr></table></figure><p>按以下步骤操作：</p><p>一、克隆allproject到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://127.0.0.1/mygroup/allprojects.git</span><br></pre></td></tr></table></figure><p>二、切换到allprojects的dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>三、添加project1远程仓库，命名为project1。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add project1 https://127.0.0.1/mygroup/project1.git</span><br></pre></td></tr></table></figure><p>四、从远程仓库拉取project1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch project1</span><br></pre></td></tr></table></figure><p>五、将project1仓库拉取dev分支作为新分支checkout到本地，新分支名设定为project1-dev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b project1-dev project1/dev</span><br></pre></td></tr></table></figure><p>六、切换到allprojects的dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout dev</span><br></pre></td></tr></table></figure><p>七、将本地的project1-dev合并到当前的dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge project1-dev</span><br></pre></td></tr></table></figure><p>如果报错：fatal: refusing to merge unrelated histories … 则使用加上一个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge project1-dev --allow-unrelated-histories</span><br></pre></td></tr></table></figure><p>同样，合并project2仓库，重复步骤三到七。</p><p>八、最后，推送合并后的dev分支到远程即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;有两个不同地址的库，现在需要把这两个git仓库的dev分支合并到一个新的git仓库的dev分支。&lt;/p&gt;</summary>
    
    
    
    
    <category term="git" scheme="https://notes.yaohwu.xyz/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>java 静态方法返回值变化导致的不兼容</title>
    <link href="https://notes.yaohwu.xyz/2022/11/25/java-static-method-return-type-change-compatiable/"/>
    <id>https://notes.yaohwu.xyz/2022/11/25/java-static-method-return-type-change-compatiable/</id>
    <published>2022-11-25T04:30:00.000Z</published>
    <updated>2023-04-11T02:22:04.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最近一个迭代做了一些改动，其中有一项是 getInstance 方法返回值发生了变化，从原本的接口类型变成了实际的实现类。<br>主体功能的插件对于这个方法的调用就出现了兼容问题。</p><span id="more"></span><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>大致讲一个例子。</p><p>有一个 Tools 的类，实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaohwu</span></span><br><span class="line"><span class="comment"> * created by yaohwu at 2022/11/25 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tools</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializable <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Serializable&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有一个依赖 Tools 的 Main 函数，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaohwu</span></span><br><span class="line"><span class="comment"> * created by yaohwu at 2022/11/25 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainTools</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Tools.say());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以正常编译执行，都很正常。</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/20221125120350.png" alt="common using of tools and main"></p><p>现在，将 Tools 的类实现稍加修改，将方法声明的返回值类型改一下，变成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaohwu</span></span><br><span class="line"><span class="comment"> * created by yaohwu at 2022/11/25 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tools</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;String&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时，仅编译 Tools 类，那么 MainTools 中的 main 函数还能正常执行么？</p><p>现在是思考时间！</p><hr><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/20221125120628.png" alt="main after tools changed"></p><p>答案是<strong>不能</strong>，会有 NoSuchMethodError 的异常。</p><h2 id="实际的业务场景"><a href="#实际的业务场景" class="headerlink" title="实际的业务场景"></a>实际的业务场景</h2><p>类比一下实际在业务里的场景。</p><table><thead><tr><th>模块</th><th>旧版本</th><th>新版本</th><th>兼容检查</th></tr></thead><tbody><tr><td>主体</td><td>Tools return String say 的实现</td><td>Tookls return Serializable say 的实现</td><td>旧版本主体</td></tr><tr><td>插件</td><td>依赖 String say 的 MainTools 编译版本</td><td>依赖 Serializable say 的 MainTools 编译版本</td><td>新版本插件调用出现 NoSuchMethodError 的问题</td></tr></tbody></table><p>为什么呢？即使重新编译 MainTools 也不会有报错，陷入方法重载的认知里面，签名没变，返回值也只是从接口变成了具体的实现类，应该可以完成重载的协变。</p><p>但实际的效果，却是未重新针对 MainTools 编译的情况下，直接执行旧编译的结果会直接抛出错误。这里是有什么新的知识点么？</p><h2 id="兼容方案"><a href="#兼容方案" class="headerlink" title="兼容方案"></a>兼容方案</h2><p>该如何兼容呢？</p><p>直接反射，反射依据方法签名进行调用，可以直接拿到对应的结果。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;最近一个迭代做了一些改动，其中有一项是 getInstance 方法返回值发生了变化，从原本的接口类型变成了实际的实现类。&lt;br&gt;主体功能的插件对于这个方法的调用就出现了兼容问题。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java-basic" scheme="https://notes.yaohwu.xyz/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>how-to-make-a-decision</title>
    <link href="https://notes.yaohwu.xyz/2022/01/12/how-to-make-a-decision/"/>
    <id>https://notes.yaohwu.xyz/2022/01/12/how-to-make-a-decision/</id>
    <published>2022-01-12T11:05:48.000Z</published>
    <updated>2024-05-19T09:16:14.270Z</updated>
    
    <content type="html"><![CDATA[<p>之前开会讨论，遇到一个需要决策的问题，有同事在回答问题的基础上，比较详细的给出了自己的思考过程。觉得很有意思。我之前的意识层面，也只是认识到决策时对成本和价值的考量，随便找一本书读一读，再延伸思考一下。</p><span id="more"></span><p>书籍信息</p><blockquote><p>决策思维:人人必备的决策口袋书:升级典藏版&#x2F;王嘉陵著.—北京: 东方出版社，2018.11</p></blockquote><h2 id="决策和决定"><a href="#决策和决定" class="headerlink" title="决策和决定"></a>决策和决定</h2><blockquote><p>做出正确的决策就是要有效地分配有限的资源以达到目标。</p></blockquote><p>比我之前的理解更完备。成本–<code>有限的资源</code>，价值–<code>目标</code>，过程中还要进行<code>有效地分配</code>。</p><p>另外一个点，就是要严谨，要认清楚一些概念。这一点，在个人思考的过程中可能会变得愈发松散，而以文字的形式输出的过程中，却需要更加的严谨。比如，粗略的认知下，决策就是我认为的，成本和价值的平衡。但是决策其实更多的还是一个过程，这个过程要实现有效地分配，是要去实现平衡。</p><blockquote><p>制定了一个系统化的方案，GPA。</p><ul><li>G (Goal) 目标：确立一个明确、共享的目标；</li><li>P (Priority) 优先级：明确不同任务的轻重缓急;</li><li>A (Alternatives) 可选方案：制作许多可选方案，选用最好的方案去达到目标。</li></ul></blockquote><p>这三个我目前最擅长的，就是 A，执行可选的方案，选用其中最好的方案去达成目标。针对目标和优先级，最不擅长，比如说每年年初的 OKR 讨论和个人事务的四象限管理中。</p><h2 id="决策的陷阱"><a href="#决策的陷阱" class="headerlink" title="决策的陷阱"></a>决策的陷阱</h2><h3 id="生活中的陷阱"><a href="#生活中的陷阱" class="headerlink" title="生活中的陷阱"></a>生活中的陷阱</h3><ul><li>锚的陷阱，先入为主；<ul><li>其实有过这样的担心，比如在讨论埋点验收平台时，前面主要就只是我的想法，难免会在大家潜意识里加一个限定框，也就是一个锚；</li></ul></li><li>固守成规，不愿意创新和改变；</li><li>沉没成本陷阱，顾惜已支付的成本；<ul><li>比如做问题库决策的时候也遇到了这样的陷阱，20年都干大半年了没有什么有效的成果；</li></ul></li><li>肯定证据陷阱，在陷入其他陷阱时，不断的收集证据完成自我倾向的证明；</li><li>框架陷阱，立即投入而不是先确定框架合理性，和先入为主类似，容易先限定在框架内；</li><li>估计和预测的各种陷阱，过于自信、过于审慎、追忆陷阱；<ul><li>对未来决策，依托过去的经验和数据，过去成功，那么可能过于自信；过去失败，那么可能过于审慎；</li><li>追忆印象深刻的大事件，容易以偏概全；</li></ul></li></ul><h2 id="管理中的陷阱"><a href="#管理中的陷阱" class="headerlink" title="管理中的陷阱"></a>管理中的陷阱</h2><ul><li>问题陷阱，以问题为起点，让问题推动决策，以解决问题为目标；<ul><li>粗看好像没什么问题，但是决定的起点必须是想要达成的目标，而非眼前的问题，以问题问起点，就输在了起跑线上；以目标为起点去思考才可能达成目标；</li></ul></li><li>机会陷阱，以机会为起点，只有一个方案时，就做是非题，没有其他的选择时就做决策；<ul><li>抓住机会时达成目标的手段而非目标本身；</li><li>以机会为起点，是常见的“手段目标化的陷阱”</li><li>没有选择就不做决定，寻找更多的选择，寻找更多的方案；</li><li>好的方案才有好的决定；</li></ul></li><li>希望在审批中提升决策的品质；<ul><li>官僚化；妄图提升品质，实则层层加码；</li><li>决策内容高质量，决策过程高质量；</li></ul></li></ul><h2 id="todo-more"><a href="#todo-more" class="headerlink" title="todo more"></a>todo more</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前开会讨论，遇到一个需要决策的问题，有同事在回答问题的基础上，比较详细的给出了自己的思考过程。觉得很有意思。我之前的意识层面，也只是认识到决策时对成本和价值的考量，随便找一本书读一读，再延伸思考一下。&lt;/p&gt;</summary>
    
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/categories/read/"/>
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>The-Cathedral-the-Bazaar-zh</title>
    <link href="https://notes.yaohwu.xyz/2022/01/04/The-Cathedral-the-Bazaar-zh/"/>
    <id>https://notes.yaohwu.xyz/2022/01/04/The-Cathedral-the-Bazaar-zh/</id>
    <published>2022-01-04T06:08:23.000Z</published>
    <updated>2023-04-11T01:12:38.516Z</updated>
    
    <content type="html"><![CDATA[<p>教堂与市集</p><span id="more"></span><h2 id="第一章-教堂与市集"><a href="#第一章-教堂与市集" class="headerlink" title="第一章 教堂与市集"></a>第一章 教堂与市集</h2><p>Linux 打破了许多软件开发的传统，这个世界级的操作系统在五年前（1991 年）仅仅靠着如丝般的互联网，神奇地联合了散布在全世界数以千计兼职的玩家们来开发它，谁曾料到会发生这样的事情呢？</p><p>我当然也没料到，Linux 出现在我电脑屏幕是在 1993 年初，当时我埋首于 UNIX 及开源的软件开发已有十年，1980 年代中期，我是 GNU [^1] 项目首批的贡献者之一，我写过许多开源的软件放到网络上供人使用，也曾独立或协同开发好几个程序（nethack，Emacs 的 VC 和 GUD 功能，xlife，…等等），这些程序到今天仍广泛地为人所用，我想我知道这是怎么办到的。</p><p>Linux 扭转了许多我认为我已知道的观念。多年来我一直宣扬使用小工具集、快速原型及快速开发的 UNIX 福音。但我也相信对于有一定复杂度的程序必需使用集中和有经验的方法来开发，我相信最重要的软件（操作系统以及庞大的工具程序如 Emacs）必须如建造一座教堂般，由个别的高手或一小群专家在光辉的孤立中小心翼翼地精雕细琢，时机未到之前，不会发布测试版。</p><p><code>Linus Torvald</code>[^2] 的软件开发风格（尽早并经常发布新版本，授权每一件作者可以委托的事，不拒绝几乎到混乱程度的程序）的出现如同一个惊奇，没有令人肃然起敬的教堂，甚至 Linux 的同好们似乎组成了一个有不同流程和不同方式的大市集（Linux 的档案网站就是它适切的象征，每个人都服从着自由的规则），以这个风格开发出来的 Linux 既一致又稳定，表面上看来真是一连串的奇迹。</p><p>市集模式似乎是可行的，并且运作得很好，这个事实带来了相当的震憾。当以我的方法去认知时，我除了努力做好个人的项目，并也试着去了解为什么在Linux的世界，不但没有因为浑沌不清而四分五裂，反而以教堂建造者几乎想像不到的速度在茁壮。</p><p>直到 1996 年年中，我想我才开始了解这一件事。我得到了一个绝佳的机会来试验我的理论，这个机会是一个开源形式的项目，正好可以试用市集模式来开发，所以我做了这个项目，而且更有意义的是它成功了。</p><p>接下来在这篇文章中我将陈述这个项目的故事，并且以它为例提出关于有效地利用开源模式来开发软件的格言，这些法则并非都是我在 Linux 中第一次学到，但我们可以看到 Linux 的世界是怎么赋予它们特别的意义。如果我是对的，那么这些格言将会帮你真确地了解是什么促成 Linux 社群成为好软件的原创者，并且帮助你变得更具生产力。</p><h2 id="第二章-信一定要寄到"><a href="#第二章-信一定要寄到" class="headerlink" title="第二章 信一定要寄到"></a>第二章 信一定要寄到</h2><p>自 1993 年起，我一直担任一家提供免费上线的小型 ISP 的技术人员，这家 ISP 叫做 County InterLink（CCIL），位于宾夕凡尼亚州的 West Chester。（我本身参与捐款设立 CCIL，并写了我们独一无二的多人布告栏软件，你可以用 telnet 连线至 <a href="telnet://locke.ccil.org">locke.ccil.org</a> 一探究竟。目前它共有三十条线，可提供近三千位的用户上网。）这个工作让我可以一天二十四小时透过 CCIL 56K 的线路上网。事实上，我的确非常需要它！</p><p>因此我必须常常利用便捷的互联网电子邮件，但由于一些复杂的原因，使得我家里的机器（snark.thyrsus.com）要以 SLIP 协议连上 CCIL 有所困难。最后我还是做到了，但我马上发觉我必须周期性地以 telnet 连上 locke 来检查我是否有新信件，这实在是一件烦人的事。我想要的是︰我的邮件可以被送到 snark，而且送达时会通知我，然后我可以用 snark 上的工具程序来处理这些邮件。</p><p>网络原生的 SMTP（Simple Mail Transfer Protocol）转信功能在这里帮不上忙，因为我个人的机器并不是时时都和网络连结着而且它也没有固定的 IP 位址。我所需要的程序是这样的︰它可以间歇地连线把我的电子邮件都抓回来并放在我的机器。我知道有这样的程序，它们大部份都使用一个简单的网络应用协议叫 POP（Post Office Protocol）。目前 POP 是最通用的邮件客户端协议，但当时我使用的邮件读取端却没有这个协议。</p><p>我需要一个支持 POP3 的客户端程序。所以我到网络上搜寻之后找到一个。其实我找到了三或四个这样的程序。我使用了其中一个一阵子，但是它少了一个重要的特性，就是精巧地处理抓回来信件附件的地址，以使收件人能回复信件至正确的网址。</p><p>这个问题是这样的︰假设 locke 上有一个叫做 joe 的用户寄信给我，当我把信抓到 snark 上并回信给 joe 时，我的送信程序会傻呼呼地试着把这封回信送给根本就不存在 snark 上的用户 joe。所以我必须动手编辑回信的网址即加上 &lt;@ccil.org&gt;，很快地这变成了一件颇痛苦的事情。</p><p>很明显的这是电脑应该帮我做的，可是现有的 POP 客户端程序却没有任何一支知道要这么做。这使我们学会了第一课︰</p><p><strong>格言1︰好软件都是起源于程序开发者要解决切身之痛。</strong></p><p>也许这已是众所皆知（不是有句着名的谚语叫︰「需求为发明之母」吗？），但有多少软件开发者为了薪水，把时间都耗在写他们既不需要也不喜爱的程序上呢？然而这样的事不会发生在 Linux 的世界 ―― 这也许可以解释为什么由 Linux 社群们开发出来的软件的平均水准都这么高。</p><p>所以，我是否该立即如抓狂般地投入写作一个新的 POP3 客户端的程序来和既有的一较高下？并不如你所想的，我仔细地检视我手上已握有的 POP 工具程序，看看那一个最符合我的需要，因为︰</p><p><strong>格言2︰优秀的程序师知道要写程序，伟大的程序师知道要改写（和重复利用）程序。</strong></p><p>我并非在宣称我是一个伟大的程序师，但我愿去效法。伟大的程序师还有一项重要的特色是制造着偷懒的办法，他们认为人们争取最好的成绩并不是为了努力的过程，而是为了最后的结果。更何况由一个部份可行的解决方法开始总比什么都没有容易得多。</p><p>举例来说，<a href="http://www.tuxedo.org/~esr/faqs/linus">Linus Torvalds</a> 当初写 Linux 的核心程序时也不是从零开始，他是由借重 Minix 的程序和构想开始的（Minix 是一个像 UNIX 的小型操作系统，它在386机器上执行），然而到最后原来属于 Minix 的代码不是被移出就是被改写 ―― 尽管如此，Minix 的代码毕竟曾存在于 Linux 中，并且曾为尚未茁壮的 Linux 提供一个骨架，最后终于诞生了 Linux。</p><p>为仿效这样的精神，我开始找寻一个现有而且写得有条理的 POP 工具程序，来作为我开发新程序的基础。</p><p>在 UNIX 的世界中，原始代码共享的传统让我们可以很容易地重复利用代码，这也是为什么 GNU 项目要选择 UNIX 作为它开发的平台，UNIX 操作系统本身几乎没做什么保留，Linux 的世界也遵行着这个传统，到接近它技术极限的地步，它供人运用的开源程序，有天文数字般地多，所以在 Linux 已有的资源中找到一个足够好的程序要比其他的操作系统容易。</p><p>而我也的确找到了，连我先前的搜寻再加上这一次总共有九个程序候选 ―― fetchpop、PopTart、get-mail、gwpop、pimp、pop-perl、popc、popmail 及 upop。我首先选择 Seung-Hong Oh 写的 fetchpop 作为出发点，我加入了我要的「重写邮件头」功能，并且作了多处的改善。原作者同意将这些纳入 fetchpop 的 1.9 版。</p><p>几个星期之后，我缓缓地读着 Carl Harris 写的 popclient 的源代码，并且发现了一个问题︰虽然 fetchpop 有一些好的初始想法（如它的伺服程序模式），但它只能处理 POP3 的协议，而且它的原始程序只有业余的水准（Seung-Hong 是个聪明的程序设计师，但当时经验不够老道）。而 Carl 写的代码就比较好，具相当的职业水准和稳固性，但他的程序缺乏了许多重要的特色，如 fetchpop 中巧妙的实践（包括我加入的部份）。</p><p>要换还是不换呢？假如我选择换的话，那么换到一个较好的开发基础所要付出的代价就是要丢掉我已经写好的代码。</p><p>事实上我选择换的动机是为了能支持多种 post-office 的协议，虽然 POP3 最广为人采用，但它却不是唯一可用的协议。Fetchpop 和其他同类的程序并不支持 POP2、RPOP 或 APOP，而我早先有一个概略的想法（只是为了有趣）︰加入<a href="http://www.imap.org/">IMAP</a>（Internet Message Access Protocol，最新最强的 post-office 协议）协议的支持。</p><p>一个更理论性的理由让我觉得换到新的开发基础是个好主意，这个理论是早在 Linux 出现前，我就已经学会了︰</p><p><strong>格言3︰「计划好如何舍弃一条路吧，你迟早会想尽办法这么做的。」</strong>（Fred Brooks，《人月神话》，第十一章）</p><p>否则，计划走另一条路吧。针对一个问题，在尚未实践出第一个解法前，你通常并不真正了解这个问题。也许第二次的时候你才能充分了解怎么做才对，所以即使你想做对一件事，但起码你要准备从第一次做起。[^3]</p><p>我告诉我自己︰修改 fetchpop 是第一次。所以我换到 Carl Harris 的 popclient 继续开发。</p><p>当 1996 年 6 月 25 日我送给 Carl Harris 我第一次对 popclient 所做的修正后，我才晓得他已经对这个程序没兴趣了。原来的代码乏人照料已有一段时间，还包括一些次要的错误。有许多修正要做，很快的我们两人都同意由我接手整个程序是合理的一件事。</p><p>在我不经意间，这个项目的规模扩大了，我不再只注意现在的 popclient 要修补那些次要的部分，而是要接下维护整个整程序，在我脑海曾浮现许多主意，我想这可以引导我改变 popclient 的主要部分。</p><p>在鼓励分享代码的软件文化下，一个项目以这样自然的方式演进。我表现出︰</p><p><strong>格言4︰抱持正确的态度，就会发现有趣的问题。</strong></p><p>但 Carl Harris 的态度更为重要，他懂得︰</p><p><strong>格言5︰当你对一个问题不再感兴趣时，你最后的责任就是找位能胜任的接棒人。</strong></p><p>虽然 Carl 和我没讨论这些，但我们却有一个共同的目标就是对这个问题写出最好的解法。现在唯一的问题只剩︰证明我是个可信赖的人，而我已经做到，所以他便欣然地把这个程序交给了我。我希望这个项目在我手中能变得更好。</p><h2 id="第三章-拥有用户的重要"><a href="#第三章-拥有用户的重要" class="headerlink" title="第三章 拥有用户的重要"></a>第三章 拥有用户的重要</h2><p>我继承了 popclient，更重要的是我也继承了它的用户。拥有用户是很棒的一件事，并不是因为这展现出你在解决他们的问题，或是你在做好事。而是好好地培养用户，他们可以变成协同开发者。</p><p>UNIX 的传统中有一种力量，那就是许多用户同时也是程序高手，Linux 促使这变成一件非常愉快的事。这是因为源代码是公开的，所以用户可以变成有影响力的高手，这对缩短除错的时间实在太有助益了。只要你给一点掌声，用户们会帮你诊断问题，建议需要修正的地方，以及改进代码，这比你自己一个人包下全部的事要快许多。</p><p><strong>格言6︰把你的用户视为协同开发人，可以让你伤最少的脑筋而做到源代码的快速改善、程序的高效除错。</strong></p><p>这种效应所造成的影响力很容易就被低估，事实上，开源世界的所有人，几乎都严重低估了因用户增多而产生用以对抗系统复杂度的力量，直到 Linus Torvalds 明白地揭露了这一点。</p><p>其实我认为 Linus 在技术上最聪明和最重大的贡献并不在于写出 Linux 的核心程序，而在于发明 Linux 的开发模式。在一次和他的会面中，我提出了这点见解，他微笑着，并重复他常说的一句话︰「基本上我是一个非常懒的人，因其他人在 Linux 上真正的努力，而感到与有荣焉。」懒惰就像狐狸一样地精明，或者就如同 Rober Heinlein 曾说︰「因为太懒所以成功了。」</p><p>回顾过去的例子，在 GNU Emacs 的 Lisp 程序库及其 Lisp 代码的资源库中，我们可以看到 Linux 模式所用的方法和所得的成功。相对于 Emacs 中用 C 语言写的核心部分及自由软件基金会其他的工具（这都是以建造教堂的模式开发），Emacs Lisp 代码库非常地用户导向并且更新很快，好的点子和原型在最后成熟稳定前常常都已重写过三或四次，藉由互联网而来的非紧密合作进行得很频繁，就像 Linux 一样。</p><p>我在还没写作 fetchmail 前，最成功的杰作大概要算是 Emacs 的 VC（version control）功能了，这项项目进行时，我用像 Linux 一样的合作模式，用 email 和其他三位作者互相联系，到今天为止，我只见过其中一位（他就是 Richard Stallman，Emacs 的作者以及<a href="http://www.fsf.org/">自由软件基金会</a>的创办人）。Emacs 的 VC 功能是作为 SCCS，RCS 及后来的 CVS 的前端处理，提供版本控制功能「按一下」的操作法，这是由某位仁兄撰写的小而有力的 sccs.el 功能改良而来，VC 功能的开发相当成功，这是因为 Emacs 用的 Lisp 程序可以快速地经历「发布 ―― 测试 ―― 改良」，而不像 Emacs 本身核心的开发那样缓慢。</p><p>Emacs 的故事并非特例。有其他的软件结合了双层的架构与双层的用户社区，前者采用教堂模式开发核心，后者采用市集模式开发工具箱。例如 MATLAB，一个商业的资料分析与视觉化工具程序。MATLAB 与其他类似结构的产品都指出，发酵与创新都在开放的部份发生，在那里各种社群都能够修补这些成果。</p><h2 id="第四章-尽早发布，经常发布新版本"><a href="#第四章-尽早发布，经常发布新版本" class="headerlink" title="第四章 尽早发布，经常发布新版本"></a>第四章 尽早发布，经常发布新版本</h2><p>尽早，经常发布新版本是 Linux 开发模式中非常重要的一环。过去，大部份的程序开发者（包括我）认为这个策略对较大型的项目是不好的，因为早期的版本几乎可以定义为多错的版本，我们并不想把用户的耐心消磨殆尽。</p><p>这个过去的信念加强了软件的开发要用建造教堂的方式的想法。假如我们极欲强调的目标是让用户在软件中发现最少的错误，那你何不每半年（或更长）才发布一个新版本，并且在开发新版本的期间，卖力地除错而累得像条狗似的。Emacs 的核心部分（用 C 语言写的）就是用这种方式开发的，但它的 Lisp 程序库就不是。因为 Emacs 的 Lisp 资源库不在自由软件基金会的管辖内，你可以在其中找到新开发的 Lisp 程序使用，而不受限于 Emacs 的发布周期[^4]。</p><p>在 Emacs 的 Lisp 程序库中，最重要的一个来源是俄亥俄州的 elisp 资源库，它先前的精神就已经具有今日大规模 Linux 资源库的特色，但当时我们之中却很少有人思考过我们到底做了什么，甚至想过我们已对自由软件基金会的「建造教堂」的开发模式提出质疑。1992 年左右，我很认真地要把俄亥俄州 elisp 资源库中许多程序加入 Emacs 正式的 Lisp 程序库中，但却遭遇到官方的阻碍而失败了。</p><p>但一年之后，Linux 已受到四方的瞩目，也带来不同而且更健康的观点，Linus 的开放性发展策略和「建造教堂」非常不同。当时 Linux 的两大资源库 sunsite 和 tsx-11 正在萌芽，有许多版本在交流着，Linux 核心系统发布新版本的频繁程度前所未有。</p><p>Linus 以最有效的方法，视用户为协同开发者︰</p><p><strong>格言7︰尽早，经常发布新版本，并且倾听用户的意见。</strong></p><p>Linus 的创新并不完全在此（这在 UNIX 世界是行之有年的传统了），而在于提高这个做法效力的层次，使其能匹配他在开发的系统的复杂度。早期在 1991 年左右，许多人都知道他一天内发布一次以上 Linux 核心程序的新版本。因为他善用互联网和协同开发者们合作更胜于其他人。</p><p>他能我也能吗？还是只有像他这样的天才才办得到？</p><p>我并不认为如此，虽然 Linus 是一位很厉害的高手（在我们之间，有多少人能够完整地写出一个具有商品品质的操作系统核心呢？），但 Linux 并不是一个空前跃进的观念，Linus 也并非（或者说至少目前还不是）如 Richard Stallman 或 James Cosling（NeWS 和 Java 的创始者）这样的天才创新者，而我个人认为他是一位天才工程师，他有避免程序错误及避免程序开发掉入死胡同的第六感，和找到两点间最省力路径的技巧。事实上，整个 Linux 的设计中，我们可以看到 Linus 表现出的品质和他保守而简单的设计取向。</p><p>承上所说，如果快速地发布新版本和彻底地善用互联网媒介不是突然冒出，而是以 Linus 天才工程师洞见所得的最省力路径，那么他把互联网的什么功用发挥到最大？</p><p>其实问题的本身已反应出答案，Linus 让 Linux 的高手和用户们经常感觉刺激和有收获 ―― 感觉刺激是因协助开发 Linux 得到自我满足，感觉有收获是因经常（甚至每天）进步的 Linux 帮助他们把工作做得更好。</p><p>Linus 想直接将投入除错和开发的「人-时」（person-hours）数加到最大，即使要付出的代价是代码的不稳定，或是因一些程序错误被证实无法追踪而吓走原有的用户。Linus 会如此做是因为他相信︰</p><p><strong>格言8︰以足够多的 beta 版测试者和协同开发者做基础，几乎程序中的每一个问题都可以很快地找出来，并且对某些人而言，针对发现的问题的解决方法是显而易见的。</strong></p><p>或者用比较不那么正式的说法︰「足够多的人来看程序，所有的错误都变得浅显」，我将此命名为「Linus法则」。</p><p>我原本的论述是︰「某些问题对某些人而言是容易解决的」，但Linus有不同的意见︰「了解并解决问题的人不一定是第一个发现问题的人」，他说︰「有些人发现问题，有些人解决问题，我愿正式强调 ―― 发现问题是较大的挑战。」而在 Linux 的世界，发现问题和解决问题的速度都很快。</p><p>对「Linus法则」来说，我想这就是教堂模式和市集模式最主要的不同，以教堂建造者的观点来看程序开发，程序错误和相关问题难以处理，并隐伏在深处，需要数个月的工夫仔细察看来找到它们，而这对程序开发者的自信少有加许。开发的期间越长，一旦经冗长等待的新版本发布后不如预期完美，用户的失望也越大。</p><p>另一方面就市集开发模式的观点来看，它假设程序错误都是显而易见的，或者说至少在上千位渴望新版的协同开发者面前，程序错误很快地都变得浅显，因此经常发布新版本是为了获得更多的指正，以及避免偶尔笨拙的修补。</p><p>以上已足够说明「Linus法则」。如果「Linus法则」是假的，那么任何像 Linux 核心程序这样复杂的系统，并且拥有像 Linux 核心程序这么多的高手在开发，早就因沟通不良及未被发现的程序错误而崩塌。反过来说如果「Linus法则」是真的，那正可解释为什么相对地 Linux 比较没有程序错误。</p><p>也许「Linus法则」并不是一个惊奇，社会学家多年前发现，在一群素质相同的观察家中，他们共同做出的预测要比其中任一位单独所做的要来得可信。这被称为「Delphi[^5]效应」。可见 Linus 只是把「Delphi效应」用在开发操作系统时对程序的除错上，所以「Delphi效应」能够克服开发系统的复杂度，即使复杂如操作系统核心[^6]。</p><p>「Linus法则」也可称之为「程序除错可并行处理」。虽然多位程序除错者在除错时需要和一些程序开发者沟通协调，但是程序除错者彼此间却不需如此。所以增加程序除错者并不会像增加程序开发者那样，多出平方倍的复杂度和管理成本。</p><p>理论上造成程序除错效率减低的原因是多位除错者重复同一件工作，就实际的情形而言，在 Linux 的世界中几乎不会发生这样的状况。「尽早，经常发布新版本」这个策略使得程序错误的修补回馈得很快，借此将除错者重复同一件工作的机会减至最低[^7]。</p><p>Brooks 曾发布过一个即席的看法︰「维护一个广为人用的程序的总成本通常是开发这个程序成本的百分之四十或更多，令人讶异的是这维护成本深受用户人数的影响，越多的用户可以发现越多的程序错误。」（这正是我所要强调的）</p><p>因为增加越多的用户，就会增加考验程序的方法，所以用户越多，发现的程序错误也越多，当用户也是协同开发者时这种效应会再被放大，每一位用户以不同的直觉，不同的分析工具，和不同的角度来标明程序错误，因为这些不同，「Delphi效应」似乎真的有作用了，在个别情况下的除错工作，也因这些不同而减少重复出力的可能。</p><p>所以，以程序开发者的眼光看来，增加更多的 beta 版测试者也许不会减少目前藏在深处的程序错误的复杂度，但可以增加某位除错者以他的工具程序找到这个程序错误的机会，而这个程序错误对这位除错者来说是浅显的。</p><p>Linus 也在这种方式上下了赌注。因为程序都会有错误，Linux 核心程序以一种特别的方式来定出版本号码，让用户可以选择要用上一个比较稳定的版本，还是选择错误风险比较高的新版来使用新功能。这个策略尚未正式为大部分的 Linux 高手所採行，但是它也显示出一个事实，就是用户可做选择使得这两种版本都更有吸引力[^8]。</p><h2 id="第五章-有多少眼球驯服了复杂度"><a href="#第五章-有多少眼球驯服了复杂度" class="headerlink" title="第五章 有多少眼球驯服了复杂度"></a>第五章 有多少眼球驯服了复杂度</h2><p>可以很明显地观察到市集模式极大地加速了除错与程序演化。另一件可以清楚明白的是，在微观上，开发者与测试者的每天活动中，市集模式如何与为何可以达到这样的成果。在本章（初版完成三年后，依据开发者多次亲身体验过的洞察力），我们将仔细的检查它的实际机制。非技术性倾向的读者可以略过这一章，直接跳到下一章去。</p><p>一个关键点是，为何没有源代码意识的用户所报告的错不会太有用。没有源代码意识的用户倾向报告表面上的问题，他们把自己的使用环境视为理所当然，所以他们会忽视重要的背景资料，报告错误时很少会包括可信赖的过程。</p><p>这里的问题是测试者与开发者对问题的视角不同，测试者由外向内看，开发者由内向外看。在封闭源代码的体系中，两者只会固守自己的角度谈论事情，因而对另一方深深的失望。</p><p>开源的体系则打破这条界线，使测试者与开发者可以站在同样的角度来讨论事情，这有高效多了。实践中，这将有巨大的差异，一者是只报告表象的症状，一者是以开发者那种以源代码为基础的角度来看问题。</p><p>大部分的时候，大多数的bug是可以由描述开发层级的特征来除错的，即使是不完整的描述。当一个 beta 测试者告诉你在那一行代码有边界的问题时，或告诉你在 X、Y 跟 Z 的情形下，有个变量有问题，指出有问题的代码通常就足够找出问题并修正它。</p><p>因此，对于 beta 测试者与核心开发者来说，有源代码意识的人对于双方都可以强化沟通与合作。换句话说，核心开发者的时间被节省了，即使是在有很多共同开发者的情形下。</p><p>另一个开源方式的特征是节省开发者的时间，而这是典型开源项目的沟通结构。上面我使用了「核心开发者」（core developer）这个字来区别项目核心（project core，通常很小；一个开发者是常见的，一到三个开发者则是很典型的）与项目圈（project halo）的 beta 测试者跟贡献者（通常有数百个）。</p><p>传统软件开发组织的根本问题是「Brooks法则」︰在落后的项目，增加越多程序员会使得项目更落后。一般的状况下，「Brooks法则」的预测是，随着开发者的人数增加，复杂度与沟通成本随着人数的平方上升，而完成的工作却只成线性上升。</p><p>「Brooks法则」依据的经验是，bug会在由不同的人编写的代码的接口上大量出现，而沟通损耗会随着项目参与人数的升高而升高。因此，问题的规模会随着开发者间的沟通路径而呈现平方上升。（精确的说，是 N x （N-1）&#x2F;2，N 是开发者的数目。）</p><p>「Brooks法则」的分析建立在一个隐藏的假设基础上︰项目的沟通结构必须是完全图（complete graph），每个人都可以跟每个人沟通。但是在开源的项目中，开发者在有效平行分割的子项目中彼此很少互动；程序更改与bug报告是透过核心团体来处理的，只有在这样的小团体中，「Brooks法则」的分析才成立[^9]。</p><p>还有其它原因让源代码层级的bug报告变得有效率。事实是一个错误常常会有许多可能的症状，取决于使用的的使用状况与使用环境。这些错误是一些复杂与微妙的bug（像是内存管理错误或视窗的随意中断），也是最难被发现或靠静态分析来捕捉的，这在长期的开发中造成最多的问题。</p><p>当一个测试者发出一个尝试性的源代码层级的多症状bug报告（例如，我看来在第 1250 行代码有个窗口在做讯号处理，或你在哪里把那个缓存清空），可能会给开发者一个关键的线索来发现半打的症状，这些开发者通常因为太靠近底层代码而无法发现这样的问题。在这种案例中，很难找出可从外部看见的不正确动作是从哪个bug引起的，甚至是不可能的 ―― 但是透过经常发布，就不需要知道了。其他的合作者会迅速找出bug是否已被修正。在很多案例中，导致不正常动作的源代码层级bug将被移除，甚至在还没有被报告之前就被移除。</p><p>复杂的多症状错误，通常有很多从表面症状来的方式可以找出真正的bug。这种能让测试者与开发者找出问题的方式，可能与开发环境有关，也可能会随着时间而有无法预期的变化。实际上，当测试者或开发者追踪一个症状时，都是在程序空间的一个集合中「半随机」（semi-random）取样。bug越微妙复杂，越难找出相关的样本。</p><p>对于简单与容易复现的bug，重点在于「半」（semi）而非在「随机」（random）；debug技巧、对程序与架构的熟练都是关键。但对于复杂的bug来说，重点就是「随机」（random），这时人多比人少好 ―― 即使这些少数人是平均技巧较高的。</p><p>如果从表面的症状找出bug的难度大，像是一些无法从表面症状预测的，上述的结果会进一步增强。单一的开发者可能会以一个困难的方式来做第一次尝试，但其实也可以从简单的方式达到同样的结果。另一方面，假如很多人随着频繁的版本一起测试，可能就会有一个人可以用最简单的方式找到bug，节省了大量的时间。项目管理者将会发现，随着新版本发布，许多人一起用各种复杂方法追踪同一个bug的时代将会过去，尤其是在众人浪费太多时间之前[^10]。</p><h2 id="第六章-今花非昨花？"><a href="#第六章-今花非昨花？" class="headerlink" title="第六章 今花非昨花？"></a>第六章 今花非昨花？</h2><p>由 Linus 行为的研究中，我们得到了一个能解释他为什么成功的理论，所以我想要在我的新项目（当然不如 Linux 内核程序复杂和雄心勃勃）中来测试这个理论。</p><p>但我做的第一件事情是大力重组和简化 popclient 的程序，Carl Harris 的实现非常扎实，可是却像许多的 C 程序员一样，含括了一种不必要的复杂，他以代码为主，数据结构为辅，因此代码看起来漂亮，但数据结构却很特殊，甚至可以说是丑陋的（至少以这位老资格 Lisp 高手的高标准而言）。</p><p>然而，我重写程序除了改良原来代码和数据结构的设计外，还有其他目的，就是把它开发到我可以完全了解，否则负责修补你不懂的程序是一件很无趣的事。</p><p>项目进行的第一个月，我简单地依循着 Carl 原来基本设计的用意，第一个重大的改变是我加入 IMAP 协议的支持，我重构原来处理协议的程序，改成一个较为通用的驱动程序再加上三个驱动它的方法表（即 POP2，POP3 和 IMAP）。这个改变阐释了一个广义的原则，特别在像 C 这种先天上未提供动态类型的程序语言，程序员们最好谨记在心︰</p><p><strong>格言9︰聪明的数据结构配上笨拙的代码要比相反的组合好。</strong>[^11]</p><p>Brooks 在《人月神话》的第九章中也说︰「光给我看你的代码，而不给我看它用的数据结构，我会一头雾水。给我看你程序的数据结构，我通常不需要再看你的代码，因为已经够明白了[^12]。」</p><p>1996 年的九月初，从零开始工作约过了六周，我开始在想是否要帮 popclient 取个新名字，毕竟 popclient 已不仅仅是单纯的 POP 协议客户端程序，但我迟疑了，因为 popclient 的设计并无真正重大的改变，我的 popclient 尚须发展出自己的特色。</p><p>当 popclient 可以把 fetchmail 抓下来的信直接转发到 SMTP 的端口时，它彻底的改变了；至于 fetchmail，我稍待会再说明。我之前说过要用这个项目来测试关于 Linus 成功的理论，也许你会问我到底要怎么做呢？我用下面几个办法︰</p><ul><li>我尽早并经常发布新版本（几乎至少每十天就发布一次，甚至在开发的高峰期，一天一次）。</li><li>对于每一位与我讨论 fetchmail 的人，我把他们列入 beta 测试者的名单，所以名单越来越长。</li><li>每当我开发出新版本，一定发出像聊天般的通知给 beta 测试者名单上的人，鼓励他们一起来参与这个项目。</li><li>而我也总是倾听 beta 测试者的心声，询问他们对于这个程序的设计上有无意见，并且回应他们送来对程序的修补和反馈。</li></ul><p>在采用上述的办法后，立即就得到了回报，自从这个项目开始以来，我所收到关于程序错误的报告，其品质足以令许多的程序开发者羡慕，这些报告甚至还常常附上不错的修补办法。因而我做了关键性的思考，我收到了用户的来信，得到了关于新增智慧型功能的建议。这说明了:</p><p><strong>格言10︰如果你视 beta 版测试者如同你最珍贵的资源，那么他们就会成为最珍贵的资源。</strong></p><p>Fetchmail 达到成功的方法中，有趣的是一张薄薄的 beta 版测试者名单，也就是 fetchamil 之友的名单，当我在写这个程序时，有 249 位，然后每周增加 2 到 3 位。</p><p>这张名单中的成员人数最多时几乎到达三百，不过，当我在 1997 年五月底审订这张名单时，其中的成员已经因为一个有趣的原因而开始减少，好几位告诉我他们要停止订阅「fetchmail之友」，因为他们觉得 fetchmail 已能满足他们的需求，已经不再需要收到「fetchmail之友」。也许这是成熟的市集模式项目的正常生命周期中的一部份。</p><h2 id="第七章-Popclient-变成-Fetchmail"><a href="#第七章-Popclient-变成-Fetchmail" class="headerlink" title="第七章 Popclient 变成 Fetchmail"></a>第七章 Popclient 变成 Fetchmail</h2><p>这个项目真正的转折点发生在 Harry Hochheiser 发给我他写的原型程序，这个程序会把邮件转发到客户端机器上 SMTP 的端口，我立即了解到这个特色若有稳定的实现，那么 fetchmail 中其他的邮件传递模式都可以废除了。</p><p>有几个礼拜，其实我一直在扭曲 fetchmail 而不是真的改进它，因为它使用界面的设计虽然能提供服务，但却不够高雅，并且有太多非必要的选项成为整个程序的累赘，尤其是要把取回的邮件存成邮件档或输出至屏幕的选项对我造成了相当的困扰，可是我却也说不出个所以然来。</p><p>当我思考邮件改由 SMTP 转发这个做法时，才发觉到原来的 popclient 包揽太多事了，过去它被设计成邮件转发代理（MTA）兼邮件递送代理（MDA），若藉由 SMTP 转发邮件，那它可以完全不管邮件递送，单纯地负责邮件转发，只要把邮件转给像 sendmail 这样的邮件递送程序就可以了。</p><p>在有支持 TCP&#x2F;IP 通讯协议的平台，几乎可以保证第 25 号端口（SMTP用）早就在那里等了，为什么还要和设定邮件递送代理组态或设定邮件档的上锁附加模式这些问题纠缠呢？尤其这样做可以保证取回的信件看起来像发信人透过SMTP传送一样，而这正是我们想要的。</p><p>在这里给我们上了好几课，第一课是，这个透过SMTP转发的巧思是从我仿效 Linus 的方法以来所得到最大的收获，一位用户提供了绝佳的主意，而我所必须做的已经蕴涵在其中。</p><p><strong>格言11︰仅次于拥有好点子的是从你的用户那里识别好点子，有时候后者反而更好。</strong></p><p>你将会发现一件很有趣的事︰如果你很诚实并很自谦地知道你欠人多少，那么全世界都会认为你发明了全部，而且对你先提出的天才创作，也会以为你非常谦虚，这些我们可以在 Linus 身上得到印证。</p><p>（1997 年 8 月的时候，当我在 Perl 会议上发布这篇论文时，Larry Wall 坐在前排，我念到上一行时，他叫了出来，以一种复兴宗教的神情，喊著︰「兄弟，告诉他们，告诉他们吧！」，全场的听众都笑了，因为他们知道这也发生在这位 Perl 的原创者身上.）</p><p>我以同样的精神进行这个项目，经过短短几周的时间，我开始得到类似的赞美，这些赞美不只来自 popclient 的用户，也来自该得到这种赞美而却未得到的人，我保留了一些感谢函，也许当我怀疑我人生的意义为何时，可以再看看这些信。</p><p>但除些之外，这里还有两课更基础，不具政治性，更适合所有设计的一般情形︰</p><p><strong>格言12︰通常，最有突破性和最有创意的方案法来自于发觉自己对问题原先的观念是错误的。</strong></p><p>我曾试着去解一个错的问题，就是延续 popclient 既是 MTA 又是 MDA 的设计，把它开发成有各种的本地端递送模式。Fetchmail 的设计需要重新思考，应该只要单纯地做一个 MTA 程序，成为因特网正规的 SMTP 邮递路径中的一段。</p><p>当你在开发程序的过程中撞到障碍时 ―― 也就是当你发现很难想出下一步要怎么修补时，通常是反省的时候了，但不是问是否已找到正确的答案，而是我们提出正确的问题了吗？也许问题需要再重新整顿一番。</p><p>是的，于是我重新整顿了我的问题，很明显地，该做对的事有︰（1）在原来通用的驱动程序中，加入转发邮件至 SMTP 端口的功能。（2）把它作为预设模式。（3）丢弃其他递送模式的代码，尤其是递送至邮件档及递送至标准输出。</p><p>我对第（3）步迟疑了一些时候，因为担心会吓走长久以来 popclient 的用户，因为他们一直倚靠另一种递送机制，理论上他们可以立即以 .forward 档来达到同样的效果而不靠 sendmail 程序，事实上这个转换可能含糊不清。</p><p>但当我真的去做，结果证明益处极大，popclient 驱动程序中的一段可以消失了，设计也变得简单多了 ―― 不用再屈就系统的 MTA 程序及用户的邮件信箱档，也不再需要担心底层的操作系统是否支持文件锁。</p><p>而且唯一丢掉邮件的可能也不见了，如果你指定要把邮件送到某个文件而磁盘空间又满了，那么你的邮件就丢掉了，然而由 SMTP 转发信件的话，则不会发生这种事，因为 SMTP 的接收者除非将信息送达，或至少先暂存起来待会再送，才会回复成功给发信者。</p><p>并且效能也改进了（如果只跑一次，你大概不会有感觉）。另一个有意义的好处是使用说明变得更简单了。</p><p>稍后，为了要处理某些模糊的状况，如动态 SLIP，我必需让用户可以指定本地端要用哪一个 MDA 程序来送达邮件，我发现了一个更简单的方法。</p><p>这寓意是什么呢？当你可以丢掉程序中老旧的特色而又不失掉效力，那就别迟疑。Antoine de Saint-Exupery[^13]（当他还不是经典童书的作者前，他当过飞行员和飞机设计师）曾说︰</p><p><strong>格言13︰设计上完美，不是「没有东西能再被加入」，而是「没有东西能再被移出」。</strong></p><p>当你觉得做对了，那么你的代码越来越好，越来越简洁，在这个过程中，fetchmail 的设计终于和先前的 popclient 不同了，而有了自己的特点。</p><p>该是这个程序改名字的时候了，新的设计看起来比旧的 popclient 更像 sendmail，新的 popclient 和 sendmail 都是 MTA，只是 sendmail 把邮件「推」出去给 SMTP 收信程序，再送达用户，而新的 popclient 则是把邮件「拉」回来给 SMTP 收信程序，然后再送出，所以两个月后，我把它更名作「fetchmail」。</p><h2 id="第八章-Fetchmail-成长了"><a href="#第八章-Fetchmail-成长了" class="headerlink" title="第八章 Fetchmail 成长了"></a>第八章 Fetchmail 成长了</h2><p>我把 fetchmail 设计得雅洁而新颖，程序本身也跑得很好，因为我天天都在用，并且开始有一些 beta 版测试者加入，这情形使我逐渐了解，我已不再是为了可能让少数其他人能得到一些便利，而在进行用处不大的程序开发，我已经为每一位有台 UNIX 机器，上面跑 SLIP&#x2F;PPP 来取得电子邮件的玩家们，写了一个真正满足他们需要的程序。</p><p>因为借 SMTP 端口转发邮件的这个特色，潜在使得 fetchmail 足以成为同领域的杀手级程序，在同类的典型程序中，它已经够资格占到适当的位置，使得其他程序不是被舍弃就是几乎被遗忘。</p><p>我认为你不该设定或计划会有这样的结果。你必须有强大的想法并全力投入，以至于之后的结果似乎是无可避免的，自然的，甚至是注定的。要追求像这样好的结果，唯一的方法就是先拥有许多的想法，或者以工程上的判断去取得别人好的想法，而在此处这个想法的利用已超出原创者的想像。</p><p>Andrew Tanenbaum 在 386 上造出了一个简单的原生 UNIX 系统，他原先的想法只是用来作为教学的工具，但 Linus Torvalds 把这个 Minix 系统的观念拓展开来，更进一步，已经超过 Andrew 当初能够想像到的开发，并且成长出一些令人赞叹的事物。我用一样的方式（虽然规模较小），由 Carl Harris 和 Herry Hocheiser 那里得到一些想法，然后把它们发扬光大。在人们的想像中，历史上的原创者都是天才，而我们两位都不是，但是大部份的科学发展和软件开发工作，完成者不是天才原创者，反而是行家们。</p><p>Linux 和 fetchmail 的成果都是一样令人兴奋，事实上这就是每一位高手追求的成功！这些成果指示我应该把标准设得高一点，把 fetchmail 发展到我所能想像的高度，我已不只是为自己的需求而写，也为其他人所需要的功能而写，并且还要同时保持程序简单和强健。</p><p>第一个加入的重大特色是「集体邮箱」的支持 ―― 这个功能可以抓下累积在同一个群组信箱中，而属于不同用户的信件，然后再分送给原来的个别收信人。</p><p>我决定加入对「集体邮箱」的支持，部分是因为有一些用户们嚷嚷着他们需要它，但主要是因为我认为它会迫使我以更通用的法则来处理邮件头的地址，并借此除去「一人一信箱」功能代码中的错误，而我的确也做到了。为了让程序能按 RFC 822[^14] 中的规定来检查信息的语法，花了我相当长的时间，不是因为规定的个别片段难以理解，而是因为它包括了成堆相互依赖的琐碎细节。</p><p>结果「集体邮箱」的支持的确是一个漂亮的设计，我是怎么知道的呢？</p><p><strong>格言14︰任何的工具以我们所知道的方法来使用都会有用，但一个真正了不起的工具会以你从未想过的使用方法来发挥它的功能。</strong></p><p>支持「集体邮箱」的 fetchmail 有一种意料之外的使用方法，就是在以 SLIP&#x2F;PPP 连线方式连上 ISP 的客户端执行「邮递讨论名单」（mailing list），因为它可以配合客户端的多用户共用 ISP 上同一信箱（用别名 ―― alias ―― 的方法），让每个用户都能在名单上，这表示我们可以在个人的电脑上，透过一个 ISP 的帐号，来维护一个邮递讨论名单，而不必持续连著 ISP。</p><p>另一个来自我 beta 测试版的用户的重要需求是接受 8 位 MIME 邮件格式，这很容易做到，因为我过去一直都小心地保持每一个ascii码都是完整的 8 位，并非我未卜先知，而是我遵从另一条法则︰</p><p><strong>格言15︰写作任何的网关类软件时，要尽可能地不去扰动到通讯的数据流 ―― 并且绝对不要丢掉其中任何的数据，除非接收方强迫你这么做。</strong></p><p>如果我当初没有遵从这项原则，那么 8 位 MIME 的支持势必难以加入并容易出错，所以我需要做的只是研读 RFC 1652[^15]，然后加入显然得知的代码以产生 MIME 的标头。</p><p>一些欧洲的用户要我在程序中加入选项，用来限制每次连线取回邮件的数目（这样他们才能控制昂贵的电话线路连线花费），我拒绝了许久，甚至到现在，我对这个选项的加入仍感到不太愉快，但假如你是在为全世界写程序，那么你就应该听取你客户们的意见 ―― 这个原则不会改变，因为他们会以金钱之外的形式给你报酬。</p><h2 id="第九章-由-Fetchmail-学到的一些经验"><a href="#第九章-由-Fetchmail-学到的一些经验" class="headerlink" title="第九章 由 Fetchmail 学到的一些经验"></a>第九章 由 Fetchmail 学到的一些经验</h2><p>在我们回头讨论一般软件工程的议题前，由 fetchmail 得来的一些特殊教训值得深思。</p><p>Fetchmail 配置文件（rc file）的语法包括可有可无的关键字，这些如「噪音」般的字眼会被语法分析程序忽略，这些字的加入，使得配置文件的语法和英文很接近，和传统中简洁的「关键字 ―― 设定值」配对表示法（把噪音字去掉就可以得到）比较起来，要来得容易阅读。</p><p>这个教训开始于某一个夜晚的实验，我注意到配置文件中的宣告语法可以组成一个迷你的祈使语言。（这也是为什么我把原来 popclient 中的关键字 server 改成 poll）。</p><p>对我而言，如果把这个祈使语言弄得更像英文，那会让 fetchmail 更易于使用，虽然我现在信服如 Emacs、HTML 及许多数据库引擎制定出来的模范语言，在正常情况下我也不那么迷恋英文的语法。</p><p>传统的程序员喜欢非常精确而简洁的配置语法，不希望有任何冗余在其中，这是因为早期的电脑计算资源昂贵而遗留下来的观念，他们认为语法分析的过程要节约计算资源，并要尽可能的简单。英文的语句大约有百分之五十的冗余，所以不利于做为配置语法。</p><p>但这并非我在正常的情况下不用英文语法的原因，我在此提及是为了推翻像英文的语法不适合作配置语法的论点，当中央处理器和内存都变得便宜时，配置语法的简洁已不再是我们的目标，现在的情况是︰一个电脑语言中符合人性易于使用的重要性已超过节约电脑的计算资源。</p><p>然而还是有好几个地方要小心，其中之一是语法分析过程变得比较复杂的代价 ―― 你不会想把这个特点（使用像英文的配置语法）变成程序错误的来源及用户的疑惑处。另一个是当我们要订出一个像英文的语言时，通常需要做些修改，表面上看起来修改过后的语法可重组出自然语言，但可能也会因修改过以致于和传统的配置语法一样，令人感到疑惑。（我们可以在许多所谓的第四代程序语言和商业用的数据库查询语言看到这个现象）</p><p>Fetchmail 的控制语法看起来避免了这个问题，因为我严格地限制控制语法的范围，它不是一个以通用为目的的语言，它简单并不很复杂，所以在极小的英文子集和真正的控制语言之间的相混处很少，我认为这里还有一个更广义的教训︰</p><p><strong>格言16︰当你设计的语言没有一处是 Turing-complete，你可以采用比较平易的语法。</strong></p><p>另有一个教训是关于含糊的保密性，有一些 fetchmail 的用户要我修改程序，以把经保密处理的凭证储存于配置文件内，这样一来，偷窥者就没办法看到真正的密码了。</p><p>我并没有这么做，因为这个做法并不能达到真正的安全，能拿到读取你配置文件权限的人，也能以你的身份执行 fetchmail ―― 如果你的密码经保密处理存在配置文件中，他们可以由 fetchmail 中取得解码程序来得到你真正的密码。</p><p>如果我把程序改成可以在 fetchmail 的配置文件中储存保密的密码，那会给认为这并不难的人们对保密性的错误观念。一般的守则应该是:</p><p><strong>格言17︰一个保密系统是否安全依存于它隐藏的秘密，注意不要有「虚拟秘密」。</strong>[^16]</p><h2 id="第十章-市集模式必要的条件"><a href="#第十章-市集模式必要的条件" class="headerlink" title="第十章 市集模式必要的条件"></a>第十章 市集模式必要的条件</h2><p>早先看过这篇文章的书评家和试读者都提出同样的问题，那就是以市集模式开发软件，获得成功的先决条件为何？包括项目领导人的资格，代码到什么样的程度，才对社群发布并开始成立协同开发团队。</p><p>相当明显的，任何人无法以市集模式建立软件基础[^17]，但是可以用市集模式来测试，debug，改进软件，在一个项目的起始点很难运用市集模式，Linus 没试过，我也没有。项目初始的协同开发团队需要有一些东西可以测试，可以执行。</p><p>当你开始召募项目团队时，你必须能提出大致合理的保证，你的程序不需要运作得很好，它可以暴力，有错，不完整，及注释贫乏，只要它可以使潜在的协同开发者相信，这个程序在可预见的未来大有可为。</p><p>Linux 和 fetchmail 公开发布时都具有强健及吸引人的设计，许多人认为这和我所报告的市集模式有所不同，并以为这样的设计很重要，甚至进一步做出一个他们的结论 ―― 高度的设计直觉和聪明是一个项目领导人不可或缺的特质。</p><p>但是 Linus 的设计由 UNIX 而来，我的设计由原先的 popclient 而来（虽然它后来改变甚大，比例上说来还超过 Linux），所以市集模式项目的领导人或协调者真的需要格外的设计技巧？或者能提升别人的设计技巧呢？</p><p>我想对于项目协调者是否能做出耀眼的设计并不重要，最重要的是协调者是否能认知别人在设计上的好点子。</p><p>Linux 和 fetchmail 都证明了这件事，Linus 这位仁兄如同之前所讨论的，他并不是伟大的创新设计师，但他展现了另一种卓越的技巧，即认同别人好的设计点子，且将这些好的设计整合到 Linux 的核心中。而我之前描述过 fetchmail 最有力的设计（藉 SMTP 转发邮件）也来自他人。</p><p>这篇文章的早期读者指出︰我低估了市集模式项目中创造力的重要性，因为我自己本身就已具备了许多的创意，所以将此视为理所当然。这真是抬举我，也许这说法有几分真实，相对于写程序及debug，设计应该是我最强的本领。</p><p>但以聪明和创意来设计软件的问题在于「习惯的养成」 ―― 当你应该保持程序的强健和简洁时，反而把它弄得花哨而复杂，我曾因犯了这个错以致于把项目搞砸了，但我在 fetchmail 这个项目中小心地控制，避免发生这种错误。</p><p>所以我相信 fetchmail 项目的成功部分的原因是我防止设计上「聪明」的倾向，这个论点（至少）已经反驳了设计上的创意是市集模式项目成功的基本条件。以 Linux 来说，假设 Linus Torvalds 在开发程序的过程中，试图在操作系统的基本设计上力求创新，那么我们现在已有的 Linux 内核程序会如此稳定和成功吗？</p><p>当然，任何想开始一个市集模式项目的人，应该具备基本程度的设计能力和写程序技巧，但我认为如果他们有认真想过，那他们的程度应该已在要求之上。开源社群对于名誉的重视，给予其中的人们一种微妙的压力，如果无法胜任项目后续的开发，那么就不会想去开始，直到目前，这种惯例似乎仍运作得很好。</p><p>还有一种技巧，通常与我们不会把它和软件开发联想在一起，但我认为这和市集模式项目中聪明的设计一样重要，也许还更重要，就是市集模式项目中的协调者或领导人必须有人缘和好的沟通技巧。</p><p>这应该很明显，为了召集开发社群，你需要吸引人们，让他们对你所做的有兴趣，并且保持他们加入后工作愉快。技术上的末节很难达成这样的目标，更难以完成整个项目，你个人的人格特质也和项目息息相关。</p><p>Linus 是一位好人，令人喜欢并乐于帮助他，这不是巧合，我精力旺盛，活泼外向，喜爱为群众们工作，并具有喜剧演员的本能，这也不是巧合，为了让市集模式项目顺利运作，如果能用一点小技巧来吸引人们，那帮助会很大。</p><h2 id="第十一章-开源软件的社会关联性"><a href="#第十一章-开源软件的社会关联性" class="headerlink" title="第十一章 开源软件的社会关联性"></a>第十一章 开源软件的社会关联性</h2><p>我们谈过︰最好的程序起自于作者个人要解决他每天的切身之痛，然后因为这通常也是许多人的痛处，所以这个程序便开始传播，这让我们把<strong>格言1</strong>用另一种更有用的说法来陈述︰</p><p><strong>格言18︰要解有趣的问题，从寻找你感兴趣的问题开始！</strong></p><p>所以 Carl Harris 写了早期的 popclient，而我写了 fetchmail，然而这句格言应早已为人所知许久，Linux 和 fetchmail 开发的历史似乎要让我们注意到这有趣的一点，就是软件开发的下一步 ―― 用户和协同开发者组成了庞大而活跃的社群，带动软件的演化。</p><p>在《人月神话》一书中，Fred Brooks 观察到︰程序员的时间有不可替换性，在一个进度已经落后的项目中，加入更多的开发者只会使进度更加落后，他讨论到一个项目的复杂度和人员间沟通的代价以参与开发人数的平方倍成长，而完成的进度只随人数做线性成长，这个声明自从发布以后，就被称为 Brooks 定律且被视为真理，但假如 Brooks 定律主宰了一切，那么根本就不可能有 Linux 这个操作系统。</p><p>Gerald Weinberg 的经典著作《计算机程序写作之心理学》（The Psychology of Computer Programming）中有后见之明，提出对 Brooks 定律极为重要的修正，在 Weinberg 对「忘我编程」（egoless programming）的讨论中，他观察到在软件工作室中，如果程序员们不只「自扫门前雪」，而是鼓励其他的程序员去看他们的程序，以找出错误或提出改进的建议，那么程序改善的速度会远超过每个程序员只顾自己的情况。</p><p>也许 Weinberg 的术语选择不当，以致于原本该为人所接受的观念却未被接受，当想到用「忘我」（egoless）来形容因特网上的电脑黑客，令人发出微笑，但我认为他的论点在今天要比过去更有力。</p><p>集市模式通过充分利用「忘我编程」效应，有力地减轻了 Brooks 定律的影响。Brooks 定律背后的原理并没有被废除，但考虑到庞大的开发者群体和廉价的通信，它的影响会被在其他方面并不明显但更有力的的非线性效应所淹没。这类似于牛顿经典物理学和爱因斯坦相对论之间的关系–旧系统在低速宏观世界中仍然有效，但如果你把质量和速度推得足够高，你就会得到惊喜，比如核爆炸或Linux。</p><p>UNIX 的历史其实早已准备好我们从 Linux 学到的东西（以及经由我实验得证的事情，这个实验经过仔细地仿效 Linus 的方法[^18]，但规模较小），当大家还认为写程序仍然是单打独斗的行为时，真正了不起的黑客已经在善用社群的注意力和脑力。在一个封闭项目中的程序开发者，他们只单靠自己的头脑，所达成的进度将落后于知道怎么搞一个开源项目的开发者，因为在开源的项目中，有数以百计的人在报告错误及改进程序。</p><p>但是传统 UNIX 的世界因为好几个原因，无法把这个方法的功效发挥到最大，其中包括︰不同版权的法律限制，商业机密，市场上的利益等等，还有一个原因（算是后见之明）就是︰当初的因特网还不够发达。</p><p>在廉价的因特网来临之前，有一些地域性的社群集中在一起，他们的文化鼓吹著 Weinberg 的「忘我」的程序写作，其中的程序开发者可以轻易地吸引许多有技巧的建言者和协同开发者，如贝尔实验室，麻省理工学院人工智能实验室及加州大学伯克利分校 ―― 这些地方都是创新的来源，都带有传奇色彩，至今都仍具有影响力。</p><p>Linux 是第一个致力于把全世界当成是它智库的项目，我并不认为在 Linux 的孕育期恰好诞生了全球资讯网是个巧合，而且在 Linux 开发的早期，因特网服务供应商的事业正在起飞，因特网的主流商机正在爆发，Linus 是第一位学会在因特网普及的情况下利用新游戏规则的人。</p><p>虽然廉价的因特网是 Linux 模式演进的必要条件，但我认为它并非充分条件，另一个极重要的因素是项目中领导人的领导风格，以及一群合作的客户，其中有人会被开发者吸引而成为协同开发者，进而把网络媒体的功能发挥到最大。</p><p>但我们要问什么是领导风格？客户是哪些人？他们之间的关系并非依赖权力而建立 ―― 或者就算是，强制的领导风格没办法带给我们今天这样的成果，Weinberg 引用十九世纪俄国无政府主义者 Pyotr Alexeyvich Kropotkin 自传中＜纪念一位革命家＞（Memoirs of a Revolutionist）的一段，来解释这个问题︰</p><blockquote><p>因自幼在拥有佃农的地主家庭中长大，当我的生命开始活跃时，就像那时所有的年轻人一样，我们非常相信命令，指使，责骂以及处罚等等行为的必要性，但当我早期必须管理正式的企业时，我要和自由的人打交道，任何错误可能最后都会引发严重的后果，我才开始接受命令和规定与建立共识的不同之处，前者在军事体系中效用极佳，但在真实的生活中却一文不名，真实生活中的目标，是在许多人同心协力下达成的。</p></blockquote><p>「许多人同心协力」（severe effort of many converging wills）正是像 Linux 这样的项目所需要的 ―― 「命令法则」（principle of command）并不适用于被我们称为因特网的无政府主义者志愿者，为了更有效的运作和竞争，想要领导与他人合作的项目的电脑黑客，必须学习如何吸引和激励有兴趣的社群，并且是在 Kropotkin 所建议的「共识法则」（principle of understanding）的模式下进行，他们也必须要学习去使用「Linus法则」[^19]。</p><p>稍早我提及「Delphi效应」是因为它可能可以解释「Linus法则」，但在生物学和经济学中的自适应系统中，有更多类似的地方可以更有力地印证它，Linux 的世界从许多方面看来，像是一个自由的市场或生态，由一群个体所组成，这些个体以一种自发性的自我更正程序，试着去发挥他最大的功用，所发挥出来的功用比起集中式的规划要来得更精巧，更有效率，这种方式正是在寻求「共识法则」（principle of understanding）。</p><p>Linux 黑客们最大化的实际利益不是典型的经济价值，而是在黑客中得来无形的自我满足和荣誉，（你也许可以认为他们的动机是「利他」，但这忽略了一项事实，就是利他主义只是利他主义者自我满足的一种形式），以这种方式进行的志愿者文化并非真的不寻常，就我长期参加的一个科幻小说俱乐部来说，它不像电脑黑客俱乐部那么明显地以「egoboo」（ego-boosting 或在同好圈里增强某人的信誉）做为驱动志愿者的力量。</p><p>Linus 在 Linux 项目中，成功地坐上项目守门员的位置（这个项目大部份的工作都由其他人所完成），也成功地培养项目的利基，直到它可以自我维持，这显示 Linus 精确地抓住 Kropotkin 所说「建立共识」的精神，用这个像经济学的观点来看 Linux 的世界，让我们知道共识是如何作用的。</p><p>我们可以把 Linus 的方法，视作一条开创有效率市场的路 ―― 以最强韧的方式联合个别的黑客来达成困难的目标，这些目标只有在持续的合作下才能达成。在 fetchmail 的项目中（虽然规模比较小），我已经展示出 Linus 的方法可以用在别的项目，并同样有好的成果，或许我有意地，更有系统地利用他的方法。</p><p>许多人（尤其是在政治上不信任自由市场的）以为重视自我的个体文化会造成分裂，自扫门前雪，浪费，私密，和敌对，只要举一个简短的实例，就可以很明显地证明这个看法是错的，这个例子就是 Linux 相关的说明文档的多样，品质，和深度都相当令人惊讶，程序员不喜欢写说明文档似乎是金科玉律，但 Linux 的黑客们是如何写出这么多的文件呢？很明显地，Linux 重荣誉的自由市场运作得要比商业软件生产者重金投资的说明文档撰写公司好。</p><p>Fetchmail 和 Linux 这两个项目都展示出藉由适当地回报许多黑客，优秀的开发者或协调者能利用因特网，获得许多协同开发者，但不致让项目因混乱而失败，所以针对 Brooks 定律，我提出以下的反驳︰</p><p><strong>格言19︰假如项目开发协调者拥有至少跟因特网一样好的媒体，而他也不靠强制力来领导，那么一群人必定胜过一个人。</strong></p><p>我认为开源软件的将来属于知道如何进行 Linus 游戏规则的人，属于离开教堂拥抱市集的人，这并不是说个人的眼光和智慧不再重要，而是我认为开源的软件的优势将属于一种人，他以个人的眼光和智慧开始一个项目，并且之后能有效地号召有兴趣的志愿者群来加入他的项目。</p><p>也许不只是开源的将来，非封闭性源代码的开发者也能吸引 Linux 社群的智库到他们的问题上，很少有人付得起 fetchmail 项目中超过两百位的贡献者的雇佣费用。</p><p>也许最后开源文化会赢，但不是因为合作是善的，或软件「栅栏」（hoarding）是恶的（假设你相信后者，但 Linus 和我则否），而是因为封闭源代码的世界无法在演化的角力中胜过开源的社群，社群能投入的资源要比封闭源代码的项目来得多。</p><h2 id="第十二章-管理与马其顿防线"><a href="#第十二章-管理与马其顿防线" class="headerlink" title="第十二章 管理与马其顿防线"></a>第十二章 管理与马其顿防线</h2><p>1997年版的《教堂与市集》这篇文章的结论是 ―― 网络上由程序员（或者该说是无政府主义者）形成的快乐游牧民族，正以锐不可挡的气势冲击著传统封闭软件的阶层式世界。</p><p>仍有许多怀疑论者不能信服，但他们提出来的问题应该受到公平的审视，对市集论点最主要的反对意见可归结为︰市集的支持者低估了传统管理的生产力乘积效应（productivity-multiplying effect）。</p><p>传统的软件开发经理人反对的论点在于开源项目的偶然性（casualness），项目团队在偶然中成立，改组，和解散，虽然开源社群比起任何封闭开发者拥有人数上明显的优势，但偶然性却否定了这个优势。他们目睹软件开发需在时间上持续付出代价，并且要看客户是否继续投资重量级的产品，而不是有多少人把骨头丢到锅里等待它熬成汤。</p><p>这个论点有一些意义，但事实上我已在《神奇熔炉》（<em>The Magic Cauldron</em>）这篇文章中指出，未来软件产业经济的关键在于服务价值。</p><p>这个论点也隐藏着一个大问题，就是它假设开源项目无法长久维持，事实上，确实有长久持续开发的开源项目，一直保持一致的开发方向和有效的维护者社群，但其中却没有传统项目管理上的激励组织或制度化控制。GNU Emacs 编辑器的开发正是一个极端且具有代表性的例子，它在十五年间，以统一的结构观点，吸收了数百位贡献者的努力，尽管参与的人这么多，其实只有一个人（原作者）在十五年间持续活跃著。没有一个封闭源代码的编辑器曾创下如此长寿的纪录。</p><p>在此，我们有理由质疑传统管理下的项目开发，但这却与其他教堂与市集的论战无关。如果 GNU 的 Emacs 编辑器可以在十五年间，保持一贯的结构，在过去八年间，虽然硬件平台的技术进步飞快，Linux 操作系统也同样做到了，假如（事实如此）有这么多结构良好的开源项目持续的时间超过五年，那么我们不禁要问，传统的项目管理除了带来巨大的额外花费，是否还有其他益处？</p><p>传统管理下的软件项目当然不保证在期限内有效执行，不保证不超支预算，不保证实现所有的规格，很难得有一个「管理下」的项目能达到以上任一个要求，更不用说三个都达到了。管理下的项目似乎在它的生命周期中，很难去适应技术上和经济环境上的变化，而开源社群却已证明了开源项目有更高的绩效。（我们可以做一个基本的验证，例如比较因特网三十年的历史和短命的私有网络技术，或者微软windows系统由 16 位转移到 32 位付出的代价和同时期 Linux 轻易地移植到 Intel 系列之外超过一打的平台，其中包含 64 位的 Alpha。）</p><p>许多人认为传统商业软件模式下，某些人能提供法律上的保证，如果该软件的方向错了，还可以补救回来，但这是个错觉，大多数的软件合约只宣告商业上的保证，而不是「履行」的保证，而且很少见到有未完成软件成功地补救回来。即使这种情形稀松平常，因为有人可以告而让我们感到宽慰并不是有意义的事。我们不要诉讼，我们要可用的软件。</p><p>到底传统项目管理的额外花费带来了什么？</p><p>为了了解这个问题，我们首先必须弄清楚软件项目管理者做些什么事，一位我认识的女士在这个工作上表现优异，她说软件项目管理有五个主要功能︰</p><ol><li>定义目标，确保每一位成员方向一致。</li><li>监督并且确定重要的细节没有被忽视。</li><li>诱导成员去做乏味但必要的苦工。</li><li>调整成员组织以期发挥最大生产力。</li><li>安排足够的资源以支持整个项目。</li></ol><p>这些很明显地都是很有价值的目标，但在开源模式，及开源的社会意义下，这些目标看起来似乎很突兀，我们以倒过来的顺序看︰</p><p>我的朋友提到争取资源基本上是防御行为，一旦你有了人，有了机器和办公室空间，你就必须保卫他们，以防被其他项目经理抢走，或者被高层榨干。</p><p>但开源的开发人都是志愿者，在所从事的项目中，依个人的兴趣和能力，自行分工（就算他们是在有给职下精研开源软件，一般而言，上述仍然属实。）志愿者的风格自动倾向于争取资源的攻方，他们带来自己所拥有的资源，因此对开源项目的管理者来说，很少需要打传统的「保卫战」，或者根本就不必要。</p><p>不论如何，在廉价的个人电脑和快速网络网络的世界中，我们发现了一个非常一致的事实︰唯一有限的资源，就是具熟练技术的参与者。当一个开源项目成立后，原则上不需要争取电脑，网络或者办公室空间，只有当开发者们失去兴趣时，它才会结束。</p><p>以此为例，非常重要的一点︰开源的黑客们如何自行分工以发挥最大的生产力 ―― 这个环境会冷酷地挑选出称职者。我的朋友同时熟悉于开源世界和大型封闭性项目，她相信开源已算是局部成功了，因为它的文化只接受最具才能的5%或说是写程序的人。她大部份的时间花在组织运用其余95%的人，并且亲身见识到（许多人都知道）最强的程序员的生产力和仅能胜任的程序员相差100倍。</p><p>这个差异的倍数一定会引来一个笨问题︰如果个别的项目，甚至整个领域，把能力差的人减到少于 50%，不就好了吗？熟虑的管理者早已知道︰如果传统软件项目管理的功能只在于把能力不及格的人训练到及格，那么软件项目管理就不值得去做了。</p><p>开源社群的成功，更加突显出这个问题，证明由因特网上征召自行分工的志愿者，通常省钱又有效，胜过管理整栋在做其他事的人。</p><p>以上把我们带向「动机」的问题，与我朋友观点同义的，且常听到说法是︰传统软件项目的管理，是对于缺乏主动性的程序员的一种补救措施。</p><p>这个答案通常伴随一点声明︰我们对开源社群能完成工作的信赖，源自于「性感」的吸引力或者技术上的喜悦，缺乏这两个要素的工作，如果不是没人做，就是做得很糟，除非有经理挥动鞭子，驱使不自由的受雇者去搅局，我在＜<a href="http://www.tuxedo.org/~esr/magic-cauldron/"><em>Homesteading the Noosphere</em></a>＞这篇文章中已经由心理和社会的因素去质疑这个论点。然而就现在的目的而言，我想︰点出接受这种说法背后的意义会更为有趣。</p><p>如果传统，封闭，重管理的软件开发风格所防御的是无趣的问题，那么在该应用领域中，以马其顿防线为手段，只有在无人发现这些问题的趣味，或者无人绕过这些问题的情况下，才算有效。但在目前，软件无趣的部份有了开源的竞争者，用户将知道最后有人处理的原因是︰因为问题本身的魅力，吸引了解决问题的人 ―― 不只在软件界，或者其他创造性的工作中，问题的魅力是一个比只提供金钱还更有效的推动因素。</p><p>如果运用传统的管理结构只是为了激励被管理者的动机，那么这也许是一个好的战术，但却是个坏的战略，短期内会赢，但在长期会输。</p><p>到目前为止，传统软件项目管理看起来有两点（安排资源，调整组织）比不上开源，似乎在第三点（动机）上苟延残喘，而被围攻的可怜经理，在监督的工作上得不到任何援助；而开源社群最强的一点就在于分散式的审校，这点胜过确认有无细节被遗漏的任何传统方法。</p><p>我们可不可以略去讨论定义目标是不是传统项目管理的额外付出呢？也许吧，但如果要这么做，我们需要一个好理由让我们相信︰管理委员会和运作计划在定义有价值和广义的目标时，要比开源世界的项目领导人和资深参与者更成功。</p><p>表面上看起来很困难，但并不是因为作对的开源社群（Emacs 的长寿，Linus Torvalds 谈论「称霸世界」以激励开发者的能力）造成的，因为定义软件项目的目标，是传统机制下的宣示性庄严。</p><p>软件工程中最为人所知的一个理论是︰有60%到75%的传统软件项目如果不是未完成就是被用户所拒用。假如这个数字范围和真实状况很接近（我尚未遇过有经验的经理人在争论这个数字），那么就有更多的项目没有遵循目标开发，而目标如果不是（a）不切实际就是（b）错了。</p><p>这点更甚于其他问题，在今天的软件工程世界，「管理委员会」（management commitee）这个惯用语令听的人脊背发凉 ―― 即使（或者特别地）听者本身就是管理者，只有程序员会如此的日子早已过去了；管理者桌上现在都放有「呆伯特」（Dilbert）漫画[^20]。</p><p>因此，我们对传统项目管理者的回应很简单︰如果开源社群真的低估传统管理的价值，那为什么你们当中有这么多人鄙视你们自己管理的作为呢？</p><p>既存的开源社群又再次突显出这个问题 ―― 因为乐趣在我们所做的工作中，我们有创意地游戏着，已经以惊人的速度带来技术上，市场占有，和心灵分享上的成功，我们正在证明我们不只能写出更好的软件，而其中的乐趣也是一项资产。</p><p>在这一篇文章第一版发布后的两年半，我所能提供的最基本想法，已不再限于开源的视界，但毕竟对许多在过去这些日子身陷诉讼而清醒的人而言，这些想法似乎都是合理的。</p><p>甚至，我想提出一个对于软件更深广的认识（也许对每一种造创或专业的工作都适用）在最适挑战 ―― 不会太容易而令人厌烦，不会太困难而难以达成的工作中，人们会获得乐趣，一个快乐的程序员的条件是︰工作量不会太轻，也未被定义不良的目标和压力下的摩擦过度压榨。享受乐趣确保了效率。</p><p>相对于在你的工作过程中，如果有恐惧和强烈的厌恶（即使如呆伯特漫画中表达出的变换或讽刺方式），那就表示这个工作过程是失败的。乐趣、幽默、和游戏性是真的资产，这也是我前面为什么写出「快乐的游牧民族」这个名词，而 Linux 的吉祥物是隻人见人爱的企鹅也不仅是个笑话。</p><p>将来的事实会证明开源最大的成功之一就是它告诉了我们︰如玩游戏般地工作是从事创造性工作最经济、最有效率的模式。</p><h2 id="第十三章-结语︰网景公司拥抱市集"><a href="#第十三章-结语︰网景公司拥抱市集" class="headerlink" title="第十三章 结语︰网景公司拥抱市集"></a>第十三章 结语︰网景公司拥抱市集</h2><p>当你真的在影响历史时，那种感觉真的很不一样…</p><p>1998 年 1 月 22 日，大约是我第一次发布这篇文章之后七个月，网景公司公开声明他们计划要发布通讯家族（Netscape Communicator）的<a href="http://www.netscape.com/newsref/pr/newsrelease558.html">原始代码</a>，之前我对这件事情的发生一点头绪也没有。</p><p>网景的执行副总裁兼首席技术官 Eric Hahn 寄给我一封电子邮件，内容简要如下︰「我代表网景公司的每一个人，向你致谢，因为你帮我们成为第一家做到开源的公司，你的思想和著作是我们做出这个决定的原因。」</p><p>接下来一个星期，我接受网景公司的邀请，搭飞机到硅谷参加他们长达一天的策略会议，参与会议的有该公司顶级执行者和技术人员，我们一起设计出网景公司开源的策略及版权，也做了些计划，希望能对开源社区有长远而正面的影响，就如同我之前所说，这件事来得太快，以致于我们定出的策略和版权还不太明确，但在几周内，细节应该可以交代清楚。</p><p>网景公司愿意提供一个真实大型的试验，在商业世界中测试市集模式，因此开源的世界正面临著一个危机，假如网景的行动不成功，那么开源的观念在商业界也许就会被鄙弃，在十年内大概不会有公司再碰它。</p><p>另一方面，这也是一个空前的机会，华尔街和其他地方对这件事的初始反应是谨慎地正面评价，我们拥有这个机会来证明开源是有益的，假如网景借此行动而重新获得实际的市场，那么它将引发软件工业中一场迟来已久的革命。</p><p>明年（1999）将会是非常有意义而且有趣的一年。</p><p>并且事实确实如此。当我在2000年中期写下这篇文章时，后来被命名为Mozilla(Firefox)的发展只是一个合格的成功。它实现了网景最初的目标，即拒绝微软对浏览器市场的垄断锁定。它也取得了一些戏剧性的成功（特别是发布了下一代Gecko渲染引擎）。</p><p>然而，它还没有像Mozilla创始人最初所希望的那样，从Netscape之外获得大量的开发工作。这里的问题似乎是在很长一段时间里Mozilla发行版实际上打破了集市模式的一个基本规则; 它没有提供一些潜在的贡献者可以很容易地运行和看到工作的东西. (直到发布一年多以后, 从源码中构建Mozilla需要一个专有的Motif库的许可证).</p><p>最消极的是(从外界的角度来看)Mozilla集团在项目启动后两年半的时间里没有推出产品级的浏览器，1999年，该项目的一位负责人辞职，抱怨管理不善和错失机会，引起了一点轰动。他正确地指出，”开源”不是万能药。</p><p>而事实上并不是这样。Mozilla 的长期前景现在(2000年11月)看起来比Jamie Zawinski写辞职信的时候要好得多–在过去的几周里，每晚发布的版本终于通过了生产可用性的关键门槛。但是Jamie正确地指出，开放源码并不一定能拯救一个现有的项目，因为这个项目存在着目标不明确、代码冗长或软件工程的其他痼疾。Mozilla已经成功地提供了一个例子，同时说明开源如何成功，如何失败。</p><p>然而，与此同时，开源理念已经取得了成功，并在其他地方找到了支持者。自Netscape开源以来，我们已经看到了对开源开发模式的巨大兴趣，这种趋势是由Linux操作系统所推动并持续。Mozilla所引发的趋势正在加速继续。</p><p>[^1]: GNU 是自由软件基金会（Free Software Fundation）的一个项目，目标是开发出 UNIX 上所有程序的自由版本，Emacs 是自由软件基会开发出来的一支程序，可做文字编辑器，提供写程序的整合开发环境，用来读电子邮件，新闻群组，甚至浏览网页。更详细的资讯请参考 <a href="http://www.gnu.org./">http://www.gnu.org。</a> ―― 译注。<br>[^2]: Linus Torvald 是 Linux 内核程序（kernel）的原始作者。 ―― 译注。<br>[^3]: 在《<em>Programing Pearls</em>》，著名的资讯工程格言家 Jon Bentley 评论 Brooks 的观察说「如果你丢弃一次，你将丢弃第二次」。他几乎是对的。他们两人的重点不是你应该预期第一次的尝试是错的，而是以正确的想法开始会比挽救一场灾难来得更有效率。<br>[^4]: 成功采用市集模式的开源例子，早在因特网时代之前，与 UNIX 无关，这因特网的传统早就存在。<a href="http://www.cdrom.com/pub/infozip/">info-Zip</a> 这个压缩工具的开发在 1990-1992 年，主要是针对 DOS，就是一个例子。另一个子是 RBBS 电子布告栏（也是针对 DOS），于 1983 年开始，开发了一个强壮的社群，直到目前（1999 年中）都还经常发布新版本，尽管网络邮件与文件分享有更巨大的优势。当 info-Zip 社群依赖网络邮件形成的规模，RBBS 的开发者文化实际上在 RBBS 支撑线上社群，使它完全独立于 TCP&#x2F;IP 的基础设施。<br>[^5]: Delphi 是希腊古都，以善作预言的 Apollo 神殿而闻名。 ―― 译注。<br>[^6]: 对训服操作系统的复杂度来说，透明与同裁审查都是很有价值的，毕竟这不是一个新概念。在 1965 年，时间共享的非常早期阶段，Corbató 与 Vyssotsky，Multics 操作系统的共同设计者<a href="http://www.multicians.org/fjcc1.html">写到</a>，一般预期 Multics 将在完成后发布…这是为了两个原因，第一是它可以经得起有兴趣者的审查与批评，第二是有义务要展出，未来的设计者才可以让内部操作系统尽可能清晰，如此会有利于发现系统问题。<br>[^7]: John Hasler 提过一个有趣的解释，我将它称为「Hasler定律」︰重复工作花费的时间与团队大小呈现 sub-quadratic 关係 ―― 至少比那些需要被消灭的过度计划与管理上升的慢。<br>这声明并没有否定「Brooks法则」。复杂度与除错规模随着人数而呈现平方上升，不过重复工作的时间成本至少上升的比较慢。从以下这个无可怀疑的事实很难开发出令人信服的推论︰「不同开发者写的代码会造成功能限制，防止重复工作比那些形成大量臭虫且缺乏计划与沟通结果好多了。」<br>将「Linus法则」与「Hasler定律」合併可以得出三种软件项目的开发模式。在小型项目（最多三个开发者），没有管理比有一个主要开发者好。在中等规模的项目，传统的管理成本相对低，在防止重复工作与除错有正面助益。<br>而大型项目中，跟重复工作相比，传统的管理成本上升的比预期的快多了。虽然跟传统管理方式相比，人多容易发现错误，但是这些上升的成本对于管理这些事情却有结构性的无力。因此，在大型项目，正面效果完全被传统管理所抵销。<br>[^8]: 实验版与稳定版 Linux 可以对冲彼此的风险。这分裂形成另一个问题︰截止日的死亡。当两边都有一个不可变动的功能清单与截止日，品质荡然无存且会形成大混乱。我输钱给哈佛商业评论的 Marco Iansiti 与 Alan MacCormack，因为他们向我展示了证据，就是鬆绑其中一的规定可以让排程可行。<br>截止日固定但功能清单可变动，放弃到截止日仍为完成的功能，这是一个可行的办法；稳定版 Linux 核心就是如此，Alan Cox（稳定版的维护者）相当准时的发布新版本，但不保证特定臭虫何时被修正，或是从实验版引进什么新功能。<br>另一个办法是设定想要的功能名单，并只在全部完成后发布；这是实验版 Linux 核心的作法。De Marco 与 Lister 指出这样的排程政策（完成后叫醒我）不只品质最好，而且平均来说，跟务实与激进的排程相比，发布的时间间隔也较短。<br>我怀疑在这论文的早期（2000 年初），我严重低估「完成后叫醒我」对社群的生产力与品质的影响。1999 年发布的 GNOME 1.0 带来的经验是，对未成熟产品的压力会抵销一般开放源代码产品应有的品质。<br>透明的过程、完成后叫醒我与开发者自我选择，这三者是对开放源代码的品质一样重要。<br>[^9]: 这不完全精确，因特网为基础的开源项目的混合式组织特征，依 Brooks 的建议，要解决这样的 N^2 复杂度问题，应该採取「外科手术小组」的团队 ―― 但是现实中差异很大。像跟在领导者身边的代码图书馆员这样的专门角色，实际上不存在；相对于 Brooks 当时来说，这角色被更而有力的软件工具集所取代。而且，开源文化强烈依赖 UNIX 传统的模组、API 与数据隐藏 ―― 没有任何一个是 Brooks 所讲的处方。<br>[^10]: 反对者跟我说，对同一bug的多症状来说，描述bug特征的难度呈现指数式（譬如 Gaussian 分布或 Poisson 分布）上升。如果可能掌握到分布的外观，那会是很有用的资料。这与debug困难度是均匀分布的差别很大，也就是说单一开发者也应该模仿市集模式，针对单一的bug定一个时间上限，超过的话就追踪下一个bug。从一而终不见得是美德…<br>[^11]: 相反的组合指笨拙的数据结构配上聪明的代码。 ―― 译注。<br>[^12]: 事实上，上述的这段话他是用「流程图」（flowchart）和「表格」（tables）这两个名词，但由于三十年间专业术语&#x2F;文化的变迁，这些名词的意义几乎是相同的。 ―― 译注。<br>[^13]: 「小王子」就是 Antoine de Saint-Exupery 的作品。这句格言也曾在《<em>Modern Operating System</em>》一书中被 Andrew S. Tanenbaum 引用来说明操作系统微核心的设计哲学。 ―― 译注。<br>[^14]: RFC 822 是 Standard for the Format of ARPA Internet Text Messages。 ―― 译注。<br>[^15]: RFC 1652 是 SMTP Service Extension for 8bit-MIME Transport。 ―― 译注。</p><p>[^16]: 以 fetchmail 为例，隐藏的秘密是指「通行密码」，「虚拟秘密」是指把通行密码编码后存于配置文件中。 ―― 译注。<br>[^17]: 一个人能不能采取市集模式从无到有的开发项目，取决于市集模式是否能够支持创造性的工作。有人认为，缺乏强而有力的领导力，市集模式只能在目前最尖端的技术上做複製与小幅度改良，而无法开发出最尖端的技术。这也许是 <a href="http://www.opensource.org/halloween/">Halloween Documents</a> 最无耻的论述，这令人尴尬的两份微软内部文件如此描述开源现象。作者比较了这个类似 UNIX 系统的 Linux 系统是在「追尾灯」（chasing taillights）（当一个项目达到最先进技术的门槛时），认为管理才能进一步扩大前进。<br>如果我们把开源替换为 Linux，会发现这跟新的情境差很远。在过去，开源社区不会借着追尾灯或管理制度发明 Emacs 或 WWW 或因特网 ―― 但目前确有非常多创新是采用开源模式。GNOME 项目就是最先进的 GUI，而且在 Linux 社群外也引起相当的注意。还有其他不胜枚举的例子，有兴趣的人可以去看一下 <a href="http://freshmeat.net/">Freshmeat</a> 等等的项目。<br>认为教堂模式（或市集模式，或其他种类的管理结构）能够让创新更值得信赖有个更根本的错误。这完全是无稽之谈。乌合之众没有突破性的洞察力 ―― 即使市集模式的无政府论者没有真正的原创，这使得目前还能生存的企业人士可以赌注维持现状。<em>洞察力来自于个人</em>。大多数围绕在这些人身边的社群机制，都希望对于突破性的洞察力更有回应 ―― 滋养与严苛的测试，而不是压榨它们。<br>一些人会说这是不切实际的观点，一个典型过时独创者的回归。并非如此，我不是断言这些已出现的人没有突破性的洞察力做开发，而是我们了解同裁审查对于高品质结果是必要的。当然，这些开发的起源来自于一个人的好点子 ―― 而且这是必要的火花。<br>因此，创新的根本问题（不管是软件或是其他方面）是如何不压榨它 ―― 或者是更根本的，如何让这些有洞察力的人群越来越多。<br>推论教堂模式可以做到而低进入门槛的市集模式做不到，这是可笑的。一个是可以让众人合作的社会环境激励创新；而等级制度下的创新却需要做一些政治性的行销才能为自己的想法开发，不然会有被开除的风险。<br>如果我们看一下采用教堂模式的软件开发历史，会很快的发现那相当稀少。大型机构依赖大学的研究中心来开发新的点子（因此 Halloween Documents 的作者对于 Linux 的快速开发成果感到相当感冒），或者买一些拥有创新者成果的小型公司；这两种都不是教堂模式，实际上，很多的创新就是被 Halloween Documents 所讚扬的管理方式扼杀的。<br>那是负面的部份，读者应该著重在正面的部份。以实验的精神，我提议以下的方式︰选一个你一直信仰的原创原则，例如「当我看见就能了解」。选一个跟 Linux 竞争的封闭源代码操作系统，与一个公认在这上面运行的最好的源代码。观察该源代码与 Freshmeat 一个月。每天计算在 Freshmeat 上原创的成品，然后对比你选的源代码的原创成品的数字。三十天后，统计两者的数据。<br>当我写本文的时候，Freshmeat 发布了 32 个，我选的源代码发布了 3 个，这在 Freshmeat 算慢的，但经验上 3 这个数字对封闭源代码来说是相当快的。<br>[^18]: 现在我们有一个比 fetchmail 更有指引意义的市集模式项目，<a href="http://egcs.cygnus.com/">EGCS</a>，实验性的 GNU 组译系统。<br>这项目是在 1997 年 8 月中发布的，作为一个早期《教堂与市集》的尝试。因为该项目的发起者觉得 GCC 的开发已经迂腐了。在之后大约二十个月，GCC 与 EGCS 各自平行开发 ―― 两者的开发者都来自一样的母体，都源于一样的 GCC 基础源代码，使用高度雷同的 UNIX 工具集与开发环境。唯一不同的是，EGCS 采用市集模式开发，而GCC 采用类似教堂模式的开发。搭配封闭的开发者团队与发布间隔较长。<br>这很接近可控制变因的实验，我们想知道的是哪一个比较戏剧性。在这几个月，EGCS 在功能上大幅度领先，较好的最佳化与对 FORTRAN 跟 C++ 的支持。很多人都认为 EGCS 的开发状况比同时期的 GCC 好，而且主要的 Linux 发行版都换到了 EGCS。<br>在 1999 年 4 月，自由软件基金会（GCC 的官方支持机构）解散了 GCC 原来的开发团队，将 EGCS 的团队纳入官方支持。<br>[^19]: 当然，Kropotkin 的评论与「Linus法则」引起关于社会组织控制学的广泛议题。另一个软件工程的理论则建议「Conway法则」 ―― 「如果你有四组人做组译器，你会得到一个四重（4-pass）组译器」。原始的叙述比较一般化︰「组织会以自己内部的沟通结构设计系统」。更简洁的说，「方式决定结果」或「过程变成产品」。<br>值得注意的是，开源社区的组织形式与功能才很多层次相配合。到处都是网状架构，不只是因特网如此，人们在分散、鬆散与同裁的结构工作，其中也会发生延迟与降级。在这样的环境中，每一个节点都需要其他节点自愿性的配合才能互动与合作。<br>对于社群令人震惊的生产力来说，同裁合作的部份是必要的。关于 Kropotkin 要处理的权力关系，「SNAFU原则」有进一步的论述︰「平等才可能有真正的沟通，因为对于劣等者来说，讲善意的谎言比陈述事实更有吸引力。」开创性的团队合作依赖于真正的沟通，在权力的展示下反而会被严重拖累。开源社区就是这样的情况，这将在除错、低生产力与机会消耗异常巨大的成本。<br>此外，「SNAFU原则」预测在需要授权的组织中，决策者与现实会慢慢脱节，对决策者的资讯太多会变成善意的谎言。这情形在传统的软件开发很容易见到，劣等者有强烈动机隐瞒、忽视与简化问题。当这过程变成产品是，那会是一个大灾难。</p><p>[^20]: 指管理者也会害怕自己成为漫画中那个老板。 ―― 译注。</p><p>转载在 <a href="https://github.com/thuwyh/The-Cathedral-the-Bazaar-zh/blob/master/%E5%A4%A7%E6%95%99%E5%A0%82%E4%B8%8E%E9%9B%86%E5%B8%82.md">The-Cathedral-the-Bazaar-zh</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;教堂与市集&lt;/p&gt;</summary>
    
    
    
    
    <category term="reproduced" scheme="https://notes.yaohwu.xyz/tags/reproduced/"/>
    
    <category term="read" scheme="https://notes.yaohwu.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>从最简单的规则开始设计</title>
    <link href="https://notes.yaohwu.xyz/2021/12/15/the-easiest-way-to-design-code/"/>
    <id>https://notes.yaohwu.xyz/2021/12/15/the-easiest-way-to-design-code/</id>
    <published>2021-12-15T12:46:25.000Z</published>
    <updated>2023-04-11T02:22:04.790Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章大致讲一些自己对于代码设计的理解，总结一些经验做一个小组的分享。</p><span id="more"></span><h2 id="导引"><a href="#导引" class="headerlink" title="导引"></a>导引</h2><p>为什么从最简单的规则开始呢？</p><p>因为其实我是在代码设计方面没有特别深入的研究，单纯的拿《 head first 设计模式》中的案例来充当分享内容有点不妥，我自己最近也还在不断学习。</p><p>另外就是，正如书中所说：</p><blockquote><p>使用模式最好的方式是：“把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。”以往是代码复用，现在是经验复用。</p></blockquote><h3 id="如何把模式装到脑子里？"><a href="#如何把模式装到脑子里？" class="headerlink" title="如何把模式装到脑子里？"></a>如何把模式装到脑子里？</h3><p>可以通过看书来达成。最好还是看 《Head First 设计模式》，不要从网上看现成的文档，不要死记硬背。</p><ol><li><p>书的组织形式很好</p><ol><li>针对设计模式的应用场景进行分类，从对象，到装饰，到松耦合 OO，到封装，到适配和外观，到集合，到状态控制，到访问控制，有一整个的故事线，很有意思。</li><li>从简单的例子，到多模式的组合进阶使用，由易到难，由 demo 到生产；</li></ol><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/F97LMr.png" alt="head first 设计模式 java 实现"></p></li><li><p>书的讲述形式很好</p><ol><li><p>不断的 Q&amp;A，不断的比较，容易引发自己的思考，印象也就更深刻；</p></li><li><p>你会发现，即使同一个模式，在不同场景下也是有不同的使用方案的，甚至这些方案在某些情况下看起来是违背了一些总结出来的原则，比如“优先使用组合而不是继承”，举个例子<a href="https://notes.yaohwu.xyz/2019/09/25/software-design/#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern">适配器模式</a>；如果没有这样的思考，很容易对某一个模式产生偏见和错误理解。<br><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/OoZCjB.png" alt="两种适配器的思辨"></p></li></ol></li></ol><h3 id="在你的设计和已有的应用中寻找他们"><a href="#在你的设计和已有的应用中寻找他们" class="headerlink" title="在你的设计和已有的应用中寻找他们"></a>在你的设计和已有的应用中寻找他们</h3><p>我也没有再花时间在我们的业务代码中找到具体的案例。</p><ol><li>我也是到分享的时候才发现，自己其实没有特别深入的学习过，脑海里一下子过不来这些东西；</li><li>时间的问题；</li><li>也觉得没有必要，自己去寻找，切身体会才是最好的。我分享的案例，只是我个人站在当初需求背景下的设计，而设计的好坏和需求又相关，在不同背景下的思考见仁见智。</li></ol><h2 id="总结经验"><a href="#总结经验" class="headerlink" title="总结经验"></a>总结经验</h2><p>既然上述两部分，都有更好的方案，那我就只能总结一下我个人最简单的经验。从比较务实的角度出发，将上层的理论交给更专业的方案去做。</p><p>我有哪些经验呢？毕竟我也是菜鸡，</p><p>所以我的经验也都比较简单，所以，还是回到题目，从最简单的规则开始，看看代码设计。</p><h3 id="减少重复代码"><a href="#减少重复代码" class="headerlink" title="减少重复代码"></a>减少重复代码</h3><p>这个可以说是最简单的规则了，没有之一。</p><p>毕竟，没有设计模式之前，至少也在强调，要实现代码复用。</p><blockquote><p>以往是代码复用，现在是经验复用。</p></blockquote><p>出现了大量的重复代码，那就不能实现代码复用，维护起来就得到处改。</p><p>重复的代码分类：</p><ul><li>方法出现重复的实现</li></ul><p>这个其实很容易理解，一个实现里面或者几个实现中，总是出现同样的方法块，idea 甚至都会帮助你识别出来。</p><p>比如我们业务中的统计逻辑，有好几处都要进行对模板信息的统计，但是是因为不同时期的功能，抄来抄去，没有再去整理，出现了大量的重复代码，维护起来，要改都得改。</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/6NkWaT.png" alt="重复代码"></p><p>这些重复的逻辑甚至都出现在同样的方法中，几百行的方法，随着迭代越来越多，不断追加，没有时间去重构来减少重复代码。</p><ul><li>某个接口大量的实现类</li></ul><p>重复的方法块出现，肯定是封装出现了问题。还有一类重复，就是出现了大量的实现类。还拿埋点逻辑来说，<code>切入点的选择和切入的实现</code> 这个接口出现了大量的实现。</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/iIDlKN.png" alt="大量的接口实现"></p><p>这当然也是一个设计上的问题。大量的实现类反映接口在易用性和抽象上的弊端。想要实现新的切入点的成本高昂。</p><ul><li>解决方案</li></ul><p>我们需要重新来设计，以实现减少重复代码的目的。</p><p>方法块的重复，在不同的场景下有多种选择。</p><ol><li>至少可以抽成公共的静态方法，带来的是稍微好维护；</li><li>也可以简单地进行抽象，使用继承，使用模板方法来处理；</li><li>也可以完全推倒原本的设计，实现一个针对模板的 parser，使用多个 parser 的组合来实现模板的读取和信息收集，对于其中的特殊的 parser 甚至还可以额外的抽象，比如针对控件列表的过滤，有些 parser 需要统计控件类型，有些 parser 需要统计个数，要让彼此独立却又在同一个便利中完成，那么就需要一个额外的抽象。</li><li>也可以 2 和 3 结合起来实现。</li></ol><p>接口大量的实现类的出现，要减轻这样的重复工作，就要抽象出一个更加合理的基本实现类，将原本的实现类变成一个个基本实现类的实例。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p><strong>进行抽象的时候，要先有具象。</strong></p><p>这个具象不一定要已经有了实现，而是至少在你思考的过程中已经出现了的。</p><p>真正在处理业务的时候，可不像 demo 中那么简单。</p><blockquote><p>一个苹果，一个梨，那么自然会想到水果。</p></blockquote><p>要思考自身的业务分为哪几部分、哪些是可以归结到一个合理的结构上的。</p><p>基于不同的业务场合得到的抽象肯定也是完全不同的。</p><p>一个苹果一个梨，可能得到的是：</p><blockquote><p>一种植物。</p></blockquote><p>也可能是</p><blockquote><p>一种拥有外皮，可以吃的，长在对应果树上的东西。</p></blockquote><p>要结合具体的业务场景，找到最本质的部分，舍弃不关注的部分，最终得到一个抽象的结果。</p><h3 id="扩展性思考"><a href="#扩展性思考" class="headerlink" title="扩展性思考"></a>扩展性思考</h3><p>分层次的来思考扩展。</p><ul><li>有扩展性的必要么？</li></ul><p>要结合对应的业务场景来思考。</p><p>通常来说，涉及一个独立模块的功能，肯定是要考虑扩展性的。</p><p>但一个模块中的原本就具有可扩展性的一个扩展实现，就不需要考虑那么多，容易造成过度设计。</p><ul><li>有热替换的必要么？能不能实现热替换？</li></ul><p>要以松耦合的方式来实现。要依赖倒置，是不是要引入工厂方法，至少要有一个管理类来实现更新。</p><ul><li>能不能实现改动替换？改动替换时需要改哪些东西？</li></ul><p>改动替换时，是重新实现一个子类，还是针对已有的进行装饰，还是弄一个适配器。</p><p>这些在需要扩展的设计场景下要尽可能的思考到。让后续的扩展改动最小。</p><h3 id="使用约定减少特定"><a href="#使用约定减少特定" class="headerlink" title="使用约定减少特定"></a>使用约定减少特定</h3><p>一些设计模式是有固定使用场景的。不要在这些固定的使用场景下搞特定的设计。</p><p>比如 单例模式，虽然单例模式的写法很多，各种懒汉饿汉、双检索、枚举，但是他们对应的利弊和使用的场景一定要搞清楚。</p><p>还有一些其他好的代码方面的建议也是类似的。</p><p>比如针对 bean 的处理，getter setter 方法，开放的无参的构造器等等。</p><p>用于数据网络传输的 bean 和代码调用间的 bean 中间做一层转换，减少改动影响的范围。</p><p>比如，针对实例化时参数特别多的类，比如各种 bean，使用 builder 加上链式调用的方式来完成。</p><p><strong>固定的场景，选择固定的模式，使用固定的原则。</strong></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>合理使用泛型，让编译器帮助你发现问题。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>借助单元测试来设计，朝着让单元测试更容易写的方向优化设计。</p><p>得到一个合理的抽象，合理的模块化拆分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与其说我是来分享的，不如说我是来劝学的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章大致讲一些自己对于代码设计的理解，总结一些经验做一个小组的分享。&lt;/p&gt;</summary>
    
    
    
    
    <category term="design pattern" scheme="https://notes.yaohwu.xyz/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>啥是云服务</title>
    <link href="https://notes.yaohwu.xyz/2021/12/05/cloud-topic/"/>
    <id>https://notes.yaohwu.xyz/2021/12/05/cloud-topic/</id>
    <published>2021-12-05T08:30:00.000Z</published>
    <updated>2021-12-06T07:25:05.908Z</updated>
    
    <content type="html"><![CDATA[<p>本意是希望了解一下什么是云原生（CloudNative），但是发现相关的名词解释很多。</p><p>就顺带整理分享下，都是互联网老词了，老词新回顾，带领大家再冲冲浪。</p><span id="more"></span><p>本意是希望了解一下什么是云原生（CloudNative），但是发现相关的名词解释很多。</p><p>就顺带整理分享下，都是互联网老词了，老词新回顾，带领大家再冲冲浪。也确实是冲浪，大部分是 redhat 官网的摘录。</p><h2 id="云计算（Cloud-Computing）"><a href="#云计算（Cloud-Computing）" class="headerlink" title="云计算（Cloud Computing）"></a>云计算（Cloud Computing）</h2><p>在了解什么是云服务之前，肯定要了解一个更老的概念——云计算。那么什么是云计算呢？</p><h3 id="云计算定义"><a href="#云计算定义" class="headerlink" title="云计算定义"></a>云计算定义</h3><p>一种能够跨网络、按需提供基础架构、服务、平台和应用的交付方式，正在快速取代原本通过硬布线连接进行资源共享的方式。</p><p>云计算是指在云中运行工作负载，而云是一种能够抽象、汇集和共享整个网络中的可扩展资源的 IT 环境。云计算和云本身都不属于技术的范畴。</p><ul><li>云计算是指在云中运行工作负载的功能。</li><li>而云是一种环境，是运行应用的地方。</li><li>技术则是指用于构建和使用云的软件和硬件。</li></ul><h3 id="云计算分类"><a href="#云计算分类" class="headerlink" title="云计算分类"></a>云计算分类</h3><p>以往人们很容易通过位置和所有权来界定公共云、私有云、混合云和多云之间的差异。</p><p>但如今已不再那么简单。所以，我们在尽全力定义主要云类型的同时，仍着眼于未来——因为了解过去的情况不一定就知道将来该如何使用云。</p><p>按照位置和所有权，我们可以这样划分云：</p><table><thead><tr><th></th><th>公共云（公有云）</th><th>私有云</th><th>混合云</th><th>多云（Multi-Cloud）</th></tr></thead><tbody><tr><td>定义</td><td>一种利用非最终用户所有的资源创建的云环境，可重新分发给其他租户。</td><td>可广义地定义为：一种专为最终用户而创建，而且通常位于用户的防火墙内（有时也是内部部署）的云环境。</td><td>一种具有一定程度的工作负载可移植性以及编排和管理能力的多云环境。</td><td>一个含有多个云环境（公共云或私有云）的 IT 系统，云与云之间可能联网也可能不联网。</td></tr></tbody></table><h4 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h4><p>一个虚拟资源池，可自动部署并通过自助服务界面在多个客户端间进行分配，其中的虚拟资源来自归第三方公司所有和管理的硬件设备。当工作负载出现意外需求波动时，可直接通过公共云进行横向扩展。</p><p>公共云通常不会作为独立的基础架构解决方案来部署，而是被作为异构混合环境的一部分部署，这样即可以提高安全性和性能，降低成本，还可以改进基础架构、服务和应用的可用性。</p><h5 id="公有云面对的需求"><a href="#公有云面对的需求" class="headerlink" title="公有云面对的需求"></a>公有云面对的需求</h5><ol><li>资源分配，由第三方提供服务，在租户见共享；</li><li>使用协议，随时可用，不用就停；</li><li>管理，提供商协助维护基础硬件、为网络提供支持、管理虚拟化软件；</li></ol><p>综合下来，就是降低成本、提高可用；</p><h4 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h4><p>一种专为最终用户而创建，而且通常位于用户的防火墙内的云环境。尽管传统上私有云在内部运行，但现在许多企业构建的私有云位于供应商租赁的外部数据中心内。如果底层 IT 基础架构归某个拥有完全独立访问权限的客户专有，那这种云就是私有云。</p><h5 id="私有云面对的需求"><a href="#私有云面对的需求" class="headerlink" title="私有云面对的需求"></a>私有云面对的需求</h5><ol><li>出于安全、加密、权限等等限制导致不能使用公有云；比如银行、金融服务等行业；</li></ol><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><p>现在的云类型过于复杂，位置和所有权比较抽象；</p><p>所以按照功能来划分：</p><ul><li>通过网络连接多台计算机。</li><li>整合 IT 资源。</li><li>横向扩展并快速置备新资源。</li><li>能够在不同环境间移动工作负载。</li><li>包含单个统一的管理工具。</li><li>利用自动化对流程进行编排。</li></ul><h4 id="多云"><a href="#多云" class="headerlink" title="多云"></a>多云</h4><p>多云是指在多个供应商上部署同一类云方案（公共云或私有云）。混合云是指通过集成或编排组合多种云部署类型（公共云或私有云）。</p><h5 id="多云面对的需求"><a href="#多云面对的需求" class="headerlink" title="多云面对的需求"></a>多云面对的需求</h5><ol><li><a href="https://en.wikipedia.org/wiki/Shadow_IT">影子 IT</a>，在大规模线上应用之外的云，比如，在我们的 CRM 系统之外，有另外的小组新搞了个 CRM，希望解决性能等问题，那么这套单独部署的未来可能会替代现有 CRM 的系统部署的环境，就可以叫做影子 IT;</li><li>灵活性，选择不同的价格、不同的性能来部署同一应用，比如 swift 历史 2 年以上的数据，就选一个容量大但是读写慢的机器存储，近三月的就选择容量小但是读写快的机器部署；</li><li>邻近，区域的距离或者法律法规限制；比如国内 swift 和海外 swift；</li><li>故障切换；</li></ol><h2 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h2><p>了解了云计算之后，我们就可以来看云服务了。</p><h3 id="云服务定义"><a href="#云服务定义" class="headerlink" title="云服务定义"></a>云服务定义</h3><p>很显然，云服务就是利用云计算的交付方式，来通过互联网提供给用户的服务。暨指由第三方提供商托管的基础架构、平台或软件，可通过互联网提供给用户。</p><h3 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h3><p>凡是用户无需下载其他软件而是直接通过互联网就能访问的所有基础架构、平台、软件或技术都可以视为云计算服务，包括以下即服务类解决方案。</p><table><thead><tr><th>IaaS</th><th>CaaS</th><th>PaaS</th><th>SaaS</th><th>FaaS</th></tr></thead><tbody><tr><td>基础架构即服务（IaaS）为用户提供计算、网络和存储资源。</td><td>容器即服务（CaaS）是一种云服务计算的模型，它允许用户使用内部数据中心或云，通过基于容器的抽象来部署和管理应用。</td><td>平台即服务（PaaS）为用户提供一个可运行应用的平台，以及运行所需的所有 IT 基础架构。</td><td>软件即服务（SaaS）为用户提供必备的云应用、应用运行平台以及平台的底层基础架构。</td><td>功能即服务（FaaS）是一种事件驱动型执行模型，它允许开发人员以功能的形式来构建、运行和管理应用包，无需维护基础架构。</td></tr></tbody></table><p>各服务维护范围，除去 FaaS。</p><table><thead><tr><th>On-site</th><th>IaaS</th><th>PaaS</th><th>SaaS</th></tr></thead><tbody><tr><td><strong>Applications</strong></td><td><strong>Applications</strong></td><td><strong>Applications</strong></td><td>Applications</td></tr><tr><td><strong>Data</strong></td><td><strong>Data</strong></td><td><strong>Data</strong></td><td>Data</td></tr><tr><td><strong>Runtime</strong></td><td><strong>Runtime</strong></td><td>Runtime</td><td>Runtime</td></tr><tr><td><strong>Middleware</strong></td><td><strong>Middleware</strong></td><td>Middleware</td><td>Middleware</td></tr><tr><td><strong>O&#x2F;S</strong></td><td><strong>O&#x2F;S</strong></td><td>O&#x2F;S</td><td>O&#x2F;S</td></tr><tr><td><strong>Virtualization</strong></td><td>Virtualization</td><td>Virtualization</td><td>Virtualization</td></tr><tr><td><strong>Servers</strong></td><td>Servers</td><td>Servers</td><td>Servers</td></tr><tr><td><strong>Storage</strong></td><td>Storage</td><td>Storage</td><td>Storage</td></tr><tr><td><strong>Networking</strong></td><td>Networking</td><td>Networking</td><td>Networking</td></tr></tbody></table><p><strong>加粗的内容</strong>是你需要管理和维护的。</p><h4 id="CaaS"><a href="#CaaS" class="headerlink" title="CaaS"></a>CaaS</h4><p>在云服务范畴内，CaaS 被认为是基础架构即服务（IaaS）的一种子集，介于 IaaS 和平台即服务（PaaS）之间。</p><p>CaaS 的基本资源为容器，它是云原生应用和微服务的常见部署机制。此外，CaaS 还可以提高环境之间的可移植性，无论是混合环境还是多云环境。</p><h4 id="FaaS"><a href="#FaaS" class="headerlink" title="FaaS"></a>FaaS</h4><p>一种在无状态容器中运行的事件驱动型计算执行模型，这些功能将利用服务来管理服务器端逻辑和状态。</p><p>它允许开发人员以功能的形式来构建、运行和管理这些应用包，无需维护自己的基础架构。</p><h3 id="云计算服务的原理"><a href="#云计算服务的原理" class="headerlink" title="云计算服务的原理"></a>云计算服务的原理</h3><p>我们在分类的时候 IaaS 提供的是基础架构，PaaS 提供的是平台，SaaS 提供的是软件。</p><p>那么这三种分别是什么？云计算是如何发布这三种服务的？</p><h4 id="云基础架构"><a href="#云基础架构" class="headerlink" title="云基础架构"></a>云基础架构</h4><p>将计算功能和硬件组件分离开。例如</p><ol><li>处理能力和 CPU 硬件分离开；</li><li>内存和 RAM 硬件分离开；</li><li>图形处理能力和 GPU 硬件分离开；</li><li>数据存储能力和磁盘等硬件分离开；</li></ol><p>怎么理解这个分离呢？举个例子，假设我只有一个 100 算力的 CPU，但是我作为云服务提供的时候，可以将这个 CPU 的 100 算力分开售卖，以满足不同客户群的使用需求，最终形成的售卖方案可能是：</p><ol><li>一个 50 算力的 SP；</li><li>三个 10 算力的 SSR；</li><li>五个 2 算力的 SR；</li><li>一百个 0.1 算力的 R；</li></ol><p>怎么做到这个呢？通过虚拟化来实现。在一个 100 算力的 CPU 上，分别虚拟出来上述的内容。CPU 如此，其他硬件资源也是类似的。</p><h4 id="云服务平台"><a href="#云服务平台" class="headerlink" title="云服务平台"></a>云服务平台</h4><p>云服务平台，就是在上述云基础架构的基础上，同时提供一套可以直接运行某种应用的环境。</p><p>实现云服务平台，除了上述的虚拟化技术之外，还要要求容器化、编排、API、路由、安全、管理和自动化等技术。</p><p>云平台是一种 PaaS。如果支持 PaaS 的基础架构组件具有高度可扩展性和可共享性，则可以将其视为云。PaaS 云的最佳例证包括公共云和托管私有云。</p><h4 id="云软件"><a href="#云软件" class="headerlink" title="云软件"></a>云软件</h4><p>提供商可以提供并最终被广泛接受的云服务是一个完整的 Web 应用，也称云软件或 SaaS。这需要最大规模的开发投资，因为云提供商实际上是在为客户提供在线应用。比如我们公司的简道云、九数云等。</p><p>作为云软件，很容易和传统软件混淆，或者基于不同的 client 形式难以区分。无论是通过 web 还是通过其他的桌面客户端，只要是需要通过互联网与云服务提供商提供的软件服务器进行通讯的，都是云软件。</p><p>云软件可以通过云原生方法提供，云原生是一种结合了小型、独立和松散耦合的微服务的应用架构。多个微服务可以打包至由容器编排引擎（如 Kubernetes ）管理的单个 Linux 容器中。最终产品是一个云应用，可通过微服务进行优化，而不会对整个应用中的其他微服务造成影响。</p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>好家伙，终于到云原生了。</p><p>就如上文所说，云原生是一种方法，一种结合了小型、独立和松散耦合的微服务的应用架构。</p><p>云原生包含四个要点。</p><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>从字面上来看，“DevOps”一词是由英文 Development（开发）和 Operations （运维）组合而成。</p><p>DevOps 强调通过一系列手段来实现既快又稳的工作流程，使每个想法（比如一个新的软件功能，一个功能增强请求或者一个 bug 修复）在从开发到生产环境部署的整个流程中，都能不断地为用户带来价值。这种方式需要开发团队和运维团队密切交流、高效协作并且彼此体谅。此外，DevOps 还要能够方便扩展，灵活部署。有了 DevOps，需求最迫切的工作就能通过自助服务和自动化得到解决；通常在标准开发环境编写代码的开发人员也可与 IT 运维人员紧密合作，加速软件的构建、测试和发布，同时保障开发成果的稳定可靠。</p><p>当然，这意味着更改代码会更频繁，基础架构的使用也会更灵活。所以传统的管理策略无法满足这种需求。</p><p><strong>它是一种文化，也是一个流程，更是一组的平台和工具。</strong></p><h3 id="微服务（Microservices）"><a href="#微服务（Microservices）" class="headerlink" title="微服务（Microservices）"></a>微服务（Microservices）</h3><p>微服务既是一种架构，也是构建软件的方法。在微服务中，应用被拆分成最小的组件，彼此独立。不同于将所有组件内置于一个架构中的传统单体式应用构建方法，在微服务架构中，所有部分相互独立，通过合作来完成同一个任务。其中的每一个组件或流程都是一个微服务。这种软件开发方法强调细粒度、轻量化，力求在多个应用中共享相似的流程。它是针对云原生模型优化应用开发的主要组件。</p><p>微服务架构有助于更快地交付高质量的软件。使用微服务有助实现这一点，但也需要注意一些细节。仅仅将应用拆分成微服务是不够的，您还必须对微服务进行管理和编排，处理微服务创建和修改的数据。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>应用编程接口（API）由一组用于集成应用软件和服务的工具、定义和协议组合而成。有了这类接口，您无需不断构建新的连接基础架构，就能让自己的产品和服务与其他产品和服务进行通信。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让您可以在不同环境（如开发、测试和生产等环境）之间轻松迁移应用，同时还可保留应用的全部功能。</p><p>容器使开发团队可以全心投入应用开发，而运维团队则专注于基础架构维护。容器编排是管理这些部署的方式。</p><p>Kubernetes 是一种可自动实施 Linux 容器操作的开源平台。它可以省去应用容器化过程的许多手动部署和扩展操作。Kubernetes 可提供一个便捷有效的平台，可以在物理机或虚拟机集群上调用和运行容器。Kubernetes 架构将集群分为不同的组件，这些组件要协同工作来维护集群的预期状态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简而言之，云原生，就是使用 DevOps 的方法搭建出一个完整的云端应用，这个应用由若干个运行在容器内部的微服务组成，它们之间借助 API 进行通信。</p><h3 id="How-to-Make-Change"><a href="#How-to-Make-Change" class="headerlink" title="How to Make Change"></a>How to Make Change</h3><p>首先从能够开展协作的自动化流程入手。也就是说，通过 DevOps 使开发和运维协同合作，让朝着共同目标努力并定期进行反馈。</p><p>容器提供理想的应用部署单元和独立的执行环境，为这些实践提供支持。凭借 DevOps 和容器，能更加轻松地以松散耦合服务的形式（如微服务）来发布和更新应用，而不是等待大型版本的发布。</p><p>云原生开发注重架构的模块性、松散耦合及其服务的独立性。每个微服务实现一种业务能力，在自己的流程中运行，并通过应用编程接口（API）或消息传递进行通信。该通信可通过服务层进行管理。</p><p>但是，作为云原生应用的一部分，<strong>无需始终从微服务开始以加速应用交付</strong>。仍然可以使用基于服务的实用架构来优化其传统应用。持续整合和持续部署（CI&#x2F;CD）等 DevOps 工作流以及全自动部署操作为该优化提供支持。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>既然方法思想都变了，那么对应的技术栈层面很显然也要跟随改变。</p><p>历史就是这样演变的。我们从传统的 tomcat 开发到 spring boot，再到云端的 spring cloud。</p><p>云原生开发当然也会有专门的框架和解决方案。</p><p>之前提到的 <a href="https://www.redhat.com/zh/topics/cloud-native-apps/what-is-quarkus">quarkus</a> 就是其中一种。</p><p>不过由于时间的关系（我懒，进一步的内容放在下次的分享吧。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.redhat.com/zh/topics/cloud">red hat cloud topic</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本意是希望了解一下什么是云原生（CloudNative），但是发现相关的名词解释很多。&lt;/p&gt;
&lt;p&gt;就顺带整理分享下，都是互联网老词了，老词新回顾，带领大家再冲冲浪。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cloud" scheme="https://notes.yaohwu.xyz/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title>《原则：生活与工作》 读书笔记</title>
    <link href="https://notes.yaohwu.xyz/2021/11/21/principles-life-and-work-reading-notes/"/>
    <id>https://notes.yaohwu.xyz/2021/11/21/principles-life-and-work-reading-notes/</id>
    <published>2021-11-21T13:19:53.000Z</published>
    <updated>2024-05-19T08:28:59.664Z</updated>
    
    <content type="html"><![CDATA[<p>这是一份从微信读书导出的关于《原则：生活与工作》的读书笔记，还有待再整理。</p><span id="more"></span><p>◆ 2 跨越门槛 （1967—1979年）</p><p>认清相关事情的发展之后，一切看起来就符合逻辑了。</p><blockquote><blockquote><p>符合逻辑</p></blockquote></blockquote><blockquote><blockquote><p>几乎所有事情都以符合逻辑的因果关系不断发生过</p></blockquote></blockquote><blockquote><blockquote><p>准确地判断出哪些事情正在重演，并理解背后的因果关系</p></blockquote></blockquote><p>skr</p><blockquote><blockquote><p>来自西班牙，名叫芭芭拉</p></blockquote></blockquote><p>了解你的领域</p><blockquote><blockquote><p>我了解几乎一切能想到的、与这两个市场有关的事情</p></blockquote></blockquote><p>自信点把像去掉</p><blockquote><blockquote><p>整个过程像是一部有着符合逻辑的因果关系的美丽机器。通过理解这些关系，我就能得出用来建立模型的决策规则（或者说原则）。</p></blockquote></blockquote><blockquote><blockquote><p>把复杂的系统设想为机器，发现其内部的因果关系，把处理这些因果关系的原则写下来，将其输入计算机，从而让计算机为我“决策”，所有这些后来都成了标准做法。</p></blockquote></blockquote><blockquote><blockquote><p>总是存在会给你造成重大损失的风险</p></blockquote></blockquote><blockquote><blockquote><p>假设自己没有看到全部</p></blockquote></blockquote><p>很强</p><blockquote><blockquote><p>我给儿子起名“德温”，而“德温”是人类所知的最早的牛种之一，也是最早输入美国的牛种之一，并以繁殖率高著称</p></blockquote></blockquote><p>◆ 3 我的低谷 （1979—1982年）</p><blockquote><blockquote><p>在每个投资者的职业生涯中，都有焦虑的时刻，你对未来的期待与真正发生的情况不符，你不知道自己面临的是巨大的机会还是灾难性的错误。</p></blockquote></blockquote><blockquote><blockquote><p>时机就是一切</p></blockquote></blockquote><p>冷静，相信自己总有还未考虑到的场景</p><blockquote><blockquote><p>我离谱地过度自信，并放纵自己被情绪左右</p></blockquote></blockquote><blockquote><blockquote><p>研究历史的价值</p></blockquote></blockquote><blockquote><blockquote><p>总结出经过仔细验证的永恒和普适的决策原则</p></blockquote></blockquote><blockquote><blockquote><p>时机</p></blockquote></blockquote><p>一个开放成功的团队氛围</p><blockquote><blockquote><p>一个创意择优的机构，鼓励经过深思熟虑的意见不一致，根据不同人的相对长处分析和权衡他们的观点。</p></blockquote></blockquote><blockquote><blockquote><p>使人们相互对立的观点公开化，并对其进行分析，让我对人们的思考方式有了很多的了解。我逐渐发现，人们的最大缺点与其最大优点互为正反面。例如，一些人倾向于过度冒险，而其他人的风险规避性过强；一些人过度关注细节，而其他人的思维过于宏观。大多数人都是在某个方面过度，而在另一方面不足。通常，当我们遵循自己的自然秉性做事时，我们可能考虑不到自身的弱点，这将导致我们走向失败。最重要的是失败之后怎么做。成功的人改变他们的做法，这使他们能够继续利用自己的优势，弥补自身的不足，而不成功的人不会这样做。在后文中，我将描述改变的具体策略，但在这里需要注意的重要一点是，只有当你能承认甚至接受自身的弱点时，你才能做出对自身有益的改变。</p></blockquote></blockquote><p>◆ 4 我的试炼之路 （1983—1994年）</p><blockquote><blockquote><p>靠水晶球谋生的人注定要吃碎在地上的玻璃</p></blockquote></blockquote><p>没有快速验证的环境就从历史数据中想办法快速验证，现在的ML就是在这样的大背景下开展的。</p><blockquote><blockquote><p>如果我把这些标准转化成公式（现在更时髦的叫法是“算法”），然后用这些公式计算历史数据，我就能检测，假如把我的这些公式运用到历史交易中，效果会怎么样</p></blockquote></blockquote><p>人类早期的ML模型训练和参数优化</p><blockquote><blockquote><p>我与计算机互相帮助</p></blockquote></blockquote><p>德州朴克每把都看牌，但是只有自己赢面大的时候才额外加注（手动狗头</p><blockquote><blockquote><p>只对你有高度信心的投资对象进行冒险押注，并对这些对象进行充分的分散投资</p></blockquote></blockquote><p>很多人看到的是成熟和选择的重要性，但是这句话的前提是勤奋和有创造性的工作。</p><blockquote><blockquote><p>我了解到，如果你以勤奋和有创造性的方式工作，你几乎可以得到你想要的任何东西，但你不可能同时得到所有东西。成熟意味着你可以放弃一些好的选择，从而追求更好的选择。</p></blockquote></blockquote><p>苏州的丝巾吗？（</p><blockquote><blockquote><p>我还记得有一次，当时只有10岁左右的大儿子德温，在中国以每条1美元的价格购买了许多黑丝巾，然后在圣诞节前夕在一个购物中心以每条20美元的价格卖出。这仅仅是展现他商业天赋的最初迹象。</p></blockquote></blockquote><blockquote><blockquote><p>有意义的人际关系是指开放诚恳的关系，人们彼此坦诚相待。</p></blockquote></blockquote><p>这是一个独特的思维方式，因为大多数人遇到这种情况想到的是只有加重惩罚才会避免出现更多的问题。更重的惩罚意味着更少的错误，当错误不可避免，那么面对错误降低反应才会让错误提前暴露出来。这就是人性。</p><blockquote><blockquote><p>这是一个可怕的、代价高昂的失误，而我不能做出太激烈的反应，比如把罗斯炒了以儆效尤，告诉大家我们不能容忍错误。因为错误总是免不了的，所以这么做只会促使其他人隐藏错误，而这将导致更大、代价更高的错误。</p></blockquote></blockquote><blockquote><blockquote><p>管理工具在促使人们采用正确的行为方式方面发挥着重要作用</p></blockquote></blockquote><p>那以如何让其他人能够坦城地讲出各自的相处原则呢？自身坦诚肯定是第一位的。</p><blockquote><blockquote><p>人们应当把各自的相处原则说得极为清楚</p></blockquote></blockquote><p>我的相处原则是什么呢？我其实并不以高标准要求别人，我可以很耐心地和他人摆事实讲道理，但是一旦我发现对方难以认同我表述的观点，不按照我认为的正确的方案行事，而且不能给出我认可的理由或者一个更好的解决方案，那么我就会逐渐失去耐心，开始发火。</p><blockquote><blockquote><p>各自的相处原则</p></blockquote></blockquote><p>可以尝试在团队内部去做类似的事情</p><blockquote><blockquote><p>我们开始书面记录我们的原则，这种做法持续了几十年，最终形成了“工作原则”。这些原则既是我们一致同意的相处规范，也是我对我们如何处理不断出现的新情况的思考。因为大多数情况都是以略微不同的形式不断出现的，所以这些原则被持续改进</p></blockquote></blockquote><p>每个人对待共同的事情都要做到坦诚</p><blockquote><blockquote><p>把我们的真实想法摆在桌面上</p></blockquote></blockquote><p>要经过有效的沟通。</p><blockquote><blockquote><p>存在经过深思熟虑的分歧，但人们愿意在相互了解的过程中更改观点；</p></blockquote></blockquote><p>还是那句话：利用欲望让自己努力，控制欲望让自己快乐。</p><blockquote><blockquote><p>每个人的大脑都有两部分——层次较高的逻辑部分与层次较低的情绪部分。我称此为“两个你”。它们会争夺对于一个人的控制权。管理这一冲突的方式，是我们行为最重要的驱动因素。</p></blockquote></blockquote><blockquote><blockquote><p>大脑的逻辑部分可以轻易理解了解自身弱点是一件好事（因为这是克服弱点的第一步），但大脑的情绪部分通常讨厌这么做。</p></blockquote></blockquote><p>◆ 5 终极恩惠 （1995—2010年）</p><p>为啥要强调年轻的程序员（</p><blockquote><blockquote><p>随着系统里的决策规则和数据变得越来越复杂，我们聘用了年轻的程序员，他们能更好地把指示转化为代码，</p></blockquote></blockquote><p>一个足够优秀的产品的起源可能只是一个不经意的想法</p><blockquote><blockquote><p>到20世纪90年代中期，我有了足够的钱为我的家庭设立一个信托，所以我开始思考，为了将财富传承给多代人，最好的资产配置组合应当是什么样子。</p></blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一份从微信读书导出的关于《原则：生活与工作》的读书笔记，还有待再整理。&lt;/p&gt;</summary>
    
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/categories/read/"/>
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>enum 静态变量的初始化</title>
    <link href="https://notes.yaohwu.xyz/2021/07/23/java-enum-static-field-init/"/>
    <id>https://notes.yaohwu.xyz/2021/07/23/java-enum-static-field-init/</id>
    <published>2021-07-23T02:52:23.000Z</published>
    <updated>2023-04-11T02:22:04.778Z</updated>
    
    <content type="html"><![CDATA[<p>前两天写代码的时候遇到这样的问题</p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>前两天写代码的时候遇到这样的问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.x.StorageType;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaohwu</span></span><br><span class="line"><span class="comment"> * created by yaohwu at 2021/7/23 10:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">AdditionHandlerManager</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(AdditionHandlerManager.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdditionHandler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    AdditionHandlerManager() &#123;</span><br><span class="line">        register(<span class="keyword">new</span> <span class="title class_">BiHandler</span>());</span><br><span class="line">        register(<span class="keyword">new</span> <span class="title class_">DesignerRealTimeOperateHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(AdditionHandler handler)</span> &#123;</span><br><span class="line">        handlers.add(handler);</span><br><span class="line">        <span class="comment">// here npe happened for logger is null</span></span><br><span class="line">        logger.info(String.format(<span class="string">&quot;addition handler %s register success&quot;</span>, handler.getClass().getSimpleName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(String table, StorageType type, String content)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (AdditionHandler handler : handlers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler.accept(table, type)) &#123;</span><br><span class="line">                handler.action(content);</span><br><span class="line">                logger.info(String.format(<span class="string">&quot;addition handler %s trigger success&quot;</span>, handler.getClass().getSimpleName()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 register 方法里面，出现了 logger npe 的问题。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>起初觉得问题很奇怪，不符合我们对于普通类的常识认知，构造方法的执行，肯定是要后于静态变量初始化的，为什么会出现 npe 的问题。</p><p>但是后面仔细一下，就明白了，枚举的底层实现其实相当于静态变量，而且这个静态变量相对于其他静态成员是要先初始化的，从 enum 的写法也可以得出结论。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Type</span>&#123;</span><br><span class="line">  Apple;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RED</span> <span class="operator">=</span> <span class="string">&quot;red&quot;</span>;</span><br><span class="line">  <span class="keyword">private</span> String color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>必须先完成 Apple 的定义，才能后续书写其他的静态成员。</p><p>那么显然，在第一个静态成员初始化的过程中，其他的静态成员必然没有完成初始化，出现 NPE。</p><p>实际的 枚举 代码类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.x.StorageType;</span><br><span class="line"><span class="keyword">import</span> org.apache.log4j.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaohwu</span></span><br><span class="line"><span class="comment"> * created by yaohwu at 2021/7/23 10:52 上午</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AdditionHandlerManager</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">AdditionHandlerManager</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AdditionHandlerManager</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> Logger.getLogger(AdditionHandlerManager.class);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;AdditionHandler&gt; handlers = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AdditionHandlerManager</span><span class="params">()</span> &#123;</span><br><span class="line">        register(<span class="keyword">new</span> <span class="title class_">BiHandler</span>());</span><br><span class="line">        register(<span class="keyword">new</span> <span class="title class_">DesignerRealTimeOperateHandler</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(AdditionHandler handler)</span> &#123;</span><br><span class="line">        handlers.add(handler);</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;addition handler %s register success&quot;</span>, handler.getClass().getSimpleName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">action</span><span class="params">(String table, StorageType type, String content)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (AdditionHandler handler : handlers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (handler.accept(table, type)) &#123;</span><br><span class="line">                handler.action(content);</span><br><span class="line">                logger.info(String.format(<span class="string">&quot;addition handler %s trigger success&quot;</span>, handler.getClass().getSimpleName()));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就有疑问了，为什么这样显著的错误，不能在编译器层面去做提示。</p><p>搜索时，我发现了 R 大的这篇文 <a href="https://www.iteye.com/blog/rednaxelafx-460981">enum 静态成员的初始化</a>，在规范中，<a href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9">jls 8.9.2</a> 中已经对于构造方法中静态变量的引用进行了编译期的校验，但是对应的代码放在其他方法中，在构造方法红进行调用，那么编译器就没有那么智能去挖掘对应存在的问题了。</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/BSSmsq.png" alt="image-20210816005223910"></p><p>还是要多看书、规范，来避免一些隐藏的坑点。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;前两天写代码的时候遇到这样的问题&lt;/p&gt;</summary>
    
    
    
    
    <category term="java-basic" scheme="https://notes.yaohwu.xyz/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>如何做一个有质量的技术分享</title>
    <link href="https://notes.yaohwu.xyz/2021/07/19/how-to-give-a-high-quality-technical-presentation/"/>
    <id>https://notes.yaohwu.xyz/2021/07/19/how-to-give-a-high-quality-technical-presentation/</id>
    <published>2021-07-19T06:08:23.000Z</published>
    <updated>2023-04-10T12:20:02.455Z</updated>
    
    <content type="html"><![CDATA[<p>怎么搞一个好的内部分享？</p><span id="more"></span><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>Q2 看到性能小组的技术分享，感觉很不错，我们在 Q2 的技术分享都没怎么搞，打算在 Q3 也开始搞起来。</p><p>虽然我们问题多，不用担心主题，但是担心其实分享的质量不行，先探探路。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如何评价一个技术分享是有质量的？</p><ol><li>分享的内容是有很长的保质期的，甚至历久弥新；</li><li>会被大范围的传递。</li></ol><p>我之前学习 js 模块化的时候，看到的一篇黄玄的分享 <a href="https://huangxuan.me/2015/07/09/js-module-7day/">js-module-7day</a> ，就让我有这种感觉，这是一个非常有质量的分享。虽然这是一个好几年前的分享了，而且随着 js 模块化的日益完善，其中的内容今天看来都没有什么价值了，但是其实每次看，还是能从中有新的收获。</p><p>我觉得这篇分享，就非常符合好分享的定义：</p><ol><li><p>把复杂的问题讲解的很简单也很清楚；</p><ol><li>用各种简单通俗通懂的话把各种复杂的知识讲的清清楚楚；</li><li>把复杂的问题，拆解成简单的问题；</li></ol></li><li><p>有各种各样的推导和方案的比较，让你知其然知其所以然；</p><ol><li>有方案的推导，理解更透彻；</li><li>有方案的比较，获得更全面的认知；</li></ol><p>原理、为什么、思路、方法论让人一通百通；</p></li></ol><p>那么如何做到这些呢?</p><h2 id="最佳实践路径"><a href="#最佳实践路径" class="headerlink" title="最佳实践路径"></a>最佳实践路径</h2><h3 id="先描述好一个问题"><a href="#先描述好一个问题" class="headerlink" title="先描述好一个问题"></a>先描述好一个问题</h3><p>不要吝啬问题的篇幅，描述好一个问题能够将受众带入进来，如果这个问题是他们感同身受的，那是最好了。千万不要一上来，绕过问题，直接就谈方案，这是非常难受的。其实我们现在很多的团队评审里面，就会发生这种现象，背景描述的不够全面，让人理解不了。方案上就提不出什么问题。</p><h3 id="how-比-what-更重要"><a href="#how-比-what-更重要" class="headerlink" title="how 比 what 更重要"></a>how 比 what 更重要</h3><p>这一切的大背景，就是上面的描述好一个问题。描述好问题之后，也就自然而然的可以讲到如何解决这个问题了。</p><p>要有一个解决问题的推导过程，要有最终不同技术的比较。</p><h3 id="一定要有Best-Practice或方法论总结"><a href="#一定要有Best-Practice或方法论总结" class="headerlink" title="一定要有Best Practice或方法论总结"></a>一定要有Best Practice或方法论总结</h3><p>要给出实际的最佳实践，要带有方法论的总结，上升高度。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>大纲: <strong>问题 –&gt; 方案 –&gt; 总结</strong></p><ul><li>用问题来吸引受众，带着受众来一起思考<ul><li>尽量缩小主题的范围，less is more !</li></ul></li><li>用问题模型来框住受众的思考范围，让受众聚焦</li><li>给出几种不同的解决方案，比较他们的优缺点，让受众有一种解决问题的参与感。</li><li>最后，给出最佳实践，方法论或套路，因为有了前三步的铺垫，受众欣然接受。</li><li>整个过程会让受众有强烈的成长感和收获感。</li></ul><p>额外</p><ol><li>依据场合，让分享更轻松；比如依据受众，可以用用表情包、玩玩梗之类的；</li><li>要分享自己的分享，接受更广泛受众的评价；</li><li>分享是学习知识的最难的方式。分享者获得的好处是最多的，而不是听众。</li><li>分享可以为听众打开知识的大门，但能不能获得知识还要靠自己。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>希望我们组能参考自己认为优秀的分享内容，或者我提到的黄玄的分享 <a href="https://huangxuan.me/2015/07/09/js-module-7day/">js-module-7day</a> 这篇的分享方式，来书写我们三季度待解决问题的分享。要求的不是形似，二是神似，有问题、有方案、有总结，让我们最终的分享上有收获。三季度多多产出高质量的分享。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;怎么搞一个好的内部分享？&lt;/p&gt;</summary>
    
    
    
    
    <category term="work" scheme="https://notes.yaohwu.xyz/tags/work/"/>
    
  </entry>
  
  <entry>
    <title>JDK 14 Features</title>
    <link href="https://notes.yaohwu.xyz/2020/03/16/jdk-14-features/"/>
    <id>https://notes.yaohwu.xyz/2020/03/16/jdk-14-features/</id>
    <published>2020-03-16T01:09:35.000Z</published>
    <updated>2023-04-11T01:12:38.518Z</updated>
    
    <content type="html"><![CDATA[<p>按照计划，明天（ 3 月 17 号） JDK 14 就要发布了，虽然距离真正使用还是比较远，但事先了解一下新特性还是比较好的，</p><span id="more"></span><p>按照计划，明天（ 3 月 17 号） JDK 14 就要发布了，虽然距离真正使用还是比较远，但事先了解一下新特性还是比较好的。</p><h2 id="JEP-305-Pattern-Matching-for-instanceof-Preview"><a href="#JEP-305-Pattern-Matching-for-instanceof-Preview" class="headerlink" title="JEP 305 Pattern Matching for instanceof (Preview)"></a>JEP 305 Pattern Matching for instanceof (Preview)</h2><p><a href="https://openjdk.java.net/jeps/305">JEP 305</a> 将会增强 instanceof 的模式匹配。<br>可以更简洁安全地表示对象类型的判断。</p><p>之前我们在代码中使用 instanceof:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 obj 是 String</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="comment">// 转换 obj 变成 String s</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> (Sting) obj;</span><br><span class="line">    <span class="comment">// use s</span></span><br><span class="line">    s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，上面的写法有三个步骤：</p><ol><li>判断类型；</li><li>强制类型转换；</li><li>使用转换后的类型；</li></ol><p>强制类型转换，由于不能确保先进行类型检查，所以是非常不安全的。<br>使用新的特性能更好的处理这样的问题，并且更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 obj 是 String 并转换为 s</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// use s</span></span><br><span class="line">    s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将类型判断和类型转换放在一起，不再会出现遗漏等情况，更加安全，同时从语法上来看也更简洁。<br>需要注意的是，绑定变量 s 的范围由包含的表达式和语句的语义确定。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> String s)) &#123;</span><br><span class="line">    <span class="comment">// no</span></span><br><span class="line">    .. s.contains(..) ..</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// yes</span></span><br><span class="line">    .. s.contains(..) ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s &amp;&amp; <span class="comment">/* yes */</span> s.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// yes</span></span><br><span class="line">    .. s.contains(..) ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s || <span class="comment">/* no */</span> s.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// no</span></span><br><span class="line">    .. s.contains(..) ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在表达式和语义都确认的情况下，s 才能被正确的使用。</p><p>这个特性能够帮助我们将代码变得更清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString) &amp;&amp;</span><br><span class="line">        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="meta">@Override</span> <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString cis) &amp;&amp;</span><br><span class="line">        cis.s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JEP-343-Packaging-Tool-Incubator"><a href="#JEP-343-Packaging-Tool-Incubator" class="headerlink" title="JEP 343 Packaging Tool (Incubator)"></a>JEP 343 Packaging Tool (Incubator)</h2><p><a href="https://openjdk.java.net/jeps/343">JEP 343</a> 将提供一个打包独立 java 应用程序的 cli 工具 jpackage。支持使用 ToolProviderAPI 编程调用，不支持交叉编译，打包格式包括 Windows 上的 msi 与exe，macOS 上的 pkg 和 dmg，Linux 上的 deb 和 rpm。</p><h2 id="JEP-345-NUMA-Aware-Memory-Allocation-for-G1"><a href="#JEP-345-NUMA-Aware-Memory-Allocation-for-G1" class="headerlink" title="JEP 345 NUMA-Aware Memory Allocation for G1"></a>JEP 345 NUMA-Aware Memory Allocation for G1</h2><p>通过 实现 NUMA 感知内存分配，提供了 G1 在大型机器上的性能。</p><p>&#x2F;&#x2F;todo more</p><h2 id="JEP-349-JFR-Event-Streaming"><a href="#JEP-349-JFR-Event-Streaming" class="headerlink" title="JEP 349 JFR Event Streaming"></a>JEP 349 JFR Event Streaming</h2><p><a href="https://openjdk.java.net/jeps/349">JEP 349</a> Expose JDK Flight Recorder data for continuous monitoring.</p><p>&#x2F;&#x2F; todo more</p><h2 id="JEP-352-Non-Volatile-Mapped-Byte-Buffers"><a href="#JEP-352-Non-Volatile-Mapped-Byte-Buffers" class="headerlink" title="JEP 352 Non-Volatile Mapped Byte Buffers"></a>JEP 352 Non-Volatile Mapped Byte Buffers</h2><p><a href="https://openjdk.java.net/jeps/352">JEP 352</a> Add new JDK-specific file mapping modes so that the FileChannel API can be used to create MappedByteBuffer instances that refer to non-volatile memory.</p><p>&#x2F;&#x2F; todo more</p><h2 id="JEP-358-Helpful-NullPointerExceptions"><a href="#JEP-358-Helpful-NullPointerExceptions" class="headerlink" title="JEP 358 Helpful NullPointerExceptions"></a>JEP 358 Helpful NullPointerExceptions</h2><p><a href="https://openjdk.java.net/jeps/358">JEP 358</a> 通过精准描述哪个变量是 null 来提高 jvm 生成的 NPE 的可用性。</p><p>这可以说是一个非常好的特性了，在很多代码中，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.b.i = <span class="number">99</span>;</span><br><span class="line">a[i][j][<span class="number">3</span>] = <span class="number">99</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> a.get().pop().size();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等等这种类型的代码中，一旦其中出现 npe 是很难判断就是哪一个值是 null 的。</p><p>但是通过这个新特性，就能够提供更丰富的 null 信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cannot <span class="built_in">read</span> field <span class="string">&quot;c&quot;</span> because <span class="string">&quot;a.b&quot;</span> is null;</span><br><span class="line">Cannot load from object array because <span class="string">&quot;a[i][j]&quot;</span> is null</span><br><span class="line">Cannot invoke <span class="string">&quot;x.pop()&quot;</span> because the <span class="built_in">return</span> value of <span class="string">&quot;a.get()&quot;</span> is null</span><br></pre></td></tr></table></figure><p>等等；不仅能够精确识别 null，还能提供不能进一步操作的具体原因。对于分析日志定位问题非常有帮助。</p><p>要启用这个功能，需要添加 JVM 标识：</p><blockquote><p>-XX:+ShowCodeDetailsInExceptionMessages</p></blockquote><p>这个功能在未来可能会默认开启。<br>但是这个有一个风险就是，这个信息可能包含源代码中的变量名。暴露此信息可能被视为安全风险。</p><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;按照计划，明天（ 3 月 17 号） JDK 14 就要发布了，虽然距离真正使用还是比较远，但事先了解一下新特性还是比较好的，&lt;/p&gt;</summary>
    
    
    
    
    <category term="java-basic" scheme="https://notes.yaohwu.xyz/tags/java-basic/"/>
    
  </entry>
  
  <entry>
    <title>高效能人士的七个习惯阅读笔记</title>
    <link href="https://notes.yaohwu.xyz/2019/10/27/read-The-Habits-of-Highly-Effective-People/"/>
    <id>https://notes.yaohwu.xyz/2019/10/27/read-The-Habits-of-Highly-Effective-People/</id>
    <published>2019-10-27T08:19:53.000Z</published>
    <updated>2021-05-14T11:14:42.735Z</updated>
    
    <content type="html"><![CDATA[<p>在读书计划选书的时候，我觉得我有必要提升一下自我管理的一些能力，因此选择了这本书。<br>这些是我读书的收获。</p><span id="more"></span><p>但是大致翻阅之后，书中的一个思想影响了我：</p><p><code>建议各位不要对本书等闲视之，大略读过便束之高阁。当然，你不妨从头到尾浏览一遍， 以了解全书梗概。不过我希望在你改进自我的成长过程中，本书能时时与你为伴。本书在编排方式上分 成几个循序渐进的章节，便于读者随时参阅并付诸行动。</code></p><p>作者说它不是一本一般的书，不能看完就丢弃，要时常与我为伴，还是循序渐进编排好的，让我随时参阅。这完全符合我对于<strong>工具书</strong>的定义。</p><p>之后我就尝试着我阅读工具书，甚至是阅读框架 guide 文档或者 api 文档的方式去阅读它。</p><p>我制定了一个阅读工具书的流程，按照这个流程来阅读：</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我目前遇到了什么问题，或者说我期望这次阅读能够帮我解决什么问题。</p><p>我这次的问题，就是选书时期望解决的，自我管理方面的，主要是时间管理以及效率的提升。</p><h2 id="自身的解决方案"><a href="#自身的解决方案" class="headerlink" title="自身的解决方案"></a>自身的解决方案</h2><p>针对我提出的问题，现在我有什么解决方案呢？</p><p>时间管理方面，就是自己排出一个优先级，之前其他人也分享了时间管理方法，重要紧急、不重要不紧急等等。但是我好像从中受益不多。一个是事情的划分不清晰，分不清楚；另外是，如何提升那些紧急但不重要的事情的处理效率，现在还没有系统的方法或者说理论。</p><h2 id="筛选阅读"><a href="#筛选阅读" class="headerlink" title="筛选阅读"></a>筛选阅读</h2><p>从头到位浏览了一遍后，我筛选出了几个章节模块，从他们的标题或者概览中，我猜测有解决我问题的答案。<br>几个章节模块分别是：</p><ol><li>第一部分-重新探索自我-第二章：七个习惯概论</li><li>第二部分-个人领域的成功：从依赖到独立</li><li>第四部分-自我提升和完善-第十章-习惯七-不断更新</li></ol><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>我来读……</p><h2 id="总结筛选阅读的收获"><a href="#总结筛选阅读的收获" class="headerlink" title="总结筛选阅读的收获"></a>总结筛选阅读的收获</h2><p>由于我是带着问题来读的，经过这样的筛选阅读，我可能找到了部分我问题的解决方案，也有可能收获一些其他知识。</p><h3 id="总结其他收获"><a href="#总结其他收获" class="headerlink" title="总结其他收获"></a>总结其他收获</h3><h4 id="了解了书名中的-7-个习惯以及人的成熟模型"><a href="#了解了书名中的-7-个习惯以及人的成熟模型" class="headerlink" title="了解了书名中的 7 个习惯以及人的成熟模型"></a>了解了书名中的 7 个习惯以及人的成熟模型</h4><p><img src="/resources/image/7.png" alt="7个习惯及成熟模型"></p><p>书里将习惯定义为“知识”、“技巧”与“意愿”相互交织的结果。<br>知识是理论范畴，指点“做什么”及“为何做”；技巧告诉“如何做”；意愿促使“想要做”。要养成一种习惯，三者缺一不可。</p><p>简单说，习惯是知道做什么、为何做以及如何做，并且想要做的这样一个行为。这才是一个习惯。</p><p>相对于我们日常生活中对于习惯的理解可以说相当拔高了。</p><p>我有聆听他人倾诉的习惯，需要我愿意聆听他人之外，还得知道如何聆听，而不是便听他说边玩手机。</p><p>七个习惯：</p><ol><li>积极主动，主动承担责任</li><li>以终为始，先定目标后行动</li><li>要事第一，总是按照事务重要性顺序安排生活并付诸实践</li><li>双赢思维，<del>就是我要赢两次</del>，基于双方的利益进行思考</li><li>知彼解己，先理解别人，再争取被人的理解</li><li>综合能效，寻找第三种更好的方案</li><li>不断更新，就是不断提升自己</li></ol><p>另外一个就是一个人的成熟模型。</p><p>这个很好理解，人从依赖别人，到独立，再到互相依赖。<br>可以那身边的例子作为一个对比：</p><ol><li>依赖别人，刚入职，啥都不懂，得各种看文档；自身重要性比较低，基本不重要；</li><li>独立，熟悉点了，bug 一来，谁都别管我，这个我知道怎么改并且知道怎么改得又快又好；自身开始变得重要；</li><li>互相依赖，更厉害了，你写了个新功能，都让你出个文档讲讲；自身变得较为重要；</li></ol><p>最后就是效能（产出&#x2F;产能 的平衡）</p><p>高效能人士的 7 个习惯，穿插在成熟模型中间，构成了本书的一个循序渐进的结构。</p><h4 id="四代时间管理的演进"><a href="#四代时间管理的演进" class="headerlink" title="四代时间管理的演进"></a>四代时间管理的演进</h4><p><code>如何分辨轻重缓急与培养组织能力，是时间管理的精髓。</code></p><ol><li>第一代理论着重利用便条与备忘录，在忙碌中调配时间与精力。</li><li>第二代理论强调行事历与日程表，反映出时间管理已注意到规划未来的重要。</li><li>第三代是目前正流行、讲求优先顺序的观念。也就是依据轻重缓急设定短、中、长期目标，再逐<br>日订定实现目标的计划，将有限的时间、精力加以分配，争取最高的效率。</li><li>第四代是主张关键不在于时间管理，而在于个人管理。与其着重于时间与事务的安排，不如<br>把重心放在维持产出与产能的平衡上。</li></ol><h3 id="问题的解决方案"><a href="#问题的解决方案" class="headerlink" title="问题的解决方案"></a>问题的解决方案</h3><h4 id="变被动为主动提升效率-积极主动"><a href="#变被动为主动提升效率-积极主动" class="headerlink" title="变被动为主动提升效率-积极主动"></a>变被动为主动提升效率-积极主动</h4><p>书中讲的，积极主动不仅是一个态度，更多的其实是一个责任感，是人的一种天性。<br>就像我之前在目标和维护拆分的时候说的，每一个研发其实都乐意去改自身改出来的 bug。这其实就是一种主动承担责任的天性。</p><p>但是问题在于当认为自身没有责任的时候怎么办。</p><p>我有时候就这样，这个 bug 一看 n 年前遗留的问题，完全不想改，不想深入挖掘，总是想让产品按照设计如此的方案退回。真的对这个问题没什么责任感。除非我愿意，否则没人能让我改这个 bug。</p><p>这时候怎么办？</p><ol><li><p>转换思维发现价值</p><ol><li>我该如何应对？如果这个 bug 就这样了，那我找到一种临时解决方案的话是不是就是有价值的？这样我是否愿意主动呢？至少提供个临时方案，说不定就能顺带针对 bug 去做分析？至少还能怼赢产品。改 bug 不乐意，怼产品呢？</li><li>自我意识检讨自身（自我催眠-我行我能我可以）；</li><li>我能不能找个理由或者找到问题的关键然后转给不乐意也得乐意的对应负责人？</li><li>我能不能从其他环节上减少这样的问题发生？</li><li>……</li></ol></li><li><p>实在没办法的就只能保持平静，将自己被动的情绪调整成对效率影响最低。</p></li></ol><h4 id="使命宣言-以终为始-自我领导"><a href="#使命宣言-以终为始-自我领导" class="headerlink" title="使命宣言-以终为始,自我领导"></a>使命宣言-以终为始,自我领导</h4><ol><li>给自己定一个使命宣言-每个客户 bug 三天内都至少跟进一次？以及任何你认为好的宣言，守时、亲和、详细的工作日志、广受好评的开放文档……</li><li>针对使命宣言付诸实践；</li><li>扮演法，将自己代入到生活中不同的角色中，培养个人使命的这个习惯；</li></ol><h4 id="时间管理-要事第一"><a href="#时间管理-要事第一" class="headerlink" title="时间管理-要事第一"></a>时间管理-要事第一</h4><p><img src="/resources/image/time-square.png" alt="时间管理矩阵"></p><p>这有什么特别的？大道理大家都知道，做得还是不好该怎么办？</p><p>是不是真的知道这些道理？</p><ol><li><p>认清事情的划分<br>第一类事务既紧迫又重要，需要立即处理，通常被称为“危机”或“问题”。<br>第二类事务包括建立人际关系、撰写使命宣言、<strong>规划长期目标、防患于未然</strong>等等。人人都知道这些事很重要，却因尚未迫在眉睫，反而避重就轻。<br>如果你过分注重第一类事务，那么它们的范围就会变得越来越大，最终占据你全部的时间和精力。<br>高效能人士的脑子里装的不是问题，而是机会。他们不会在各种各样的问题上浪费时间和精力，他们的思维定式是预防型的，总是能够做到防患于未然。<br>在个人管理上，<strong>着重虽不紧迫却极重要的事</strong>，找到平衡重要紧急事务和重要不紧急事务之间的关系；</p></li><li><p>第二类活动是有效自我管理的核心内容，需要将生活中心转移到第二类事务；<br>每周都围绕<strong>虽不紧迫却极重要</strong>的事情，不是按照事情的急迫程度而是<strong>重要程度</strong>来做安排。</p><ol><li>确认角色，这周要扮演什么角色？bug 修复者？目标推进者？单元测试完善者？</li><li>选择目标，针对角色制定目标；</li><li>安排进度，具体安排时间；</li><li>每日调整，<strong>第二类事务为中心</strong>，每日计划就变成了依据这个中心进行的调整；</li></ol></li></ol><p>之前自身的解决方案问题出在事情的划分上，感觉所有的问题都好象是又重要又紧急的。</p><h4 id="不断更新"><a href="#不断更新" class="headerlink" title="不断更新"></a>不断更新</h4><p><img src="/resources/image/4-options.png" alt="4 options"></p><p>重点是<strong>平衡更新</strong>,每个方向上都要不断成长，学习、坚持、实践、再学习、再坚持、再实践……</p><h2 id="对比自身解决方案和新收获的解决方案"><a href="#对比自身解决方案和新收获的解决方案" class="headerlink" title="对比自身解决方案和新收获的解决方案"></a>对比自身解决方案和新收获的解决方案</h2><p>上文都总结对比过了。</p><h2 id="下一个问题"><a href="#下一个问题" class="headerlink" title="下一个问题"></a>下一个问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在读书计划选书的时候，我觉得我有必要提升一下自我管理的一些能力，因此选择了这本书。&lt;br&gt;这些是我读书的收获。&lt;/p&gt;</summary>
    
    
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>设计软件的思想和方式</title>
    <link href="https://notes.yaohwu.xyz/2019/09/25/software-design/"/>
    <id>https://notes.yaohwu.xyz/2019/09/25/software-design/</id>
    <published>2019-09-25T08:12:57.000Z</published>
    <updated>2023-04-11T02:22:04.772Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章大致讲一些设计软件使用的原则和思想，以及一些具体的模式。其实软件行业发展这么多年来，已经解决了大量的问题。本文讲的这些内容其实全是这些为了解决问题而发明的有效的方法。</p><p>无论是适用广泛的 23 种设计模式，还是其他对于软件结构的抽象，其实类似这样的东西都能被叫做 Pattern。若干个 Pattern 组合起来，就构成了一个 Architecture。</p><span id="more"></span><h2 id="面向对象的-SOLID-原则"><a href="#面向对象的-SOLID-原则" class="headerlink" title="面向对象的 SOLID 原则"></a>面向对象的 SOLID 原则</h2><p>在讲 23 种设计模式之前，我们先来看看 SOLID 原则。</p><p>其实在我之前的分享文章<a href="https://yaohwu.xyz/#/posts/9">耦合和聚合以及软件设计的一些理论知识</a><br>中就已经提到过这些原则。在这边再详细展开说一下。</p><h3 id="Single-responsibility-principle"><a href="#Single-responsibility-principle" class="headerlink" title="Single responsibility principle"></a>Single responsibility principle</h3><p>单一职责原则，认为对象应该具有单一职责的概念。每个类都应该有单一的职责，并且该职责由这个类完全封装起来。<br>这样的结构让这个类非常健壮，修改自己类的功能，不会影响到其他的功能。<br>比如，一个报表需要导出，那么就专门搞一个导出器类来完成导出这个功能，而不是放在报表这个类中，这样即使修改导出的功能，也不会影响报表其他功能的正常使用。</p><h3 id="Open–closed-principle"><a href="#Open–closed-principle" class="headerlink" title="Open–closed principle"></a>Open–closed principle</h3><p>开闭原则，软件中的对象（类，模块，函数等等）应该对于扩展是开放的，对于修改是封闭的。这是一个非常重要的原则。对于这个原则，有两种理解：</p><p>最初的理解：</p><ol><li>如果一个模块仍可以扩展，那么它是一个开放的模块。</li><li>如果一个模块需要被其他模块使用，那么这个模块必须已经包含已定义好的稳定的描述，这些描述将不再可被修改。</li><li>如果需要将一个模块的功能进行重新修改，那么可以通过继承的方式，可以重用已有的实现。</li></ol><p>后续的理解，也就是现在被大家接受的理解：</p><ol><li>使用抽象的接口。</li><li>接口的实现是可以被修改的，并且可以通过多态在多种实现间实现替换。</li><li>由于继承自抽象接口，因此接口规范可以被重用，但是不能重用实现。</li><li>接口是不可以修改的，但是新的实现必须要实现这个接口。</li></ol><p>旧理解，强调更多的是一个稳定的已定义好的默认实现；新理解，强调更多的是一个稳定的已定义好的抽象接口。</p><p>例如还是拿报表的导出来说，我们在设计导出逻辑时，使用的是一个抽象的导出接口，可以没有任何实现，然后可以提供一种导出器比如导出 xlsx 作为一个默认的实现。当我们要做扩展的时候，应该要去重新实现抽象的导出接口，而不是继承已有的 xlsx 导出器做修改，当然更不是直接修改 xlsx 导出器。这样新的导出器实现只是依赖导出器接口，而不是依赖默认的导出器，避免默认导出器修改时被影响，也就是面向接口编程。</p><h3 id="Liskov-substitution-principle"><a href="#Liskov-substitution-principle" class="headerlink" title="Liskov substitution principle"></a>Liskov substitution principle</h3><p>里氏替换原则，在不改变程序正确性的同时，任何对象都可以由其子类型对象替换。</p><p><code>Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T.</code></p><p>里氏替换原则有至少以下两种含义：</p><ol><li>里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</li><li>如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合 LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化的，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</li></ol><p>不符合 LSP 的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。</p><p>尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。</p><p><code>正方形不是长方形。</code></p><h3 id="Interface-segregation-principle"><a href="#Interface-segregation-principle" class="headerlink" title="Interface segregation principle"></a>Interface segregation principle</h3><p>接口隔离原则，多个特定客户端的接口要优于一个通用的接口。</p><ol><li>客户端客户端不应该依赖他不需要的接口；不依赖不需要的接口，降低耦合；</li><li>类见的依赖关系应该建立在最小的接口上；最小也不是无限制最小，而是达到要求的最小的接口，提高内聚。</li></ol><h3 id="Dependency-inversion-principle"><a href="#Dependency-inversion-principle" class="headerlink" title="Dependency inversion principle"></a>Dependency inversion principle</h3><p>依赖反转原则。</p><ol><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口；降低层与层之间的耦合。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口；面向接口编程。</li></ol><p>由 Resource 依赖 Store 变成 Resource 依赖 StoreProvider，Store 实现 StoreProvider。</p><h2 id="分门别类的学习设计模式"><a href="#分门别类的学习设计模式" class="headerlink" title="分门别类的学习设计模式"></a>分门别类的学习设计模式</h2><p>经过上述的学习，我们已经知道，这些原则都是前辈总结出来的使得软件清晰可读以及可扩展时可以应用的指南，都是一个思想，具体在代码中怎么运用还需要我们面对实际情况去灵活运用。<br>那么，设计模式就是更细层面上指导我们运用的细则。虽然说是细则，但是在不同的业务及需求背景下，也会有更灵活的运用，写出的代码可能不是任何设计模式的一种。<br>所以，还是要明确一点的是，我们学东西，重要的是学 idea，次要的是学 technique。我们通过学习更细层次上的设计模式，来将比较抽象难理解的 SOLID 原则搞懂，来学习如何合理的组织我们的代码，如何解耦，如何真正的达到对修改封闭对扩展开放的效果，让我们的代码更符合上面提到的面向对象的 SOLID 原则或者一些其他原则。我们是怀着这样的目的去学习设计模式的，而不是为了去背诵这些模式。</p><p>为了合理的利用设计模式，我们应该明白一个概念，叫做扩展点。扩展点不是天生就有的，而是设计出来的。我们设计一个软件的架构的时候，我们也要同时设计一下哪些地方以后可以改，哪些地方以后不能改。倘若你的设计不能满足现实世界的需要，那你就要重构，把有用的扩展点加进去，把没用的扩展点去除掉。</p><p>学习完设计模式我们要达成什么目标呢？假如看到一个代码结构，我们应该能：</p><ol><li>讲出这个结构的代码有何优劣；</li><li>讲出符合哪些 SOLID 原则；</li><li>讲出扩展点在什么地方，如何扩展；</li><li>更厉害的是，如果需求向不同的方向变更，应该怎么将这段代码修改成一个更符合需求变更方向的结构。</li></ol><p>如果能达成这个目标，那么我们的学习就是非常成功的。</p><h3 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h3><p>todo</p><h3 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式(Builder Pattern)"></a>建造者模式(Builder Pattern)</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li><li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li><li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li><li>初始化一个对象时，参数过多，或者很多参数具有默认值</li><li>Builder模式不适合创建差异性很大的产品类，产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li><li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li></ul><h4 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h4><p>最主要的用处就是配合链式调用的，来实现一个 builder，使得大量参数的对象或者有很多默认值的对象能够清晰的创建。</p><p>至于其他的用法，见仁见智，我认为都可以使用一些简单工厂或者静态的 builder 方法来实现。<br>在很多 IDE 中，都有为复杂对象自动生成对应 builder 类的插件，比如在 intellij IDEA 中，就有类似的插件<a href="https://plugins.jetbrains.com/plugin/6585-builder-generator">builder-generator</a>。</p><h3 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h3><h4 id="适配器模式适用场景"><a href="#适配器模式适用场景" class="headerlink" title="适配器模式适用场景"></a>适配器模式适用场景</h4><p>讲一个类的接口，转换成客户期望的另外一个接口。让原本接口不兼容的类可以合作无间。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>使用组合来实现，对象适配器<br>针对被适配的实例来进行适配，使用对象的组合来实现。在调用是，所有的方法，都被委托给被适配的对象。</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/eGoQni.png" alt="对象适配器 UML 图"></p></li><li><p>使用继承来实现，类适配器</p><p>因为使用的是继承，所以更像是调用者和被适配者之间的粘合剂。</p><p>总是使用一个适配器实例即可，不会在不同的被适配对象实例间创建不同的适配器。</p><p><img src="https://testingcf.jsdelivr.net/gh/yaohwu/link-image/static/0VlslE.png" alt="类适配器 UML 图"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章大致讲一些设计软件使用的原则和思想，以及一些具体的模式。其实软件行业发展这么多年来，已经解决了大量的问题。本文讲的这些内容其实全是这些为了解决问题而发明的有效的方法。&lt;/p&gt;
&lt;p&gt;无论是适用广泛的 23 种设计模式，还是其他对于软件结构的抽象，其实类似这样的东西都能被叫做 Pattern。若干个 Pattern 组合起来，就构成了一个 Architecture。&lt;/p&gt;</summary>
    
    
    
    
    <category term="design pattern" scheme="https://notes.yaohwu.xyz/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>泛型（Generic）-泛型怎么用，来大幅提高代码可读性和易用性</title>
    <link href="https://notes.yaohwu.xyz/2019/08/14/how-to-use-java-generic/"/>
    <id>https://notes.yaohwu.xyz/2019/08/14/how-to-use-java-generic/</id>
    <published>2019-08-14T08:09:35.000Z</published>
    <updated>2023-04-11T01:12:38.517Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Before generics, you had to cast every object you read from a collection.<br>If someone accidentally inserted an object of the wrong type, casts could fail at runtime.<br>With generics, you tell the compiler what types of objects are permitted in each collection.<br>The compiler inserts casts for you automatically and tells you at compile time if you try to insert an object of the wrong type.<br>This results in programs that are both safer and clearer, but these benefits come with complications.<br>In release 1.5, generics were added to Java.</p></blockquote><p>原本以为是一个很简单的东西，后来研究了发现，其实还是有不少知识可以学习。</p><span id="more"></span><h2 id="正面回答"><a href="#正面回答" class="headerlink" title="正面回答"></a>正面回答</h2><p>这个问题可以通过两方面来回答。</p><ol><li>怎么来大幅提高代码可读性和易用性？<br>其中有一种方式叫做用泛型。</li><li>泛型怎么用？<br>继续读本文。</li></ol><h2 id="什么是范型"><a href="#什么是范型" class="headerlink" title="什么是范型"></a>什么是范型</h2><p>范型，其实单独解释这个泛型是很困难的，就比如有人问你什么是书一样，这时候最好的回答就是直接拿一本书放到他面前告诉他，这就是书。</p><p>或者我们也可以从功能上来解释，泛型提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型，其本质是参数化类型。</p><h2 id="怎么理解泛型"><a href="#怎么理解泛型" class="headerlink" title="怎么理解泛型"></a>怎么理解泛型</h2><h3 id="这样"><a href="#这样" class="headerlink" title="这样"></a>这样</h3><p>对于泛型来说，网上有一种比较流行的理解方式，就是泛型提供了一种“模板”。</p><p>就拿 <code>ArrayList</code> 来说，假设需要一种 <code>String</code> 的 <code>ArrayList</code>，那么需要写一个 <code>StringArrayList</code> 类，又需要一种 <code>Integer</code> 的 <code>ArrayList</code>，那么需要写一个 <code>IntegerArrayList</code> 类。</p><p>为了减少这种类型的代码越来越多，因此将 <code>ArrayList</code> 变成了 <code>ArrayList&lt;T&gt;</code>，提供了一种“模板”，可以方便的完成各种类型的 <code>ArrayList</code>。</p><h3 id="不"><a href="#不" class="headerlink" title="不"></a>不</h3><p>我不是很赞同这种理解方式，虽然这种理解方式一定程度上确实能帮助我们理解泛型在代码复用方面给我们带来的好处，但是这种对泛型的理解很容易落入片面，因为完全可以不用泛型，就实现这种级别的代码复用，并且这种理解方式不符合 java 语言规范的发展历史，不能让我们看到 java 语言规范内部设计时的思考。</p><p>我来说一下我是如何理解的。</p><p>泛型是 <code>java</code> 在 <code>1.5</code> 版本时引入的特性，如果我们现在不用泛型，那么写出的代码就是 <code>1.5</code> 版本之前的代码。就拿操作 <code>ArrayList</code> 来说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作一个 String 的 ArrayList</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">strList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">strList.add(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line">strList.add(<span class="string">&quot;str2&quot;</span>);</span><br><span class="line">strList.remove(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> (String) strList.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作一个 Integer 的 ArrayList</span></span><br><span class="line"><span class="type">ArrayList</span> <span class="variable">intList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">intList.add(<span class="number">1</span>);</span><br><span class="line">intList.add(<span class="number">2</span>);</span><br><span class="line">intList.remove(<span class="number">1</span>);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">int2</span> <span class="operator">=</span> (Integer) intList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以看到，即使是在 <code>1.5</code> 版本之前的代码中，需要 <code>StringArrayList</code> 或者 <code>IntegerArrayList</code> 时，直接使用 <code>ArrayList</code> 就可以了，<code>ArrayList</code> 可不是直到 <code>1.5</code> 才有的，<code>ArrayList</code> 中使用 <code>Object[]</code> 数组来实现，因为万物都可以向上转型成 <code>Object</code> 因此也就不必要每一个类型都有一个 <code>TypeArrayList</code>，这已经实现了代码复用。</p><p>但是确实又不方便的地方，哪里呢？</p><ol><li>需要强制类型转换，不够安全，不够方便；</li><li>没有类型检查，往一个类型为 <code>String</code> 的 <code>ArrayList</code> 的插入一个 <code>Integer</code> 对象是可以的。</li></ol><p>正是这两个原因，才在 <code>1.5</code> 引入的泛型。泛型来的目的是为了解决类型检查以及强制类型转换。泛型，让代码更清楚更安全，和“模板”以及代码复用只有很小的关系。</p><p>更清楚，指明类型，无需主动强制转换，直接调用相应方法；更安全，类型检查，提供保证安全的强制转换。</p><p>到了这一步，这么明显的好处，显然，在 <code>1.5</code> 版本引入泛型的特性是迫在眉睫的，但是有一个问题，怎么兼容？</p><p>新加的泛型对于旧代码来说是完全没有意义的，因为旧代码在旧版本上也能够正常运行。但是如何保证引入泛型的同时，旧代码在新版本上也能正常运行呢？</p><p>在详细说这个之前，我们先介绍一个名词，叫做 <code>可具化类型</code>（<code>reifiable type</code>），指的是 在运行期间类型完全可用的类型，例如 声明成 A 类型，那么在运行期间就一直是 A 类型，不会发生变化。</p><p>一种方式就是不改旧版本的东西，而是完全来一套新的类库。拿 <code>ArrayList</code> 来说，就是保留 <code>ArrayList</code>，同时提高一个新的泛化 <code>ArrayList</code> 我们假设叫做 <code>GArrayList</code>。</p><p>这两个是完全不一样的类型，并且都是可具化的类型，这就意味着，在运行时，这两个类库是完全独立的，这样旧代码就只能在旧版本的逻辑中运行，新版本也只能在新版本的逻辑中运行。</p><p>旧版本代码向新版本代码迁移变得非常困难，一个应用假如希望迁移到新版本代码中，那么它必须提供两个版本的代码，并且这种兼容方案会在所有代码中飞速传播，如果当时的 <code>java</code> 社区采用这种方案，那么我们现在可能学习使用的就是 <code>java 2</code>。</p><p>这种方式显然不能够满足兼容的需求，因此泛型系统的设计向寻求迁移兼容性上转变，允许现有代码可以用泛型也可以不用，这样不会再彼此独立开发的软件中间加任何依赖。</p><p>既然 <code>ArrayList</code> 和 <code>GArrayList</code> 需要迁移兼容性，那么就不能创造一个完全可具化的泛型系统。怎么办呢，<code>类型擦除</code>（<code>type erasure</code>）。</p><p>其实类型擦除和可具化类型本身就是相对的概念，可具化就是不会被擦除的类型，会进行类型擦除的就不是可具化类型。</p><p><code>java</code> 的泛型系统就是借助类型擦除来实现的，类型擦除是一种映射，即将（可能包含参数化类型和类型变量的）类型映射为（不再是参数化类型或类型变量的）类型，也就是无论何种类型的 ArrayList，在编译后都会无类型的 <code>ArrayList</code>。</p><h3 id="类型擦除带来的弊端"><a href="#类型擦除带来的弊端" class="headerlink" title="类型擦除带来的弊端"></a>类型擦除带来的弊端</h3><p>到这里，我们已经知道为什么使用类型擦除来实现泛型了。</p><p>类型擦除也给 <code>java</code> 的泛型系统带来了很多弊端：</p><ol><li>因为泛型都是引用类型，最终都会被擦除成 <code>Object</code>，因此基本类型会进行包装；<br>就像 <code>Object a = 1;</code> a 其实是 <code>Integer</code> 一样；</li><li>无法取得带泛型的 <code>Class</code><br>无论 <code>ArrayList&lt;String&gt;</code> 还是 <code>ArrayList&lt;Integer&gt;</code> 实例拿到的 <code>class</code> 都是 <code>ArrayList.class</code></li><li>因为无法获取带泛型的 <code>Class</code>，因此也就没办法判断带泛型类型的类型<br>运行时无法判断 <code>list</code> 是 <code>ArrayList&lt;String&gt;</code> 还是 <code>ArrayList&lt;Integer&gt;</code></li><li>无法实例化泛型 <code>T</code></li></ol><h2 id="哪三种泛型用法"><a href="#哪三种泛型用法" class="headerlink" title="哪三种泛型用法"></a>哪三种泛型用法</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Box</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dock</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethodTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(E[] inputArray)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s &quot;</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用泛型注意哪些"><a href="#使用泛型注意哪些" class="headerlink" title="使用泛型注意哪些"></a>使用泛型注意哪些</h2><h3 id="使用泛型，不要使用原生类型（raw-type）"><a href="#使用泛型，不要使用原生类型（raw-type）" class="headerlink" title="使用泛型，不要使用原生类型（raw type）"></a>使用泛型，不要使用原生类型（raw type）</h3><p>每个泛型都有一个不带任何实际类型参数的类型，那种类型就是原生类型，比如 <code>ArrayList&lt;T&gt;</code> 的原生类型是 <code>ArrayList</code>。</p><p>这一点就是要求我们使用泛型，因为泛型能够代码类型检查并且代码也更清楚，如果使用原生类型，那么就失去了泛型在安全性以及表述性上的优势。</p><p>两个例外：</p><ol><li><code>List&lt;String&gt;.class</code></li><li><code>o instanceof Set&lt;String&gt;</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set)&#123;</span><br><span class="line">    Set&lt;?&gt; m = (Set&lt;?&gt;) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>，<code>Set&lt;Object&gt;</code>，<code>Set&lt;?&gt;</code> 的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        put1(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Object&gt;(), <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        put2(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Object&gt;(), <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        put3(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;Object&gt;(), <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put1</span><span class="params">(Set&lt;?&gt; objects, Object o)</span> &#123;</span><br><span class="line">        <span class="comment">// compile error</span></span><br><span class="line">        objects.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put2</span><span class="params">(Set&lt;Object&gt; objects, Object o)</span> &#123;</span><br><span class="line">        objects.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">put3</span><span class="params">(Set objects, Object o)</span> &#123;</span><br><span class="line">        objects.add(o);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><code>Set</code></strong> 是原生类型，只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的；它脱离了泛型系统，是不安全的。<br><strong><code>Set&lt;Object&gt;</code></strong> 是参数化类型，表示可以包含任何对象类型的一个集合；是安全的。<br><strong><code>Set&lt;?&gt;</code></strong> 则是一个无限制的通配符类型，表示只能包含某种未知对象类型的一个集合；是安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(Set&lt;?&gt; objects, Set&lt;?&gt; objects2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objects2.contains(object)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h3><p>在使用泛型编程的过程中，会收到很多编译器警告，这些是使用泛型类型检查的好处，我们应该尽可能的消除这些警告。</p><p>如果无法消除警告，也应该始终在尽可能小的范围中使用 <code>SuppressWarnings</code> 注解并且加注释来说明原因；永远不要将 <code>SuppressWarnings</code> 注解放在类上来消除非受检警告。</p><h3 id="使用列表优先于数组"><a href="#使用列表优先于数组" class="headerlink" title="使用列表优先于数组"></a>使用列表优先于数组</h3><p>数组和泛型相比，有两个不同点：</p><p>数组是协变的，泛型是不可变的<br>例如，<code>Sub</code> 是 <code>Par</code> 的子类，那么数组类型 <code>Sub[]</code> 是 <code>Par[]</code> 的子类，但是 <code>List&lt;Sub&gt;</code> 和 <code>List&lt;Par&gt;</code> 之间没有任何父子类关系；<br>数组是可具化的，泛型要进行类型擦除<br>因此，不要出现数组和泛型混用的情况，如果出现这样的情况，优先使用列表而不是数组。</p><h3 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h3><p>这一条看似和第一条重复，其实侧重点不同，第一条侧重使用泛型，这一条侧重定义新的泛型。</p><p>当你发现你的代码中需要获取对象并进行转化，那么可以考虑使用泛型了。</p><h3 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h3><p>如同类能够从泛型中收益，方法也可以。静态工具方法尤其适合泛型化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UnmodifiableCollection</span>&lt;&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用有限制通配符来提升-API-的灵活性"><a href="#利用有限制通配符来提升-API-的灵活性" class="headerlink" title="利用有限制通配符来提升 API 的灵活性"></a>利用有限制通配符来提升 <code>API</code> 的灵活性</h3><p>使用 <code>super</code>（T 及 T 的所有父类），<code>extends</code>（T 及 T 的所有子类） 和 <code>?</code>（<code>? extends Object</code>，无边界）来提高 <code>api</code> 的灵活性。<br>使用 <strong>交集类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;AA&gt; aas = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;AA&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Docker</span>&lt;A&gt;().pushAll(aas);</span><br><span class="line">        List&lt;A&gt; as = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;A&gt;();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Docker</span>&lt;AA&gt;().popAll(as);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">A</span> &#123;</span><br><span class="line">        String <span class="title function_">a</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">AA</span> <span class="keyword">extends</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">interface</span> <span class="title class_">B</span> &#123;</span><br><span class="line">        String <span class="title function_">b</span><span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">C</span>&lt;T <span class="keyword">extends</span> <span class="title class_">A</span> &amp; B&gt; &#123;</span><br><span class="line">        T t;</span><br><span class="line"></span><br><span class="line">        String <span class="title function_">c</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> t.a() + t.b();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Docker</span>&lt;T&gt; &#123;</span><br><span class="line">        Collection&lt;T&gt; ts;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">pushAll</span><span class="params">(Collection&lt;? extends T&gt; collection)</span> &#123;</span><br><span class="line">            ts.addAll(collection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">void</span> <span class="title function_">popAll</span><span class="params">(Collection&lt;? <span class="built_in">super</span> T&gt; collection)</span> &#123;</span><br><span class="line">            collection.addAll(ts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="几个分享会问题"><a href="#几个分享会问题" class="headerlink" title="几个分享会问题"></a>几个分享会问题</h2><ol><li>对于 Java 泛型的弊端，我们应该如何规避？</li><li>哪种情况下的强转是被认为安全的，可以忽略的？哪些不是？代码中找得到例子么？</li><li>哪些非受检警告是很难消除的，代码中能找得到例子么?</li><li>举几个数组和泛型冲突的例子？</li><li>如何实现一个类型安全的异构容器？</li></ol><p>类型安全的异构容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Favorites</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">get</span><span class="params">(Class&lt;T&gt; clazz)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.cast(map.get(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Class&lt;T&gt; clazz, T t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;clazz should not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(clazz, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Favorites</span> <span class="variable">favorites</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Favorites</span>();</span><br><span class="line">        favorites.put(String.class, <span class="string">&quot;String value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局限性1</span></span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> getStringClass();</span><br><span class="line">        favorites.put(clazz, <span class="number">2</span>);</span><br><span class="line">        favorites.put(clazz, <span class="keyword">new</span> <span class="title class_">Object</span>());</span><br><span class="line">        <span class="comment">// 局限性2</span></span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        <span class="comment">// favorites.put(List&lt;String&gt;.class, new ArrayList&lt;String&gt;());</span></span><br><span class="line">        favorites.put(List.class, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title function_">getStringClass</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> String.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Before generics, you had to cast every object you read from a collection.&lt;br&gt;If someone accidentally inserted an object of the wrong type, casts could fail at runtime.&lt;br&gt;With generics, you tell the compiler what types of objects are permitted in each collection.&lt;br&gt;The compiler inserts casts for you automatically and tells you at compile time if you try to insert an object of the wrong type.&lt;br&gt;This results in programs that are both safer and clearer, but these benefits come with complications.&lt;br&gt;In release 1.5, generics were added to Java.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原本以为是一个很简单的东西，后来研究了发现，其实还是有不少知识可以学习。&lt;/p&gt;</summary>
    
    
    
    
    <category term="java-basic" scheme="https://notes.yaohwu.xyz/tags/java-basic/"/>
    
    <category term="generic" scheme="https://notes.yaohwu.xyz/tags/generic/"/>
    
  </entry>
  
  <entry>
    <title>mock-test 2 EasyMock &amp; PowerMock</title>
    <link href="https://notes.yaohwu.xyz/2019/03/10/mock-test-2-easymock-powermock/"/>
    <id>https://notes.yaohwu.xyz/2019/03/10/mock-test-2-easymock-powermock/</id>
    <published>2019-03-10T07:57:20.000Z</published>
    <updated>2021-05-14T11:14:42.735Z</updated>
    
    <content type="html"><![CDATA[<p>从遇到的问题出发，反向总结一下这段时间写单元测试的一些方法。</p><span id="more"></span><h2 id="1-EasyMock"><a href="#1-EasyMock" class="headerlink" title="1.EasyMock"></a>1.EasyMock</h2><p>EasyMock 主要也就分 mock expect replay 和 verify 这四个过程。</p><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><h4 id="mock-的方式"><a href="#mock-的方式" class="headerlink" title="mock 的方式"></a>mock 的方式</h4><ul><li>在方法中直接 mock</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 在方法中直接mock</span></span><br><span class="line">    <span class="type">Singer</span> <span class="variable">defaultSinger</span> <span class="operator">=</span> EasyMock.mock(Singer.class);</span><br><span class="line">    <span class="type">Singer</span> <span class="variable">strictSinger</span> <span class="operator">=</span> EasyMock.strictMock(Singer.class);</span><br><span class="line">    <span class="type">Singer</span> <span class="variable">niceSinger</span> <span class="operator">=</span> EasyMock.niceMock(Singer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(EasyMockRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="comment">// 使用注解</span></span><br><span class="line">    <span class="meta">@Mock(MockType.STRICT)</span></span><br><span class="line">    <span class="keyword">private</span> Singer strictSingerAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock(MockType.NICE)</span></span><br><span class="line">    <span class="keyword">private</span> Singer niceSingerAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> Singer defaultSingerAnnotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用注解处理一些依赖注入</strong>，例如：<br>被测试类 VocalConcert 里面依赖了一个 Singer 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VocalConcert</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Singer singer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">VocalConcert</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (singer != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Vocal Concert Show: &quot;</span> + singer.show();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Vocal Concert Show: ...&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这样写就可以直接将 mock 得到的 defaultMockSinger 注入到 concert 当中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(EasyMockRunner.class)</span></span><br><span class="line"><span class="comment">// 或者是 @RunWith(PowerMockRunner.class) 都可以</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VocalConcertTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestSubject</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">VocalConcert</span> <span class="variable">concert</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VocalConcert</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> Singer defaultMockSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testVocalConcert</span><span class="params">()</span> &#123;</span><br><span class="line">        EasyMock.expect(defaultMockSinger.show()).andReturn(<span class="string">&quot;defaultMockSinger show&quot;</span>).anyTimes();</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(defaultMockSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(concert.show());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想使用默认的 test runner，那么可以采用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VocalConcertTest3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">EasyMockRule</span> <span class="variable">mocks</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EasyMockRule</span>(<span class="built_in">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestSubject</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">VocalConcert</span> <span class="variable">concert</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VocalConcert</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> Singer defaultMockSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testVocalConcert</span><span class="params">()</span> &#123;</span><br><span class="line">        EasyMock.expect(defaultMockSinger.show()).andReturn(<span class="string">&quot;defaultMockSinger show&quot;</span>).anyTimes();</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(defaultMockSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(concert.show());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mock-的策略"><a href="#mock-的策略" class="headerlink" title="mock 的策略"></a>mock 的策略</h4><ul><li>default</li></ul><p>默认策略，使用 Easy.mock(XXX.class) 或者 @Mock 注解；</p><p>不介意方法是否按照 expect 的顺序进行调用，verify <strong>会</strong>针对所有期望被调用但是实际上没有调用的方法抛出异常。</p><ul><li>strict</li></ul><p>strict 策略，使用 Easy.strictMock(XXX.class) 或者 @Mock(MockType.STRICT) 注解；</p><p>相比 default 的方式，这种更为严格，所有调用的方法需要严格按照 expect 的顺序进行调用，否则会抛出异常；verify 也<strong>会</strong>针对所有期望被调用但是实际上没有调用的方法抛出异常。</p><ul><li>nice</li></ul><p>nice 策略，使用 EasyMock.niceMock(Nice.class) 或者 @Mock(MockType.NICE) 注解；</p><p>相比 default 的方式，这种更为宽松，不介意调用顺序和次数，verify <strong>不会</strong>针对所有期望被调用但是实际上没有调用的方法抛出异常。同时，针对未期望的方法调用不会像 default 或者 strict 那样抛出 AssertionError 错误，而是返回对应的空值 0，null 或者 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(EasyMockRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingerTest2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> Singer defaultSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock(MockType.STRICT)</span></span><br><span class="line">    <span class="keyword">private</span> Singer strictSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock(MockType.NICE)</span></span><br><span class="line">    <span class="keyword">private</span> Singer niceSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// default</span></span><br><span class="line">        EasyMock.expect(defaultSinger.getName()).andReturn(<span class="string">&quot;yaohwu&quot;</span>).once();</span><br><span class="line">        EasyMock.expect(defaultSinger.getBirthday()).andReturn(<span class="keyword">new</span> <span class="title class_">Date</span>()).once();</span><br><span class="line">        EasyMock.expect(defaultSinger.getName()).andReturn(<span class="string">&quot;new yaohwu&quot;</span>).once();</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(defaultSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(defaultSinger.getBirthday());</span><br><span class="line">        System.out.println(defaultSinger.getName());</span><br><span class="line">        System.out.println(defaultSinger.getName());</span><br><span class="line"></span><br><span class="line">        EasyMock.verify(defaultSinger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// strict</span></span><br><span class="line">        EasyMock.expect(strictSinger.getName()).andReturn(<span class="string">&quot;yaohwu&quot;</span>).once();</span><br><span class="line">        EasyMock.expect(strictSinger.getBirthday()).andReturn(<span class="keyword">new</span> <span class="title class_">Date</span>()).once();</span><br><span class="line">        EasyMock.expect(strictSinger.getName()).andReturn(<span class="string">&quot;new yaohwu&quot;</span>).once();</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(strictSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(strictSinger.getName());</span><br><span class="line">        System.out.println(strictSinger.getBirthday());</span><br><span class="line">        System.out.println(strictSinger.getName());</span><br><span class="line"></span><br><span class="line">        EasyMock.verify(strictSinger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nice</span></span><br><span class="line">        EasyMock.expect(niceSinger.getName()).andReturn(<span class="string">&quot;yaohwu&quot;</span>).once();</span><br><span class="line">        <span class="comment">//EasyMock.expect(niceSinger.getBirthday()).andReturn(new Date()).once();</span></span><br><span class="line">        <span class="comment">//EasyMock.expect(niceSinger.getName()).andReturn(&quot;new yaohwu&quot;).once();</span></span><br><span class="line"></span><br><span class="line">        EasyMock.replay(niceSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(niceSinger.getBirthday());</span><br><span class="line">        System.out.println(niceSinger.getName());</span><br><span class="line">        System.out.println(niceSinger.getName());</span><br><span class="line"></span><br><span class="line">        EasyMock.verify(niceSinger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部-mock"><a href="#局部-mock" class="headerlink" title="局部 mock"></a>局部 mock</h4><p>部分场景下，只希望 mock 部分方法，针对其余的方法希望能保留默认行为。这种场景一般是由于设计不好，如果非得局部 mock 也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingerTest3</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Singer</span> <span class="variable">singer</span> <span class="operator">=</span></span><br><span class="line">                EasyMock.partialMockBuilder(Singer.class)</span><br><span class="line">                        .addMockedMethod(<span class="string">&quot;getName&quot;</span>)</span><br><span class="line">                        .createMock();</span><br><span class="line"></span><br><span class="line">        EasyMock.expect(singer.getName()).andReturn(<span class="string">&quot;yaohwu&quot;</span>);</span><br><span class="line">        EasyMock.replay(singer);</span><br><span class="line"></span><br><span class="line">        System.out.println(singer.getName());</span><br><span class="line">        Assert.assertNull(singer.getBirthday());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>EasyMock 不能 mock final 和 private 的方法，即使 mock 了，实际执行的还是默认的行为；</li><li>对象实例化是通过 <a href="http://objenesis.org/">objenesis</a> 做到的，和我们的 rpc 反序列化时获取实例策略是一样的，<strong>不会触发任何执行任何构造方法</strong>，因此类中的变量不会被初始化。</li></ol><h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestMain</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">Singer</span> <span class="variable">defaultSinger</span> <span class="operator">=</span> EasyMock.mock(Singer.class);</span><br><span class="line">        <span class="comment">// 对存在返回值的方法进行录制</span></span><br><span class="line">        EasyMock.expect(defaultSinger.show()).andReturn(<span class="string">&quot;fff&quot;</span>).once();</span><br><span class="line">        EasyMock.expect(defaultSinger.getName()).andReturn(<span class="string">&quot;b&quot;</span>).once();</span><br><span class="line">        <span class="comment">// 对没有返回值的方法进行录制</span></span><br><span class="line">        defaultSinger.setName(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        EasyMock.expectLastCall()</span><br><span class="line">                .andThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Error Cannot Reset Name&quot;</span>)).once()</span><br><span class="line">                .andVoid().once()</span><br><span class="line">                .andThrow(<span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Error Cannot Reset Name For More Times&quot;</span>)).anyTimes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>times andReturn andThrow 是可以被链式调用的，并且可以是多组组合使用</li></ul><p>因此要注意顺序，一般情况，andReturn() 或者 andThrow() 在前，times() 放在最后。</p><h4 id="andStubXXX"><a href="#andStubXXX" class="headerlink" title="andStubXXX"></a>andStubXXX</h4><p>上面使用的 expect 是我们期望进行的录制并希望参与 verify 的，假设部分方法，我们也希望他们对调用做出反应，同时也不在乎他们何时何地被调用多少次，那么可以使用 andStub 开头的方法。</p><p>&#96;</p><p>EasyMock.expect(defaultMockSinger.getName()).andStubReturn(“”);<br>EasyMock.expect(defaultMockSinger.getBirthday()).andStubThrow(new RuntimeException(“Error e”));<br>&#96;</p><h4 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h4><p>&#96;</p><p>EasyMock.expect(dictionary.get(EasyMock.eq(1001L), EasyMock.anyObject(Calculator.class)))<br>        .andReturn(“J”).anyTimes();<br>&#96;</p><p>有时候，我们并不确认实际调用的参数是什么或者说实际上的参数是一个范围，那么我们就可以用到参数匹配。</p><p>EasyMock 中提供了多种多样的线程的方法来供我们使用。</p><p>需要注意的是，<strong>被调用方法的参数要么全部使用确定的值，要么全部使用参数匹配器</strong>，不能出现下面这种场景。</p><p>&#96;</p><p>EasyMock.expect(dictionary.get(1000L, EasyMock.anyObject(Calculator.class)))<br>        .andReturn(“J”).anyTimes();<br>&#96;</p><h5 id="自定义参数匹配器"><a href="#自定义参数匹配器" class="headerlink" title="自定义参数匹配器"></a>自定义参数匹配器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyMock</span>&#123;</span><br><span class="line">    <span class="comment">// EasyMock.endsWith() 的实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">endsWith</span><span class="params">(String suffix)</span> &#123;</span><br><span class="line">            reportMatcher(<span class="keyword">new</span> <span class="title class_">EndsWith</span>(suffix));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EndsWith</span> <span class="keyword">implements</span> <span class="title class_">IArgumentMatcher</span>, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">5159338714596685067L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">EndsWith</span><span class="params">(String suffix)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配规则</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matches</span><span class="params">(Object actual)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (actual <span class="keyword">instanceof</span> String) &amp;&amp; ((String) actual).endsWith(suffix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不匹配时的输出信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTo</span><span class="params">(StringBuffer buffer)</span> &#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;endsWith(\&quot;&quot;</span> + suffix + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="andAnswer-和-andDelegateTo"><a href="#andAnswer-和-andDelegateTo" class="headerlink" title="andAnswer() 和 andDelegateTo()"></a>andAnswer() 和 andDelegateTo()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo 我没怎么用到，等用到了再补充</span></span><br></pre></td></tr></table></figure><h2 id="verify"><a href="#verify" class="headerlink" title="verify"></a>verify</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testA</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 录制</span></span><br><span class="line">        expect();</span><br><span class="line">        <span class="comment">// 设定未回放状态</span></span><br><span class="line">        replay();</span><br><span class="line">        <span class="comment">// 调用业务逻辑进行测试</span></span><br><span class="line">        test();</span><br><span class="line">        <span class="comment">// 验证录制的方法调用的 times() 是否符合预期，如果和预期不符合，会抛出异常显示多或者少</span></span><br><span class="line">        verrify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>mock 对象是可以被重用的，使用 reset 方法，让他变回起初的“白纸”状态。<br>还可以通过 reset 修改策略。<br>resetToNice(mock), resetToDefault(mock), resetToStrict(mock).</p><h2 id="PowerMock"><a href="#PowerMock" class="headerlink" title="PowerMock"></a>PowerMock</h2><p>PowerMock 也有和 Mockito 配合的 api, 这里就不关注了，主要说和 EasyMock 配合的。</p><p>PowerMock is a Java framework that allows you to unit test code normally regarded as untestable.</p><p>处理 EasyMock 不能处理的 mock 场景。</p><h3 id="mock-static"><a href="#mock-static" class="headerlink" title="mock static"></a>mock static</h3><h4 id="common-mock-static"><a href="#common-mock-static" class="headerlink" title="common mock static"></a>common mock static</h4><ol><li>类上加注解 @RunWith(PowerMockRunner.class)</li><li>类上加注解 @PrepareForTest(ClassThatContainsStaticMethod.class)</li><li>mock PowerMock.mockStatic(ClassThatContainsStaticMethod.class)</li><li>expect EasyMock.expect(ClassThatContainsStaticMethod.xxx())</li><li>replay PowerMock.replay(ClassThatContainsStaticMethod.class)</li><li>verify PowerMock.verify(ClassThatContainsStaticMethod.class)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;GeneralContext.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JavaScriptImplTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JavaScriptImpl script;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RepositoryDeal repositoryDeal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">Before</span><span class="params">()</span> &#123;</span><br><span class="line">        script = <span class="keyword">new</span> <span class="title class_">JavaScriptImpl</span>();</span><br><span class="line">        script.setContent(<span class="string">&quot;console.log(&#x27;a&#x27;)&quot;</span>);</span><br><span class="line">        script.setParameters(<span class="keyword">new</span> <span class="title class_">ParameterProvider</span>[]&#123;<span class="keyword">new</span> <span class="title class_">Parameter</span>(<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;中文!+&quot;</span>)&#125;);</span><br><span class="line">        script.addJSImort(<span class="string">&quot;imported.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">        repositoryDeal = EasyMock.mock(RepositoryDeal.class);</span><br><span class="line">        EasyMock.replay(repositoryDeal);</span><br><span class="line"></span><br><span class="line">        PowerMock.mockStatic(GeneralContext.class);</span><br><span class="line">        EasyMock.expect(GeneralContext.getCurrentAppNameOfEnv()).andReturn(<span class="string">&quot;webroot&quot;</span>).anyTimes();</span><br><span class="line">        GeneralContext.listenPluginRunningChanged(EasyMock.anyObject(PluginEventListener.class));</span><br><span class="line">        EasyMock.expectLastCall().anyTimes();</span><br><span class="line">        GeneralContext.listenPlugin(</span><br><span class="line">                EasyMock.eq(PluginEventType.AfterStop), EasyMock.anyObject(PluginEventListener.class), EasyMock.anyObject(PluginFilter.class));</span><br><span class="line">        EasyMock.expectLastCall().anyTimes();</span><br><span class="line"></span><br><span class="line">        PowerMock.replayAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testCreateJS</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// do xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意，PowerMock 的 replayAll 并不会触发 EasyMock 的 replay(xxx) 因此还是要分开调用，EasyMock 只是负责给 PowerMock mock 的对象预设行为，replay 和 verify PowerMock 和 EasyMock 两者还是各走各的。</li></ul><h4 id="mock-partial-static-or-private-method"><a href="#mock-partial-static-or-private-method" class="headerlink" title="mock partial static or private method"></a>mock partial static or private method</h4><p>如下的代码中就只是 mock 了  <strong>MimeUtility</strong> 其中的两个方法。<br>其中 <strong>getDefaultMIMECharset</strong> 不是一个 <strong>public</strong> 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br><span class="line">PowerMock.mockStaticPartial(MimeUtility.class, <span class="string">&quot;getDefaultJavaCharset&quot;</span>, <span class="string">&quot;getDefaultMIMECharset&quot;</span>);</span><br><span class="line">EasyMock.expect(MimeUtility.getDefaultJavaCharset()).andAnswer(<span class="keyword">new</span> <span class="title class_">IAnswer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">answer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GBK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).once().andAnswer(<span class="keyword">new</span> <span class="title class_">IAnswer</span>&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">answer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).once();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    PowerMock.expectPrivate(MimeUtility.class, <span class="string">&quot;getDefaultMIMECharset&quot;</span>).andAnswer(<span class="keyword">new</span> <span class="title class_">IAnswer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">answer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;GBK&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).once().andAnswer(<span class="keyword">new</span> <span class="title class_">IAnswer</span>&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> String <span class="title function_">answer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).once();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    Assert.fail(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="mock-final"><a href="#mock-final" class="headerlink" title="mock final"></a>mock final</h3><p>和 mock static 一样<br>区别仅在于 <code>PowerMock.mockStatic</code> 和 <code>PowerMock.createMock</code>；</p><h3 id="mock-private"><a href="#mock-private" class="headerlink" title="mock private"></a>mock private</h3><p>用到的不多，如果出现这样的单元测试，优先考虑是不是设计上有问题或者有没有通过 public 方法的单元测试覆盖到的方法。</p><p>如果实在需要，可以参考<a href="https://github.com/powermock/powermock/wiki/MockPrivate">MockPrivate</a>。</p><h3 id="一些-Mock-技巧"><a href="#一些-Mock-技巧" class="headerlink" title="一些 Mock 技巧"></a>一些 Mock 技巧</h3><h4 id="SuppressStaticInitializationFor-“xxx-xxx-xxx”-和-suppress-策略"><a href="#SuppressStaticInitializationFor-“xxx-xxx-xxx”-和-suppress-策略" class="headerlink" title="@SuppressStaticInitializationFor(“xxx.xxx.xxx”) 和 suppress 策略"></a>@SuppressStaticInitializationFor(“xxx.xxx.xxx”) 和 suppress 策略</h4><p>假设单元测试用到了一个其他类的静态方法，但是这个类的初始化中做了很多单元测试不感知的工作，例如可能读取了授权证书等等。<br>这时候如果使用 powermock 对静态方法进行 mock 会触发这些初始化操作，但是由于相应的模块没有启动，这些初始化可能会失败，导致 mock 不了。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SessionManager</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> OtherModuleService.getService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        authenticateLicense();</span><br><span class="line">        doSomethingSpecialDependsOnOtherModule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有这样的场景，可以使用 @SuppressStaticInitializationFor(“xxx.xxx.xxx”) 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor(&quot;com.xx.SessionManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Record&gt; RECORDS = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Manager Init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;Manager.class&#125;)</span></span><br><span class="line"><span class="comment">//@SuppressStaticInitializationFor(&quot;com.v2.yaohwu.gov.Manager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManagerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">List</span> <span class="variable">expected</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        PowerMock.mockStatic(Manager.class);</span><br><span class="line">        EasyMock.expect(Manager.getAllRecord()).andReturn(expected).anyTimes();</span><br><span class="line"></span><br><span class="line">        PowerMock.replayAll();</span><br><span class="line">        <span class="type">List</span> <span class="variable">result</span> <span class="operator">=</span> Manager.getAllRecord();</span><br><span class="line">        System.out.println(result.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manager Init</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>如果放开@SuppressStaticInitializationFor(“com.v2.yaohwu.gov.Manager”) 的注释，那么输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>@SuppressStaticInitializationFor 可以阻止静态变量的声明以及静态代码块的运行。</p><p>如果需要部分变量初始化，那么可以使用 WhiteBox 的 api 对变量进行赋值 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;Manager.class&#125;)</span></span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor(&quot;com.v2.yaohwu.gov.Manager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ManagerTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常测试</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">expected</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        PowerMock.mockStatic(Manager.class);</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        EasyMock.expect(Manager.getAllRecord()).andReturn(expected).anyTimes();</span><br><span class="line"></span><br><span class="line">        PowerMock.replayAll();</span><br><span class="line">        <span class="type">List</span> <span class="variable">result</span> <span class="operator">=</span> Manager.getAllRecord();</span><br><span class="line">        System.out.println(result.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取变量 RECORDS 的值</span></span><br><span class="line">        System.out.println((String) Whitebox.getInternalState(Manager.class, <span class="string">&quot;RECORDS&quot;</span>));</span><br><span class="line">        <span class="comment">// 输出 null SuppressStaticInitializationFor 注解阻止了 RECORDS 的初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 Manager 中的私有变量进行赋值</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">expected2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 私有变量 RECORDS 中加入 一个 Manager 私有内部类 Record 的一个实例</span></span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            expected2.add(Whitebox.newInstance(Whitebox.getInnerClassType(Manager.class, <span class="string">&quot;Record&quot;</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            Assert.fail(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将变量 RECORDS 赋值</span></span><br><span class="line">        Whitebox.setInternalState(Manager.class, <span class="string">&quot;RECORDS&quot;</span>, expected2);</span><br><span class="line">        <span class="comment">// 获取变量 RECORDS 的值</span></span><br><span class="line">        System.out.println(((List) Whitebox.getInternalState(Manager.class, <span class="string">&quot;RECORDS&quot;</span>)).size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他的-suppress-场景"><a href="#其他的-suppress-场景" class="headerlink" title="其他的 suppress 场景"></a>其他的 suppress 场景</h5><ol><li>suppress(constructor(XXX.class)) 处理构造函数</li><li>suppress(method(XXX.class, “methodName”)) 处理方法</li><li>suppress(field(XXX.class, “fieldName”)) 处理变量</li></ol><p>以上都要和 @PrepareForTest(XXX.class) 配合使用。<a href="https://github.com/powermock/powermock/wiki/Suppress-Unwanted-Behavior">link</a></p><h4 id="PowerMockIgnore"><a href="#PowerMockIgnore" class="headerlink" title="@PowerMockIgnore"></a>@PowerMockIgnore</h4><p>PowerMock 采用自定义类加载器的方式加载被测试类，如果出现类型转换异常或者类加载器形式的错误，那么可以使用 @PowerMockIgnore 注解，让 PowerMock 从系统类加载器中获取类。</p><p>出现的类型转换异常：</p><p><code>xxx.xxx.xxx.xxx cannot be cast to xxx.xxx.xxxProvider</code></p><p>也不仅仅局限于这个异常，如果你看到你一个不能解决的异常，其中有 package name 的信息，那么可以尝试使用 <strong>@PowerMockIgnore</strong>。</p><p>一般这些类有 “javax.crypto.*“,”javax.net.ssl.*“,”sun.security.ssl.*“ 等。</p><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PowerMockIgnore(&#123;&quot;javax.crypto.*&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XXXTest</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>参考文档</p><ul><li><a href="http://easymock.org/">easymock</a></li><li><a href="https://github.com/powermock/powermock/wiki">powermock</a></li><li><a href="https://github.com/powermock/powermock/wiki/FAQ">powermock QA</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;从遇到的问题出发，反向总结一下这段时间写单元测试的一些方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="unit-test" scheme="https://notes.yaohwu.xyz/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://notes.yaohwu.xyz/2019/01/31/hello-world/"/>
    <id>https://notes.yaohwu.xyz/2019/01/31/hello-world/</id>
    <published>2019-01-31T12:46:25.000Z</published>
    <updated>2021-05-14T11:14:42.732Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="blog" scheme="https://notes.yaohwu.xyz/categories/blog/"/>
    
    
    <category term="blog" scheme="https://notes.yaohwu.xyz/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>web security</title>
    <link href="https://notes.yaohwu.xyz/2018/09/13/web-security/"/>
    <id>https://notes.yaohwu.xyz/2018/09/13/web-security/</id>
    <published>2018-09-13T07:54:01.000Z</published>
    <updated>2021-05-14T11:14:42.736Z</updated>
    
    <content type="html"><![CDATA[<p>安全涉及的领域很广泛，有 web 安全、DDoS 攻防、用户隐私、加密解密、数据安全、授权和认证等等，很多。</p><p>可以逐一学习。</p><p>今天我们主要讲一下 web 安全 顺带了解一下 DDoS 防范。（因为这个比较好找资料，准备的有些仓促。</p><span id="more"></span><h2 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h2><h3 id="XSS-Cross-Site-Scripting-攻击"><a href="#XSS-Cross-Site-Scripting-攻击" class="headerlink" title="XSS(Cross Site Scripting) 攻击"></a>XSS(Cross Site Scripting) 攻击</h3><p>通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的。</p><h4 id="成功的条件"><a href="#成功的条件" class="headerlink" title="成功的条件"></a>成功的条件</h4><ol><li>需要向web页面注入恶意代码</li><li>恶意代码被浏览器执行</li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>依据攻击效果可以分为两类，</p><ul><li>反射性攻击</li></ul><p>恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。</p><p>比如：</p><p><img src="https://user-images.githubusercontent.com/9320666/45463544-32542c80-b73f-11e8-9a4e-1bd48b160b90.png" alt="xssreflect"></p><ul><li>存储型攻击</li></ul><p>恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性。</p><p>例如 bbs 发帖，中插入了脚本，查看这个帖子就可能执行恶意脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com/img/bd_logo1.png?where=super&amp;id=&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id= imageid&quot;/&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;br x=&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com/img/bd_logo1.png?where=super&amp;id=&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="title function_">alert</span>(<span class="regexp">/xsst2/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> <span class="attr">x</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="XSS-防范方法"><a href="#XSS-防范方法" class="headerlink" title="XSS 防范方法"></a>XSS 防范方法</h4><ol><li><p>针对反射性攻击，可以在表单提交或者 url 传递参数之前，对参数进行过滤。</p></li><li><p>针对存储型攻击，控制用户输入的输出，可以采用白名单的方法使用合法的标签显示，过滤掉非法的字符。</p></li></ol><h3 id="CSRF-Cross—Site-Request-Forgery"><a href="#CSRF-Cross—Site-Request-Forgery" class="headerlink" title="CSRF (Cross—Site Request Forgery)"></a>CSRF (Cross—Site Request Forgery)</h3><p>既跨站点请求伪造，也被叫做 XSRF，和 XSS 一样也是一种比较常见的 web 攻击。CSRF攻击者会过过构造的第三方页面诱导受害者完成加载或者点击，利用受害者的权限，以其身份向合法网站发起恶意请求，通常用户发生状态改变的请求，比如虚拟货币的转账，账号信息修改，恶意发邮件等等，由于具有一定的隐蔽性，所以比较难以防范。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://user-images.githubusercontent.com/9320666/45463565-4861ed00-b73f-11e8-8272-6bb0fcbd9bf6.png" alt="csrf"></p><p>例如，转账的请求为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get http://xxxbank.com/transfer.do?from=rommel&amp;to=alice&amp;amount=100 HTTP/1.1</span><br></pre></td></tr></table></figure><p>CSRF 的攻击过程过程图上图所示：</p><ol><li>CSRF 攻击有一个前提条件，是用户具有某个正常访问的访问权限。一般网站的访问权限都具备一定的有效期，比如1天过期，或者几个小时过期，在此期间权限信息会保留在用户浏览器的 cookie 中，例子中假设用户C刚刚登录了网站A，权限还没有过期。</li><li>攻击者利用正常网站 A 的 CSFR 漏洞，构造页面一个恶意网页 B，在页面中包含对发往正常网站 A 的请求，在用户 C 加载页面 B（或者点击某些元素时触发）时，会触发攻击请求，目的是为了实现虚拟币的转账，请求可能隐藏得很深，用户并不一定能发现，伪造的请求如下：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">widht</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">src</span>=<span class="string">&quot;http://xxxbank.com/transfer.do?from=rommel&amp;to=attacker&amp;amount=100&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CSRF-防范方法"><a href="#CSRF-防范方法" class="headerlink" title="CSRF 防范方法"></a>CSRF 防范方法</h4><ol><li>添加 Referer 域名白名单：HTTP 的 Referer 头记录了当前请求的来源页面的URL，如果用户是通过浏览器打开的网页一般都会带有这个信息。可以验证 URL 的域名是否在网站允许的白名单内，如果不在则拒绝请求。这种方式实现比较简单，而且可以在 web 服务器层统一配置，减少了后端开发成本，但是 Referer 域可以伪造，用户浏览器的可靠性也不能完全信赖，判断 Referer 可以做为一种辅助手段，但不能根治 CSRF。</li><li>令牌 (Token) 验证：令牌验证的方式，这是目前方法CSRF的一种普遍方法，其原理是在用户正式提交数据更新之前，给用户生成一个 token，一方面 token 保存在服务端，比如 Session 或者缓存中，一方面用户提交请求时连同 token 一同提交，服务获得接收到请求之后再做 token 验证，token 不存在、或者token不一致，或者失效都算作验证失败。token 的生成具有一定的随机性，攻击者往往很难伪造。token 一般作为一个 post 字段提交，或者作为 ajax 请求的 header 信息提交。</li><li>二次验证：对于一些敏感操作，比如对涉及到交易操作的控制更加严格一些。在用户提交时可以让用户输入验证码，或者再次输入交易密码，确保是用户的真实操作，而不是机器触发的。</li><li>SameSite Cookie 属性 <a href="https://en.wikipedia.org/wiki/HTTP_cookie">Http cookie</a></li></ol><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>利用后端程序的漏洞，针对数据库进行攻击。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;$username&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;$password&quot;;</span><br></pre></td></tr></table></figure><p>如果攻击者设定了一个 password &#x3D; anywords” OR 1&#x3D;1 的密码，那么执行的 sql 就变成了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;xxx&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;anywords&quot; <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果 构造密码为 password anywords” OR 1&#x3D;1;DROP TABLE users ，那么 users 表都会被删除。</p><p><img src="https://user-images.githubusercontent.com/9320666/45463573-557edc00-b73f-11e8-8990-51c6d45c7f7e.jpg" alt="&#39;上古&#39;时代，网络上流传的搞笑图片" title="&#39;上古&#39;时代，网络上流传的搞笑图片"></p><h3 id="sql-注入防范"><a href="#sql-注入防范" class="headerlink" title="sql 注入防范"></a>sql 注入防范</h3><ul><li>预编译sql</li></ul><p>预编译 sql 的原理：</p><ol><li>基本解析：包括SQL语句的语法、语义解析，以及对应的表和列是否存在等等。</li><li>编译：将 SQL 语句编译成机器理解客理解的中间代码格式。</li><li>查询优化：编译器在所有的执行方案中选择一个最优的。</li><li>缓存：缓存优化后的执行方案。</li><li>执行阶段：执行最终查询方案并返回给用户数据。</li></ol><p>预编译语句指的是在缓存之后，在执行阶段的之前的编译后的语句，通过占位符来替代查询查询参数。同样的SQL，如果参数不同普通的SQL语句每次请求都会进行编译，而预编译语句只会编译一次，在执行阶段会从缓存中取出预编译语句并将占位符替换成查询参数数据，而在这个阶段SQL 语句已经是编译后的语句，参数数据只能最为纯数据使用，不能作为SQL语句的一部分，通过SQL字符串的拼装已经不起作用，所以可以避免SQL注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">query</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line"><span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> connection.prepareStatement( query );</span><br><span class="line">pstmt.setString( <span class="number">1</span>, username);</span><br><span class="line">pstmt.setString( <span class="number">2</span>, password);</span><br><span class="line"><span class="type">ResultSet</span> <span class="variable">results</span> <span class="operator">=</span> pstmt.executeQuery( );</span><br></pre></td></tr></table></figure><ul><li>交给 ORM 框架</li></ul><h3 id="hash-DoS-Denial-of-Service"><a href="#hash-DoS-Denial-of-Service" class="headerlink" title="hash DoS (Denial of Service)"></a>hash DoS (Denial of Service)</h3><p>我们都知道，哈希表 是一个 O(1) 的数据结构，对于其中的任意元素&#x3D;可以在一个与哈希表长度无关的时间内计算出一个哈希值（key），然后在常量时间内定位到一个bucket，找到改元素。</p><p>这是理想的情况，但是存在不同的数据项，具有相同的 hash 值，这是就会发生 hash 碰撞。</p><p>哈希表的实现需要解决碰撞问题，碰撞解决大体有两种思路，第一种是根据某种原则将被碰撞数据定为到其它桶，例如线性探测——如果数据在插入时发生了碰撞，则顺序查找这个桶后面的桶，将其放入第一个没有被使用的桶；第二种策略是每个桶不是一个只能容纳单个数据项的位置，而是一个可容纳多个数据的数据结构（例如链表或红黑树），所有碰撞的数据以某种数据结构的形式组织起来。</p><p>不论使用了哪种碰撞解决策略，都导致插入和查找操作的时间复杂度不再是 O(1)。以查找为例，不能通过key定位到桶就结束，必须还要比较原始key（即未做哈希之前的key）是否相等，如果不相等，则要使用与插入相同的算法继续查找，直到找到匹配的值或确认数据不在哈希表中。</p><p>哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量CPU资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。</p><p>web 应用 大多会使用json作为数据传递的方式，在服务端拿到 json 字符串后，都会将 json 字符串转换成 json 对象，json 对象大多都是基于 hashmap 或者 hashtable 做的，因此只要能够导致 hash 碰撞，然后结合一个较大的 json 对象，就能将 hashmap 的性能降低到极致，拖垮cpu，从而达到 DoS 的目的。</p><h2 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h2><h3 id="DDoS的概念和发展"><a href="#DDoS的概念和发展" class="headerlink" title="DDoS的概念和发展"></a>DDoS的概念和发展</h3><h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h4><p>其实可以简单理解为：让一个公开网站无法访问。要达到这个目的的方法也很简单：不断地提出服务请求，让合法用户的请求无法及时处理。</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>其实随着网络发展，很多大型企业具备较强的服务提供能力，所以应付单个请求的攻击已经不是问题。道高一尺，魔高一丈，于是乎攻击者就组织很多同伙，同时提出服务请求，直到服务无法访问，这就叫“分布式”。但是在现实中，一般的攻击者无法组织各地伙伴协同“作战”，所以会使用“僵尸网络”来控制N多计算机进行攻击。</p><h4 id="僵尸网络-肉鸡"><a href="#僵尸网络-肉鸡" class="headerlink" title="僵尸网络 肉鸡"></a>僵尸网络 肉鸡</h4><p>就是数量庞大的僵尸程序(Bot)通过一定方式组合，出于恶意目的，采用一对多的方式进行控制的大型网络，也可以说是一种复合性攻击方式。因为僵尸主机的数量很大而且分布广泛，所以危害程度和防御难度都很大。</p><p>僵尸网络具备高可控性，控制者可以在发布指令之后，就断开与僵尸网络的连接，而控制指令会自动在僵尸程序间传播执行。</p><p>这就像个生态系统一样，对于安全研究人员来说，通过捕获一个节点可以发现此僵尸网络的许多僵尸主机，但很难窥其全貌，而且即便封杀一些僵尸主机，也不会影响整个僵尸网络的生存。</p><h3 id="DDoS的攻击方式"><a href="#DDoS的攻击方式" class="headerlink" title="DDoS的攻击方式"></a>DDoS的攻击方式</h3><p>分布式拒绝服务攻击的精髓是：利用分布式的客户端，向目标发起大量看上去合法的请求，消耗或者占用大量资源，从而达到拒绝服务的目的。</p><p>其主要攻击方法有4种：</p><ul><li>攻击带宽</li></ul><p>当网络数据包的数量达到或者超过上限的时候，会出现网络拥堵、响应缓慢的情况。DDoS就是利用这个原理，发送大量网络数据包，占满被攻击目标的全部带宽，从而造成正常请求失效，达到拒绝服务的目的。</p><p>攻击者可以使用ICM泛洪(即发送大量ICMP相关报文)、或者UDP泛洪(即发送用户数据报协议的大包或小包)，使用伪造源IP地址方式进行隐匿，并对网络造成拥堵和服务器响应速度变慢等影响。</p><p>但是这种直接方式通常依靠受控主机本身的网络性能，所以效果不是很好，还容易被查到攻击源头。于是反射攻击就出现，攻击者使用特殊的数据包，也就是IP地址指向作为反射器的服务器，源IP地址被伪造成攻击目标的IP，反射器接收到数据包的时候就被骗了，会将响应数据发送给被攻击目标，然后就会耗尽目标网络的带宽资源。</p><ul><li>攻击系统</li></ul><p>创建TCP连接需要客户端与服务器进行三次交互，也就是常说的“三次握手”。这个信息通常被保存在连接表结构中，但是表的大小有限，所以当超过了存储量，服务器就无法创建新的TCP连接了。</p><p>攻击者就是利用这一点，用受控主机建立大量恶意的TCP连接，占满被攻击目标的连接表，使其无法接受新的TCP连接请求。如果攻击者发送了大量的TCP SYN报文，使服务器在短时间内产生大量的半开连接，连接表也会被很快占满，导致无法建立新的TCP连接，这个方式是SYN洪水攻击，很多攻击者都比较常用。</p><ul><li>攻击应用</li></ul><p>由于DNS和Web服务的广泛性和重要性，这两种服务就成为了消耗应用资源的分布式拒绝服务攻击的主要目标。</p><p>比如向DNS服务器发送大量查询请求，从而达到拒绝服务的效果，如果每一个DNS解析请求所查询的域名都是不同的，那么就有效避开服务器缓存的解析记录，达到更好的资源消耗效果。当DNS服务的可用性受到威胁，互联网上大量的设备都会受到影响而无法正常使用。</p><p>近些年，Web技术发展非常迅速，如果攻击者利用大量的受控主机不断地向Web服务器恶意发送大量HTTP请求，要求Web服务器处理，就会完全占用服务器资源，让正常用户的Web访问请求得不到处理，导致拒绝服务。一旦Web服务受到这种攻击，就会对其承载的业务造成致命的影响。</p><ul><li>混合攻击</li></ul><p>在实际的生活中，乖哦概念记者并不关心自己使用的哪种攻击方法管用，只要能够达到目的，一般就会发动其所有的攻击手段，尽其所能的展开攻势。对于被攻击目标来说，需要面对不同的协议、不同资源的分布式拒绝服务攻击，分析、响应和处理的成本就会大大增加。</p><p>随着僵尸网络向着小型化的趋势发展，为降低攻击成本，有效隐藏攻击源，躲避安全设备，同时保证攻击效果，针对应用层的小流量慢速攻击已经逐步发展壮大起来。因此，从另一个角度来说，DDoS攻击方面目前主要是两个方面：UDP及反射式大流量高速攻击、和多协议小流量及慢速攻击。</p><h3 id="DDoS防范"><a href="#DDoS防范" class="headerlink" title="DDoS防范"></a>DDoS防范</h3><ol><li>高性能设备</li><li>提高带宽</li><li>异常流量清洗</li><li>分布式防御</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;安全涉及的领域很广泛，有 web 安全、DDoS 攻防、用户隐私、加密解密、数据安全、授权和认证等等，很多。&lt;/p&gt;
&lt;p&gt;可以逐一学习。&lt;/p&gt;
&lt;p&gt;今天我们主要讲一下 web 安全 顺带了解一下 DDoS 防范。（因为这个比较好找资料，准备的有些仓促。&lt;/p&gt;</summary>
    
    
    
    
    <category term="security" scheme="https://notes.yaohwu.xyz/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>耦合和聚合以及软件设计的一些理论知识</title>
    <link href="https://notes.yaohwu.xyz/2018/08/23/low-coupling-and-high-cohesion-and-others/"/>
    <id>https://notes.yaohwu.xyz/2018/08/23/low-coupling-and-high-cohesion-and-others/</id>
    <published>2018-08-23T07:50:25.000Z</published>
    <updated>2021-05-14T11:14:42.734Z</updated>
    
    <content type="html"><![CDATA[<p>模块的独立性很重要，因为有效的模块化(即具有独立的模块)的软件比较容易开发出来。<br>独立的模块比较容易测试和维护。模块的独立程度可以由两个定性标准度量，这两个标准分别称为内聚和耦合。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>评价设计质量的两个条件：聚合和耦合<br>内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。<br>内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。</p><p>好的设计，应该具有高聚合，低耦合的特点。</p><p>在面向对象的设计中，有很多设计模式可以促进聚合最大化的减少无需的耦合，诸如 MVC.</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>如果一个实体执行的是一个单一的，定义明确的任务，和它有关的一切都是执行这个任务的必要条件，那么我们说这个实体是聚合的。</p><p>我们可以在实体上定义聚合，这个定义也可以延伸到类，向低层次延申可以到类中某个方法，向高层次延申可以到包，甚至更高层次的子系统，系统。</p><ol><li>好的设计目标就是每一个设计的实体都有最高可能的聚合。</li><li>一个聚合的实体功能，可以用简单的一句话来描述。</li></ol><h3 id="聚合分类"><a href="#聚合分类" class="headerlink" title="聚合分类"></a>聚合分类</h3><h4 id="理想的聚合"><a href="#理想的聚合" class="headerlink" title="理想的聚合"></a>理想的聚合</h4><ul><li>功能聚合</li></ul><p>实体执行的是单一的，定义明确的任务，无任何副作用。高聚合的方法应该是功能聚合的。</p><ul><li>信息内聚</li></ul><p>实体代表一组聚合的数据和在这些数据上独立的操作。高聚合的类应该是信息内聚的。</p><h4 id="次理想的聚合"><a href="#次理想的聚合" class="headerlink" title="次理想的聚合"></a>次理想的聚合</h4><ul><li>沟通的、连续的、程序性的聚合</li></ul><p>实体执行的是必须按照一定顺序执行的一系列任务。</p><ul><li>时间上的聚合</li></ul><p>实体执行的是必须在同一时间完成的任务，比如初始化操作，或者清理释放操作。</p><ul><li>逻辑上的聚合</li></ul><p>实体负责的是一组相关的任务，由调用方决定哪些任务被执行，一般定义多个实体或者使用多态。</p><ul><li>实用的聚合</li></ul><p>实体负责的是一组相关的任务，但也仅此而已。比如 java.util 包和 java.Math 类。这种次理想的聚合是不可避免的。他们会最“聚合”的情况也就如此了。</p><h4 id="不理想的聚合"><a href="#不理想的聚合" class="headerlink" title="不理想的聚合"></a>不理想的聚合</h4><p>实体负责的是一组无关的，只是因为巧合放在一起的任务。</p><h3 id="聚合改进"><a href="#聚合改进" class="headerlink" title="聚合改进"></a>聚合改进</h3><p>任何有更好聚合方案的实体，都应该被改进。</p><ul><li>整理实体功能，修改功能描述，依据功能描述开发功能。</li></ul><p>是不是能够用简单的一句话概括这个实体的功能(without and)，如果不能，尝试换用新的语言概括这个功能。</p><p>举例子：一个方法具有 下楼，骑车，坐地铁，到公司，打卡 等功能，概括为 去上班。</p><ul><li>拆分</li></ul><p>将一个低聚合的实体拆分成多个内部具有高聚合的实体。</p><p>举例子：一个方法具有 下楼，骑车，做地铁，到公司，到公园，打卡，自拍 等功能。拆分成两个，去上班 和 去游玩。</p><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p>耦合是对一个软件结构内不同模块之间互连程度的度量。耦合强弱取决于模块间接口的复杂程度，进入或访问一个模块的点，以及通过接口的数据。</p><p>系统的耦合程度取决于内部各个组件间的耦合程度。有些情况，耦合是必要的。我们需要做的就是去除不必要的耦合，这样对于系统的维护和修改就更容易。</p><h3 id="识别耦合"><a href="#识别耦合" class="headerlink" title="识别耦合"></a>识别耦合</h3><ol><li>A概括了或者实现了B</li><li>A通过方法依赖了B<ul><li>有局部变量B</li><li>有参数B</li><li>有返回值B</li></ul></li><li>两个结论<ul><li>重用A需要也重用B</li><li>修改B也需要修改A</li></ul></li><li>依赖是不可避免的，而且经常是必须的，要做的就是降低耦合避免复合修改（修改B也得修改A）</li></ol><h3 id="耦合缺点"><a href="#耦合缺点" class="headerlink" title="耦合缺点"></a>耦合缺点</h3><ol><li>一个模块的修改会产生涟漪效应，其他模块也需随之修改。</li><li>由于模块之间的依赖关系，模块的组合会需要更多的精力及时间。</li><li>由于一个模块依赖很多其他模块，模块的可复用性会降低。</li></ol><h3 id="耦合分类和改进"><a href="#耦合分类和改进" class="headerlink" title="耦合分类和改进"></a>耦合分类和改进</h3><p>模块耦合分为<strong>数据耦合、特征耦合、控制耦合、公共环境耦合、内容耦合</strong>。耦合程度由低到高。</p><h4 id="数据耦合"><a href="#数据耦合" class="headerlink" title="数据耦合"></a>数据耦合</h4><p>两个模块彼此间通过<strong>参数</strong>交换信息，而且交换的信息仅仅是数据（指的是单一的原子的数据片段），那么这种耦合称为数据耦合。数据耦合是低耦合。系统中至少必须存在这种耦合。这是不可避免的。</p><h4 id="特征耦合"><a href="#特征耦合" class="headerlink" title="特征耦合"></a>特征耦合</h4><p>当把整个数据结构作为参数、局部变量或者返回值，而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。</p><p>比如判断一个人是否成年，只需要传递该人的出生日期即可，不必要把人传进去。</p><p>因此这种耦合，通常是可以通过修改参数、局部变量或者返回值，只使用必要的数据元素来避免。</p><h4 id="控制耦合"><a href="#控制耦合" class="headerlink" title="控制耦合"></a>控制耦合</h4><p>传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。</p><p>比如，传递的参数中包含一个枚举类型的参数，在方法的具体逻辑中判断该参数实现不同的功能。<br>那么，完全可以通过将一个方法修改为多个方法改进这种耦合。</p><h4 id="公共环境耦合"><a href="#公共环境耦合" class="headerlink" title="公共环境耦合"></a>公共环境耦合</h4><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。<br>公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。<br>公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。</p><p>只有两个模块有公共环境，耦合有下面两种可能。</p><ol><li>一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。</li><li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li></ol><p>限制范围，比如如果是依赖的是汇率，提供一个统一获汇率配置的方法，限制耦合范围。</p><h4 id="内容耦合"><a href="#内容耦合" class="headerlink" title="内容耦合"></a>内容耦合</h4><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。</p><ol><li>一个模块访问另一个模块的内部数据。</li><li>一个模块不通过正常入口而转到另一个模块的内部。</li><li>两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。</li><li>一个模块有多个入口(这意味着一个模块有几种功能)。</li></ol><p>应该坚决避免使用内容耦合，重构吧。</p><h3 id="耦合总结"><a href="#耦合总结" class="headerlink" title="耦合总结"></a>耦合总结</h3><p>总之，耦合是影响软件复杂程度的一个重要因素。<br>应该采取下述设计原则：<br><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。</strong></p><h2 id="附录-一些软件设计的相关原则"><a href="#附录-一些软件设计的相关原则" class="headerlink" title="附录 一些软件设计的相关原则"></a>附录 一些软件设计的相关原则</h2><ul><li><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t Repeat Yourself(DRY)</a></li></ul><p>当在两个或多个地方发现一些相似的代码的时候，它们的共性抽象出来形成一个唯一的新方法，并且改变现有地方的代码让它们以一些合适的参数调用这个新的方。<br>可以说是在我们的软件开发中最常使用的原则，也最容易理解。<br>前端时间前端圈（JS圈？）还在围着这个做讨论<a href="https://zhuanlan.zhihu.com/p/35848291">我不是很懂 Node.js 社区的 DRY 文化</a>。</p><ul><li><a href="https://en.wikipedia.org/wiki/KISS_principle">Keep It Simple, Stupid(KISS)</a></li></ul><p>在界面、操作、交互设计上，简单的东西总比复杂的更容易让人接受。甚至从家装到商业风格，都有这样的实践。</p><ul><li>Program to an interface, not an implementation</li></ul><p>注重接口而不是实现，依赖接口而不是实现，是设计模式中最根本的哲学。</p><p>tip. 面向接口而不是实现，喜欢组合而不是继承 是 23个经典设计模式的设计原则</p><ul><li><a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">You Ain’t Gonna Need It (YAGNI)</a></li></ul><p>只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后需要更多功能时，可以再进行添加。软件开发是 <a href="https://en.wikipedia.org/wiki/Trade-off">trade-off</a> 的博弈。</p><ul><li><a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter(LoD)</a></li></ul><p>又称“最少知识原则”（Principle of Least Knowledge)</p><pre><code>More formally, the Law of Demeter for functions requires that a method m of an object O may only invoke the methods of the following kinds of objects:O itselfm&#39;s parametersAny objects created/instantiated within mO&#39;s direct component objectsA global variable, accessible by O, in the scope of m</code></pre><p>如果你想让你的狗跑的话，你会对狗说还是对四条狗腿说?<br><strong>use only one dot</strong></p><ul><li><p><a href="https://en.wikipedia.org/wiki/SOLID">面向对象的S.O.L.I.D 原则</a></p><ul><li>SRP Single responsibility principle 单一职责原则。一个类，只做一件事，并把这件事做好，其只有一个引起它变化的原因。单一职责原则可以看作是低耦合、高内聚在面向对象上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</li><li>OCP Open&#x2F;Closed Principle 开闭原则。模块是可扩展的而不可更改的，对扩展开放，如果新的需求或者变化，可以对代码进行扩展，以适应新的情况；对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，不要对类进行任何修改。</li><li>LSP Liskov Substitution Principle 里氏代换原则 Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.</li><li>ISP Interface Segregation Principle 接口隔离原则 Many client-specific interfaces are better than one general-purpose interface.</li><li>DIP Dependency Inversion Principle 依赖倒置原则 depend upon abstractions, not concretions. 依赖于抽象而不是实现。</li></ul></li><li><p>CCP Common Closure Principle 共同封闭原则</p></li></ul><p>一个包中所有的类应该对同一种类型的变化关闭。一起修改的类，应该组合在一起（同一个包里）。扩展了 OCP 的“关闭”概念。</p><ul><li>CRP Common Reuse Principle 共同重用原则</li></ul><p>包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。没有被一起重用的类不应该组合在一起。</p><p>CCP 让包尽可能大（CCP 原则加入功能相关的类），CRP 则让包尽可能小（CRP 原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。</p><ul><li>好莱坞原则 Hollywood Principle</li></ul><p>“Don’t call us, we’ll call you.” 意思是，好莱坞的经纪人不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。</p><p>简单来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：1) 不创建对象，而是描述创建对象的方式。2）在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。好莱坞原则就是IoC（Inversion of Control） 或DI（Dependency Injection）的基础原则。</p><ul><li>高内聚，低耦合 High Cohesion &amp; Low&#x2F;Loose coupling</li></ul><p>这个原则是 UNIX 操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。<br>内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。<br>内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。</p><ul><li>CoC (Convention over Configuration) 惯例优于配置原则</li></ul><p>简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。<br>前段时间的 maven 配置修改源码路径，以及一些 maven 本身的配置。</p><ul><li>SoC (Separation of Concerns) 关注点分离</li></ul><p>SoC 是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。</p><p>正如程序员的记忆力相对于计算机知识来说那么有限一样，程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。</p><p>就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按照标准来就一定能合得上。不断地把程序的某些部分抽象并包装起来，也是实现关注点分离的好方法。一旦一个函数被抽象出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的。同样的，一旦一个类被抽象并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。诸如组件、分层、面向服务等这些概念都是在不同的层次上做抽象和包装，以使得使用者不用关心它的内部实现细节。</p><ul><li>DbC（Design by Contract）契约式设计</li></ul><p>DbC 的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。</p><p>如果在程序设计中一个模块提供了某种功能，那么它要：</p><ol><li><p>期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。</p></li><li><p>保证退出时给出特定的属性：这就是模块的后验条件（供应商的义务，显然也是客户的权利）。</p></li><li><p>在进入时假定，并在退出时保持一些特定的属性：不变式。</p></li></ol><ul><li>ADP（Acyclic Dependencies Principle 无环依赖原则</li></ul><p>包（或服务）之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？</p><p>有两种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果 A、B、C 形成环路依赖，那么把这些共同类抽出来放在一个新的包 D 里。这样就把 C 依赖 A 变成了 C 依赖 D 以及 A 依赖 D，从而打破了循环依赖关系。第二种方法是使用 DIP（依赖倒置原则）和 ISP（接口分隔原则）设计原则。无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;模块的独立性很重要，因为有效的模块化(即具有独立的模块)的软件比较容易开发出来。&lt;br&gt;独立的模块比较容易测试和维护。模块的独立程度可以由两个定性标准度量，这两个标准分别称为内聚和耦合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="design pattern" scheme="https://notes.yaohwu.xyz/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>从单元测试出发看前端和前端模块化</title>
    <link href="https://notes.yaohwu.xyz/2018/06/20/from%20unit%20test%20to%20front%20end%20modularization/"/>
    <id>https://notes.yaohwu.xyz/2018/06/20/from%20unit%20test%20to%20front%20end%20modularization/</id>
    <published>2018-06-20T10:02:00.000Z</published>
    <updated>2021-05-14T11:14:42.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>代码是为了什么，当然是为了重复运行。如何保持unit test代码的稳定？主要靠好的API设计。API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。以后你重构的时候，只要你的unit test覆盖的够好，基本跑一遍就知道有没有改成傻逼。可以节省大量的时间。所以那些专门写不需要维护的软件的人，讨厌测试，也是情有可原的。<br>作者：vczh<br>链接：<a href="https://www.zhihu.com/question/28729261/answer/94964928">https://www.zhihu.com/question/28729261/answer/94964928</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><span id="more"></span><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><blockquote><p>代码是为了什么，当然是为了重复运行。如何保持unit test代码的稳定？主要靠好的API设计。API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。以后你重构的时候，只要你的unit test覆盖的够好，基本跑一遍就知道有没有改成傻逼。可以节省大量的时间。所以那些专门写不需要维护的软件的人，讨厌测试，也是情有可原的。<br>作者：vczh<br>链接：<a href="https://www.zhihu.com/question/28729261/answer/94964928">https://www.zhihu.com/question/28729261/answer/94964928</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>由于我们一年之中，超过一半的时间都是在做软件维护工作，因此我们需要单元测试帮助提高效率节省时间。而且当去重构某些模块的时候，甚至可能帮助设计 API。</p><p>对于我们后端的 java 代码，之前也是有分享过，可以使用 <a href="https://yaohwu.xyz/#/posts/4">EasyMock 单元测试</a>去做，而且 10 之后单元测试也写的如火如荼。</p><p>那么对于前端代码，应该怎么写单元测试呢？</p><h2 id="前端原有的测试方案"><a href="#前端原有的测试方案" class="headerlink" title="前端原有的测试方案"></a>前端原有的测试方案</h2><h3 id="原有分类"><a href="#原有分类" class="headerlink" title="原有分类"></a>原有分类</h3><p>我们原有的前端测试大致分为两部分。</p><p>一部分是使用 <a href="http://qunitjs.com/">Qunit</a> 通过我们自身的 servlet 处理对于测试页面的请求，加载一些写的单元测试到浏览器执行然后结果展现到页面上。</p><p>另外一部分是使用 <a href="http://casperjs.org/">casperjs</a> 框架编写一些自动化脚本持续集成到 Jenkins 中，主要完成一些在浏览器端交互方面的测试。</p><p>其实这也说明了，在前端的代码中，我们要针对两种类型的代码做测试。</p><p>一种就是对应我们使用 Qunit 写的部分单元测试，大部分是针对一些和前端 UI 不耦合的代码，包括一些工具函数，以及一些抽象的代码，和 UI 不耦合。</p><p>另外一种就是和 UI 耦合非常严重的代码，应该是我们的大部分代码，使用 casperjs 框架去完成针对 ui 交互部分的测试。</p><h3 id="原有测试下的问题"><a href="#原有测试下的问题" class="headerlink" title="原有测试下的问题"></a>原有测试下的问题</h3><p>当前前端单元测试方案可能存在的问题。</p><ol><li>使用 Qunit 写的需要在浏览器端执行，难持续集成。PS.当然可以再通过 casperjs 去针对 Qunit 部分的测试再去写测试，麻烦。</li><li>使用 casperjs 做测试，我们需要做的工作比较多。又要做模板，又要写测试。</li><li>和 UI 的耦合迫使我们只能使用 casperjs 这种复杂的方案，而不能在服务端运行 js 完成测试。</li></ol><h3 id="如何解决这些问题"><a href="#如何解决这些问题" class="headerlink" title="如何解决这些问题"></a>如何解决这些问题</h3><ol><li>借助 nodejs，我们可以非常方便的将和 UI 不耦合的代码直接在服务端运行和测试。因为没有 ui 交互的部分，这些代码其实完全是 pure js 代码，和 server-side js 代码区别很小。(很小？)</li><li>使用 casperjs 写测试，是不是能够跳过做模板的这一步？</li><li>前端的代码能不能和 UI 降低耦合，方便使用更简单的方式去写单元测试，而不是使用 caspserjs。</li></ol><h2 id="新的测试方案"><a href="#新的测试方案" class="headerlink" title="新的测试方案"></a>新的测试方案</h2><h3 id="新分类"><a href="#新分类" class="headerlink" title="新分类"></a>新分类</h3><p>其实和原有的分类没有什么大的区别。我们在 旧分类中也解释了，前端代码中一部分是我们能够使用 nodejs 运行并测试的代码，另外一部分是借助浏览器去完成运行和测试的代码。</p><ol><li>能够直接借助 nodejs 运行和测试的部分。</li><li>想办法借助 nodejs 运行和测试的部分。</li></ol><p>不同于旧有测试方案分类的主要有三点：</p><ol><li>不再使用自身的 servlet 处理测试请求然后在浏览器执行测试；而是直接借助 nodejs 完成测试。</li><li>还是使用 casperjs 来完成耦合交互的前端代码测试，但是跳过模板制作，而是直接写脚本。</li><li>降低代码同交互部分不需要的耦合，使能够直接使用 nodejs 进行测试的代码所占比例提高。</li></ol><h3 id="直接借助-nodejs-运行的代码"><a href="#直接借助-nodejs-运行的代码" class="headerlink" title="直接借助 nodejs 运行的代码"></a>直接借助 nodejs 运行的代码</h3><p>其实我们原本使用的 <a href="http://qunitjs.com/">Qunit</a> 也提供了 nodejs 运行的版本。详细见官网。</p><p>完成安装配置之后，写一段 js 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">QUnit</span> = <span class="built_in">require</span>(<span class="string">&quot;qunit&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&quot;assert&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title class_">QUnit</span>.<span class="title function_">test</span>(<span class="string">&quot;hello test1&quot;</span>, <span class="keyword">function</span> (<span class="params">assert</span>) &#123;</span><br><span class="line">    assert.<span class="title function_">ok</span>(<span class="number">1</span> === <span class="number">1</span>, <span class="string">&quot;Passed!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">QUnit</span>.<span class="title function_">test</span>(<span class="string">&quot;hello test2&quot;</span>, <span class="keyword">function</span> (<span class="params">assert</span>) &#123;</span><br><span class="line">    assert.<span class="title function_">equal</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;failed!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 qunit 提供的 cli 运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">qunit</span></span><br><span class="line">TAP version 13</span><br><span class="line">ok 1 hello test</span><br><span class="line">not ok 2 hello test</span><br><span class="line">  ---</span><br><span class="line">  message: &quot;failed!&quot;</span><br><span class="line">  severity: failed</span><br><span class="line">  actual: 1</span><br><span class="line">  expected: 2</span><br><span class="line">  stack:     at Object.&lt;anonymous&gt; (E:\release10.0\fine-js-test\test\use-qunit-test.js:10:12)</span><br><span class="line">    at runTest (E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1530:30)</span><br><span class="line">    at Test.run (E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1516:6)</span><br><span class="line">    at E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1737:12</span><br><span class="line">    at advanceTaskQueue (E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1129:6)</span><br><span class="line">    at advance (E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1110:4)</span><br><span class="line">  ...</span><br><span class="line">1..2</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pass 1</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">skip 0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">todo 0</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">fail 1</span></span><br></pre></td></tr></table></figure><p>这是 qunit 提供的运行在 node 之上的测试方案。</p><p>既然我们原本就没有使用这种，并且 qunit 是比较老的框架了，和更流行的测试框架 mocha，它存在很多的缺点，诸如扩展性差，配置项复杂，异步测试复杂等。</p><p>因此我们可以直接使用更好的测试框架 <a href="https://mochajs.org/">mocha</a>。</p><p>这边主要分享一下 mocha。</p><h4 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a>mocha</h4><h5 id="接口类型INTERFACES"><a href="#接口类型INTERFACES" class="headerlink" title="接口类型INTERFACES"></a>接口类型INTERFACES</h5><p>mocha的测试接口类型指的是集中测试用例组织模式的选择。Mocha提供了BDD(Behavior Driven Development),TDD(Test Driven Development),Exports,QUnit和Require-style几种接口。</p><ul><li>BDD</li></ul><p>BDD测试提供了describe()，context()，it()，specify()，before()，after()，beforeEach()和afterEach()这几种函数。</p><p>context()是describe()的别名，二者的用法是一样的。最大的作用就是让测试的可读性更好，组织的更好。相似地，specify()是it()的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;Array&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">before</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Array before&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">after</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Array after&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">beforeEach</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Array before for each&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">afterEach</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Array after for each&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">describe</span>(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">describe</span>(<span class="string">&#x27;when not present&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">it</span>(<span class="string">&#x27;should not throw an error&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">indexOf</span>(<span class="number">4</span>);</span><br><span class="line">                &#125;).<span class="property">should</span>.<span class="property">not</span>.<span class="keyword">throw</span>();</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="title function_">it</span>(<span class="string">&#x27;should return -1&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">indexOf</span>(<span class="number">4</span>).<span class="property">should</span>.<span class="title function_">equal</span>(-<span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="title function_">describe</span>(<span class="string">&#x27;when present&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="title function_">it</span>(<span class="string">&#x27;should return the index where the element first appears in the array&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">                [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">indexOf</span>(<span class="number">3</span>).<span class="property">should</span>.<span class="title function_">equal</span>(<span class="number">2</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>相应的执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array before</span><br><span class="line">Array before for each</span><br><span class="line">Array after for each</span><br><span class="line">Array before for each</span><br><span class="line">Array after for each</span><br><span class="line">Array before for each</span><br><span class="line">Array after for each</span><br><span class="line">Array after</span><br></pre></td></tr></table></figure><ul><li>TDD</li></ul><p>TDD风格的测试提供了suite(), test(), suiteSetup(), suiteTeardown(), setup(), 和 teardown()这几个函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">suite</span>(<span class="string">&#x27;Array&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">suiteSetup</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;suite set up&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">suiteTeardown</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;suite tear down&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">setup</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="title function_">teardown</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">suite</span>(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">test</span>(<span class="string">&#x27;should return -1 when not present&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            assert.<span class="title function_">equal</span>(-<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">indexOf</span>(<span class="number">4</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mocha --ui tdd test/use-mocha-test.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Demo</span><br><span class="line">    test1</span><br><span class="line">      √ should equal</span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">Array before</span><br><span class="line">    #indexOf()</span><br><span class="line">      when not present</span><br><span class="line">Array before for each</span><br><span class="line">        √ should not throw an error</span><br><span class="line">Array after for each</span><br><span class="line">Array before for each</span><br><span class="line">        √ should return -1</span><br><span class="line">Array after for each</span><br><span class="line">      when present</span><br><span class="line">Array before for each</span><br><span class="line">        √ should return the index where the element first appears in the array</span><br><span class="line">Array after for each</span><br><span class="line">Array after</span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">suite set up</span><br><span class="line">    #indexOf()</span><br><span class="line">      √ should return -1 when not present</span><br><span class="line">suite tear down</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  5 passing (15ms)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ps. mocha 默认使用 bdd 接口，如果想要更换接口类型，需要使用在 cli 中提供的 –ui 参数 <em>-u, –ui &lt;name&gt;                         specify user-interface (bdd|tdd|qunit|exports)</em></p><ul><li>EXPORTS</li></ul><p>EXPORTS 的写法有的类似于 Mocha 的前身 <a href="https://github.com/visionmedia/expresso">expresso</a> ，键 before, after, beforeEach, 和afterEach都具有特殊的含义。对象值对应的是测试集合，函数值对应的是测试用例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">before</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;Array&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;#indexOf()&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;should return -1 when not present&#x27;</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">indexOf</span>(<span class="number">4</span>).<span class="property">should</span>.<span class="title function_">equal</span>(-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>QUNIT</li></ul><p>QUNIT 风格的测试像TDD 接口一样支持 suite 和 test 函数，同时又像 BDD 一样支持 before(), after(), beforeEach(), 和 afterEach()等 hook 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*qunit*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>), assert = chai.<span class="property">assert</span>, should = chai.<span class="title function_">should</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ok = assert.<span class="property">isOk</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">suite</span>(<span class="string">&#x27;Array&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;#length&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_">ok</span>(arr.<span class="property">length</span> === <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    <span class="title function_">ok</span>(arr.<span class="title function_">indexOf</span>(<span class="number">1</span>) === <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">ok</span>(arr.<span class="title function_">indexOf</span>(<span class="number">2</span>) === <span class="number">1</span>);</span><br><span class="line">    <span class="title function_">ok</span>(arr.<span class="title function_">indexOf</span>(<span class="number">3</span>) === <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">suite</span>(<span class="string">&#x27;String&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&#x27;#length&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">ok</span>(<span class="string">&#x27;foo&#x27;</span>.<span class="property">length</span> === <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="title function_">suite</span>(<span class="string">&quot;group a&quot;</span>);</span><br><span class="line"><span class="title function_">before</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">afterEach</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;after&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title function_">test</span>(<span class="string">&quot;a basic test example&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    assert.<span class="title function_">ok</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title function_">test</span>(<span class="string">&quot;a basic test example 2&quot;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">ok</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>REQUIRE</li></ul><p>REQUIRE 可以使用 require 方法引入 describe 等函数，同时，你可以为其设置一个别名。如果你不想在测试中出现全局变量，这个方法也是十分实用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testCase = <span class="built_in">require</span>(<span class="string">&#x27;mocha&#x27;</span>).<span class="property">describe</span>;</span><br><span class="line"><span class="keyword">var</span> pre = <span class="built_in">require</span>(<span class="string">&#x27;mocha&#x27;</span>).<span class="property">before</span>;</span><br><span class="line"><span class="keyword">var</span> assertions = <span class="built_in">require</span>(<span class="string">&#x27;mocha&#x27;</span>).<span class="property">it</span>;</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>).<span class="property">assert</span>;</span><br><span class="line"></span><br><span class="line"><span class="title function_">testCase</span>(<span class="string">&#x27;Array&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">pre</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">testCase</span>(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">assertions</span>(<span class="string">&#x27;should return -1 when not present&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">            assert.<span class="title function_">equal</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].<span class="title function_">indexOf</span>(<span class="number">4</span>), -<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这种方案，是有bug的，详见 <a href="https://github.com/mochajs/mocha/issues/956">issues&#x2F;956</a>，一个比较旧的 bug 了，如果不使用 node_modules&#x2F;mocha&#x2F;bin&#x2F;mocha 执行这样的 js ，那么 <em>require(‘mocha’).describe</em>拿到是<em>undefined</em>。</p><h6 id="同步和异步SYNCHRONOUS-CODE-AND-ASYNCHRONOUS-CODE"><a href="#同步和异步SYNCHRONOUS-CODE-AND-ASYNCHRONOUS-CODE" class="headerlink" title="同步和异步SYNCHRONOUS CODE AND ASYNCHRONOUS CODE"></a>同步和异步SYNCHRONOUS CODE AND ASYNCHRONOUS CODE</h6><p>使用 mocha 测试异步代码是再简单不过了。只需要在测试完成的时候调用一下回调函数即可。通过添加一个回调函数(通常命名为 done)给 it() 方法，Mocha 就会知道，它应该等这个函数被调用的时候才能完成测试。hook 函数也是如此。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">Demo</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../src/demo.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>), assert = chai.<span class="property">assert</span>, should = chai.<span class="title function_">should</span>();</span><br><span class="line"></span><br><span class="line"><span class="title function_">describe</span>(<span class="string">&#x27;async test&#x27;</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">before</span>(<span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async test before&#x27;</span>);</span><br><span class="line">        sucCallback = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// some success method</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test before save success&#x27;</span>);</span><br><span class="line">            <span class="title function_">done</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Demo</span>().<span class="title function_">save</span>(sucCallback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">afterEach</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;async test after each&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="title function_">it</span>(<span class="string">&#x27;async test #save&#x27;</span>, <span class="keyword">function</span> (<span class="params">done</span>) &#123;</span><br><span class="line">        sucCallback = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// some success method</span></span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;save success&#x27;</span>);</span><br><span class="line">            <span class="title function_">done</span>();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="title class_">Demo</span>().<span class="title function_">save</span>(sucCallback);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="借助-nodejs-模仿在浏览器运行的代码"><a href="#借助-nodejs-模仿在浏览器运行的代码" class="headerlink" title="借助 nodejs 模仿在浏览器运行的代码"></a>借助 nodejs 模仿在浏览器运行的代码</h3><p>casperjs is a navigation scripting &amp; testing utility for the PhantomJS (WebKit) and SlimerJS (Gecko) headless browsers, written in Javascript.</p><p>casperjs 需要先安装 PhantomJS 或者 SlimerJS。通过 <a href="http://casperjs.org/">get start</a> 一步一步就可以。</p><p>demo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> casper = <span class="built_in">require</span>(<span class="string">&#x27;casper&#x27;</span>).<span class="title function_">create</span>();</span><br><span class="line">casper.<span class="title function_">start</span>(<span class="string">&#x27;http://casperjs.org/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">casper.<span class="title function_">then</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">echo</span>(<span class="string">&#x27;First Page: &#x27;</span> + <span class="variable language_">this</span>.<span class="title function_">getTitle</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">casper.<span class="title function_">thenOpen</span>(<span class="string">&#x27;http://phantomjs.org&#x27;</span>, <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">echo</span>(<span class="string">&#x27;Second Page: &#x27;</span> + <span class="variable language_">this</span>.<span class="title function_">getTitle</span>());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">casper.<span class="title function_">run</span>();</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">casperjs test/casperjs.demo.js</span><br><span class="line"></span><br><span class="line">yaohw@yaohwu MINGW64 /e/release10.0/fine-js-test (master)</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">First Page: CasperJS, a navigation scripting and testing utility <span class="keyword">for</span> PhantomJS and SlimerJS</span></span><br><span class="line">Second Page: PhantomJS - Scriptable Headless Browser</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>惨的是：PhantomJS 已经要逐渐没人维护了。<a href="http://www.itboth.com/d/eQbUv2/phantomjs">phantomJs之殇，chrome-headless之生</a></p><p><a href="https://karma-runner.github.io/2.0/index.html">karma</a></p><p>ps. 免去制作模板的步骤指的是，可以直接在 js 中去控制生成控件以及相关 dom , 只要请求到一个能够加载进来所需 完整 js 的地址就可以。</p><h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><p>js 的模块化。</p><p>之前vito 做过一个版本的模块化，但是主要解决的是加载finereport.js 的问题。</p><p>模块化内容比较多，我不懂得也很多，这次就不怎么分享了。</p><p>可以看一下：<a href="https://huangxuan.me/js-module-7day/#/">js-module-7day</a></p><h3 id="前端的问题"><a href="#前端的问题" class="headerlink" title="前端的问题"></a>前端的问题</h3><p>上次 vuejs 分享之后，我也在不断想这个事情，就是如何能让我们的前端跟上时代。</p><p>为了解决这个问题，我了解了一下我们的 js 代码是怎么加载到浏览器端的。</p><ul><li>我们自身的模块化</li></ul><p>其实我们自身本来就有自己的模块化。</p><p>我们不同的前端组件都是散落在不同的 js 文件中，这是一个非常显著的模块化倾向。</p><p>但是我们这些又不是真正的模块化，因为我们每一个 js 文件，单独拿到浏览器端是运行不了的。没有解决各个模块之前的依赖问题，在运行单个 js 文件的时候就会有各种undefined。</p><p>为了解决这个问题，我们将每个 js 文件在启动服务器的时候拼接起来，放在服务端的一个缓存里面，每次前端发送 op cmd 就从 缓存 中去读 js 代码字符串做响应。</p><p>ps：</p><ol><li>这个拼接 js 的启动耗时算不算问题？</li><li>无论采用何种优化，在高并发场景下，对于 js 等静态资源文件的请求会不会存在锁竞争。</li></ol><p>让我们的前端跟上时代的第一步是不是就是改变这种加载方式？</p><ul><li>从jar包里面拿出来</li></ul><p>引入 webpack？ 自己完成编译</p><p>最大化的放大前端模块化的优势，同时使得 ide 能够更好的帮助进行前端开发和维护<br>会不会 更加容易做单元测试？</p><ul><li>之前的 requirejs 模块化做了什么？</li></ul><p>Asynchronous Module Definition 实现异步加载</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;代码是为了什么，当然是为了重复运行。如何保持unit test代码的稳定？主要靠好的API设计。API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。以后你重构的时候，只要你的unit test覆盖的够好，基本跑一遍就知道有没有改成傻逼。可以节省大量的时间。所以那些专门写不需要维护的软件的人，讨厌测试，也是情有可原的。&lt;br&gt;作者：vczh&lt;br&gt;链接：&lt;a href=&quot;https://www.zhihu.com/question/28729261/answer/94964928&quot;&gt;https://www.zhihu.com/question/28729261/answer/94964928&lt;/a&gt;&lt;br&gt;来源：知乎&lt;br&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="unit-test" scheme="https://notes.yaohwu.xyz/tags/unit-test/"/>
    
    <category term="front-end" scheme="https://notes.yaohwu.xyz/tags/front-end/"/>
    
  </entry>
  
</feed>
