<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yaohwu</title>
  
  <subtitle>notes</subtitle>
  <link href="https://notes.yaohwu.xyz/atom.xml" rel="self"/>
  
  <link href="https://notes.yaohwu.xyz/"/>
  <updated>2022-01-13T02:55:29.120Z</updated>
  <id>https://notes.yaohwu.xyz/</id>
  
  <author>
    <name>yaohwu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>how-to-make-a-decision</title>
    <link href="https://notes.yaohwu.xyz/2022/01/12/how-to-make-a-decision/"/>
    <id>https://notes.yaohwu.xyz/2022/01/12/how-to-make-a-decision/</id>
    <published>2022-01-12T11:05:48.000Z</published>
    <updated>2022-01-13T02:55:29.120Z</updated>
    
    <content type="html"><![CDATA[<p>之前开会讨论，遇到一个需要决策的问题，有同事在回答问题的基础上，比较详细的给出了自己的思考过程。觉得很有意思。我之前的意识层面，也只是认识到决策时对成本和价值的考量，随便找一本书读一读，再延伸思考一下。</p><span id="more"></span><p>书籍信息</p><blockquote><p>决策思维:人人必备的决策口袋书:升级典藏版&#x2F;王嘉陵著.—北京: 东方出版社，2018.11</p></blockquote><h2 id="序和前言"><a href="#序和前言" class="headerlink" title="序和前言"></a>序和前言</h2><blockquote><p>做出正确的决策就是要有效地分配有限的资源以达到目标。</p></blockquote><p>比我之前的理解更完备。成本–<code>有限的资源</code>，价值–<code>目标</code>，过程中还要进行<code>有效地分配</code>。</p><p>另外一个点，就是要严谨，要认清楚一些概念。这一点，在个人思考的过程中可能会变得愈发松散，而以文字的形式输出的过程中，却需要更加的严谨。比如，粗略的认知下，决策就是我认为的，成本和价值的平衡。但是决策其实更多的还是一个过程，这个过程要实现有效地分配，是要去实现平衡。</p><blockquote><p>制定了一个系统化的方案，GPA。</p><ul><li>G (Goal) 目标：确立一个明确、共享的目标；</li><li>P (Priority) 优先级：明确不同任务的轻重缓急;</li><li>A (Alternatives) 可选方案：制作许多可选方案，选用最好的方案去达到目标。</li></ul></blockquote><p>这三个我目前最擅长的，就是 A，执行可选的方案，选用其中最好的方案去达成目标。针对目标和优先级，最不擅长，比如说每年年初的 OKR 讨论和个人事务的四象限管理中。</p><p>&#x2F;&#x2F; todo more</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前开会讨论，遇到一个需要决策的问题，有同事在回答问题的基础上，比较详细的给出了自己的思考过程。觉得很有意思。我之前的意识层面，也只是认识到决策时对成本和价值的考量，随便找一本书读一读，再延伸思考一下。&lt;/p&gt;</summary>
    
    
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>从最简单的规则开始设计</title>
    <link href="https://notes.yaohwu.xyz/2021/12/15/the-easiest-way-to-design-code/"/>
    <id>https://notes.yaohwu.xyz/2021/12/15/the-easiest-way-to-design-code/</id>
    <published>2021-12-15T12:46:25.000Z</published>
    <updated>2022-04-06T04:18:19.199Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章大致讲一些自己对于代码设计的理解，总结一些经验做一个小组的分享。</p><span id="more"></span><h2 id="导引"><a href="#导引" class="headerlink" title="导引"></a>导引</h2><p>为什么从最简单的规则开始呢？</p><p>因为其实我是在代码设计方面没有特别深入的研究，单纯的拿《 head first 设计模式》中的案例来充当分享内容有点不妥，我自己最近也还在不断学习。</p><p>另外就是，正如书中所说：</p><blockquote><p>使用模式最好的方式是：“把模式装进脑子里，然后在你的设计和已有的应用中，寻找何处可以使用它们。”以往是代码复用，现在是经验复用。</p></blockquote><h3 id="如何把模式装到脑子里？"><a href="#如何把模式装到脑子里？" class="headerlink" title="如何把模式装到脑子里？"></a>如何把模式装到脑子里？</h3><p>可以通过看书来达成。最好还是看 《Head First 设计模式》，不要从网上看现成的文档，不要死记硬背。</p><ol><li><p>书的组织形式很好</p><ol><li>针对设计模式的应用场景进行分类，从对象，到装饰，到松耦合 OO，到封装，到适配和外观，到集合，到状态控制，到访问控制，有一整个的故事线，很有意思。</li><li>从简单的例子，到多模式的组合进阶使用，由易到难，由 demo 到生产；</li></ol><p><img src="https://cdn.jsdelivr.net/gh/yaohwu/link-image/static/F97LMr.png" alt="head first 设计模式 java 实现"></p></li><li><p>书的讲述形式很好</p><ol><li><p>不断的 Q&amp;A，不断的比较，容易引发自己的思考，印象也就更深刻；</p></li><li><p>你会发现，即使同一个模式，在不同场景下也是有不同的使用方案的，甚至这些方案在某些情况下看起来是违背了一些总结出来的原则，比如“优先使用组合而不是继承”，举个例子<a href="https://notes.yaohwu.xyz/2019/09/25/software-design/#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-Adapter-Pattern">适配器模式</a>；如果没有这样的思考，很容易对某一个模式产生偏见和错误理解。<br><img src="https://cdn.jsdelivr.net/gh/yaohwu/link-image/static/OoZCjB.png" alt="两种适配器的思辨"></p></li></ol></li></ol><h3 id="在你的设计和已有的应用中寻找他们"><a href="#在你的设计和已有的应用中寻找他们" class="headerlink" title="在你的设计和已有的应用中寻找他们"></a>在你的设计和已有的应用中寻找他们</h3><p>我也没有再花时间在我们的业务代码中找到具体的案例。</p><ol><li>我也是到分享的时候才发现，自己其实没有特别深入的学习过，脑海里一下子过不来这些东西；</li><li>时间的问题；</li><li>也觉得没有必要，自己去寻找，切身体会才是最好的。我分享的案例，只是我个人站在当初需求背景下的设计，而设计的好坏和需求又相关，在不同背景下的思考见仁见智。</li></ol><h2 id="总结经验"><a href="#总结经验" class="headerlink" title="总结经验"></a>总结经验</h2><p>既然上述两部分，都有更好的方案，那我就只能总结一下我个人最简单的经验。从比较务实的角度出发，将上层的理论交给更专业的方案去做。</p><p>我有哪些经验呢？毕竟我也是菜鸡，</p><p>所以我的经验也都比较简单，所以，还是回到题目，从最简单的规则开始，看看代码设计。</p><h3 id="减少重复代码"><a href="#减少重复代码" class="headerlink" title="减少重复代码"></a>减少重复代码</h3><p>这个可以说是最简单的规则了，没有之一。</p><p>毕竟，没有设计模式之前，至少也在强调，要实现代码复用。</p><blockquote><p>以往是代码复用，现在是经验复用。</p></blockquote><p>出现了大量的重复代码，那就不能实现代码复用，维护起来就得到处改。</p><p>重复的代码分类：</p><ul><li>方法出现重复的实现</li></ul><p>这个其实很容易理解，一个实现里面或者几个实现中，总是出现同样的方法块，idea 甚至都会帮助你识别出来。</p><p>比如我们业务中的统计逻辑，有好几处都要进行对模板信息的统计，但是是因为不同时期的功能，抄来抄去，没有再去整理，出现了大量的重复代码，维护起来，要改都得改。</p><p><img src="https://cdn.jsdelivr.net/gh/yaohwu/link-image/static/6NkWaT.png" alt="重复代码"></p><p>这些重复的逻辑甚至都出现在同样的方法中，几百行的方法，随着迭代越来越多，不断追加，没有时间去重构来减少重复代码。</p><ul><li>某个接口大量的实现类</li></ul><p>重复的方法块出现，肯定是封装出现了问题。还有一类重复，就是出现了大量的实现类。还拿埋点逻辑来说，<code>切入点的选择和切入的实现</code> 这个接口出现了大量的实现。</p><p><img src="https://cdn.jsdelivr.net/gh/yaohwu/link-image/static/iIDlKN.png" alt="大量的接口实现"></p><p>这当然也是一个设计上的问题。大量的实现类反映接口在易用性和抽象上的弊端。想要实现新的切入点的成本高昂。</p><ul><li>解决方案</li></ul><p>我们需要重新来设计，以实现减少重复代码的目的。</p><p>方法块的重复，在不同的场景下有多种选择。</p><ol><li>至少可以抽成公共的静态方法，带来的是稍微好维护；</li><li>也可以简单地进行抽象，使用继承，使用模板方法来处理；</li><li>也可以完全推倒原本的设计，实现一个针对模板的 parser，使用多个 parser 的组合来实现模板的读取和信息收集，对于其中的特殊的 parser 甚至还可以额外的抽象，比如针对控件列表的过滤，有些 parser 需要统计控件类型，有些 parser 需要统计个数，要让彼此独立却又在同一个便利中完成，那么就需要一个额外的抽象。</li><li>也可以 2 和 3 结合起来实现。</li></ol><p>接口大量的实现类的出现，要减轻这样的重复工作，就要抽象出一个更加合理的基本实现类，将原本的实现类变成一个个基本实现类的实例。</p><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p><strong>进行抽象的时候，要先有具象。</strong></p><p>这个具象不一定要已经有了实现，而是至少在你思考的过程中已经出现了的。</p><p>真正在处理业务的时候，可不像 demo 中那么简单。</p><blockquote><p>一个苹果，一个梨，那么自然会想到水果。</p></blockquote><p>要思考自身的业务分为哪几部分、哪些是可以归结到一个合理的结构上的。</p><p>基于不同的业务场合得到的抽象肯定也是完全不同的。</p><p>一个苹果一个梨，可能得到的是：</p><blockquote><p>一种植物。</p></blockquote><p>也可能是</p><blockquote><p>一种拥有外皮，可以吃的，长在对应果树上的东西。</p></blockquote><p>要结合具体的业务场景，找到最本质的部分，舍弃不关注的部分，最终得到一个抽象的结果。</p><h3 id="扩展性思考"><a href="#扩展性思考" class="headerlink" title="扩展性思考"></a>扩展性思考</h3><p>分层次的来思考扩展。</p><ul><li>有扩展性的必要么？</li></ul><p>要结合对应的业务场景来思考。</p><p>通常来说，涉及一个独立模块的功能，肯定是要考虑扩展性的。</p><p>但一个模块中的原本就具有可扩展性的一个扩展实现，就不需要考虑那么多，容易造成过度设计。</p><ul><li>有热替换的必要么？能不能实现热替换？</li></ul><p>要以松耦合的方式来实现。要依赖倒置，是不是要引入工厂方法，至少要有一个管理类来实现更新。</p><ul><li>能不能实现改动替换？改动替换时需要改哪些东西？</li></ul><p>改动替换时，是重新实现一个子类，还是针对已有的进行装饰，还是弄一个适配器。</p><p>这些在需要扩展的设计场景下要尽可能的思考到。让后续的扩展改动最小。</p><h3 id="使用约定减少特定"><a href="#使用约定减少特定" class="headerlink" title="使用约定减少特定"></a>使用约定减少特定</h3><p>一些设计模式是有固定使用场景的。不要在这些固定的使用场景下搞特定的设计。</p><p>比如 单例模式，虽然单例模式的写法很多，各种懒汉饿汉、双检索、枚举，但是他们对应的利弊和使用的场景一定要搞清楚。</p><p>还有一些其他好的代码方面的建议也是类似的。</p><p>比如针对 bean 的处理，getter setter 方法，开放的无参的构造器等等。</p><p>用于数据网络传输的 bean 和代码调用间的 bean 中间做一层转换，减少改动影响的范围。</p><p>比如，针对实例化时参数特别多的类，比如各种 bean，使用 builder 加上链式调用的方式来完成。</p><p><strong>固定的场景，选择固定的模式，使用固定的原则。</strong></p><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>合理使用泛型，让编译器帮助你发现问题。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>借助单元测试来设计，朝着让单元测试更容易写的方向优化设计。</p><p>得到一个合理的抽象，合理的模块化拆分。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>与其说我是来分享的，不如说我是来劝学的。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章大致讲一些自己对于代码设计的理解，总结一些经验做一个小组的分享。&lt;/p&gt;</summary>
    
    
    
    
    <category term="design pattern" scheme="https://notes.yaohwu.xyz/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>啥是云服务</title>
    <link href="https://notes.yaohwu.xyz/2021/12/05/cloud-topic/"/>
    <id>https://notes.yaohwu.xyz/2021/12/05/cloud-topic/</id>
    <published>2021-12-05T08:30:00.000Z</published>
    <updated>2021-12-06T07:25:05.908Z</updated>
    
    <content type="html"><![CDATA[<p>本意是希望了解一下什么是云原生（CloudNative），但是发现相关的名词解释很多。</p><p>就顺带整理分享下，都是互联网老词了，老词新回顾，带领大家再冲冲浪。</p><span id="more"></span><p>本意是希望了解一下什么是云原生（CloudNative），但是发现相关的名词解释很多。</p><p>就顺带整理分享下，都是互联网老词了，老词新回顾，带领大家再冲冲浪。也确实是冲浪，大部分是 redhat 官网的摘录。</p><h2 id="云计算（Cloud-Computing）"><a href="#云计算（Cloud-Computing）" class="headerlink" title="云计算（Cloud Computing）"></a>云计算（Cloud Computing）</h2><p>在了解什么是云服务之前，肯定要了解一个更老的概念——云计算。那么什么是云计算呢？</p><h3 id="云计算定义"><a href="#云计算定义" class="headerlink" title="云计算定义"></a>云计算定义</h3><p>一种能够跨网络、按需提供基础架构、服务、平台和应用的交付方式，正在快速取代原本通过硬布线连接进行资源共享的方式。</p><p>云计算是指在云中运行工作负载，而云是一种能够抽象、汇集和共享整个网络中的可扩展资源的 IT 环境。云计算和云本身都不属于技术的范畴。</p><ul><li>云计算是指在云中运行工作负载的功能。</li><li>而云是一种环境，是运行应用的地方。</li><li>技术则是指用于构建和使用云的软件和硬件。</li></ul><h3 id="云计算分类"><a href="#云计算分类" class="headerlink" title="云计算分类"></a>云计算分类</h3><p>以往人们很容易通过位置和所有权来界定公共云、私有云、混合云和多云之间的差异。</p><p>但如今已不再那么简单。所以，我们在尽全力定义主要云类型的同时，仍着眼于未来——因为了解过去的情况不一定就知道将来该如何使用云。</p><p>按照位置和所有权，我们可以这样划分云：</p><table><thead><tr><th></th><th>公共云（公有云）</th><th>私有云</th><th>混合云</th><th>多云（Multi-Cloud）</th></tr></thead><tbody><tr><td>定义</td><td>一种利用非最终用户所有的资源创建的云环境，可重新分发给其他租户。</td><td>可广义地定义为：一种专为最终用户而创建，而且通常位于用户的防火墙内（有时也是内部部署）的云环境。</td><td>一种具有一定程度的工作负载可移植性以及编排和管理能力的多云环境。</td><td>一个含有多个云环境（公共云或私有云）的 IT 系统，云与云之间可能联网也可能不联网。</td></tr></tbody></table><h4 id="公有云"><a href="#公有云" class="headerlink" title="公有云"></a>公有云</h4><p>一个虚拟资源池，可自动部署并通过自助服务界面在多个客户端间进行分配，其中的虚拟资源来自归第三方公司所有和管理的硬件设备。当工作负载出现意外需求波动时，可直接通过公共云进行横向扩展。</p><p>公共云通常不会作为独立的基础架构解决方案来部署，而是被作为异构混合环境的一部分部署，这样即可以提高安全性和性能，降低成本，还可以改进基础架构、服务和应用的可用性。</p><h5 id="公有云面对的需求"><a href="#公有云面对的需求" class="headerlink" title="公有云面对的需求"></a>公有云面对的需求</h5><ol><li>资源分配，由第三方提供服务，在租户见共享；</li><li>使用协议，随时可用，不用就停；</li><li>管理，提供商协助维护基础硬件、为网络提供支持、管理虚拟化软件；</li></ol><p>综合下来，就是降低成本、提高可用；</p><h4 id="私有云"><a href="#私有云" class="headerlink" title="私有云"></a>私有云</h4><p>一种专为最终用户而创建，而且通常位于用户的防火墙内的云环境。尽管传统上私有云在内部运行，但现在许多企业构建的私有云位于供应商租赁的外部数据中心内。如果底层 IT 基础架构归某个拥有完全独立访问权限的客户专有，那这种云就是私有云。</p><h5 id="私有云面对的需求"><a href="#私有云面对的需求" class="headerlink" title="私有云面对的需求"></a>私有云面对的需求</h5><ol><li>出于安全、加密、权限等等限制导致不能使用公有云；比如银行、金融服务等行业；</li></ol><h4 id="混合云"><a href="#混合云" class="headerlink" title="混合云"></a>混合云</h4><p>现在的云类型过于复杂，位置和所有权比较抽象；</p><p>所以按照功能来划分：</p><ul><li>通过网络连接多台计算机。</li><li>整合 IT 资源。</li><li>横向扩展并快速置备新资源。</li><li>能够在不同环境间移动工作负载。</li><li>包含单个统一的管理工具。</li><li>利用自动化对流程进行编排。</li></ul><h4 id="多云"><a href="#多云" class="headerlink" title="多云"></a>多云</h4><p>多云是指在多个供应商上部署同一类云方案（公共云或私有云）。混合云是指通过集成或编排组合多种云部署类型（公共云或私有云）。</p><h5 id="多云面对的需求"><a href="#多云面对的需求" class="headerlink" title="多云面对的需求"></a>多云面对的需求</h5><ol><li><a href="https://en.wikipedia.org/wiki/Shadow_IT">影子 IT</a>，在大规模线上应用之外的云，比如，在我们的 CRM 系统之外，有另外的小组新搞了个 CRM，希望解决性能等问题，那么这套单独部署的未来可能会替代现有 CRM 的系统部署的环境，就可以叫做影子 IT;</li><li>灵活性，选择不同的价格、不同的性能来部署同一应用，比如 swift 历史 2 年以上的数据，就选一个容量大但是读写慢的机器存储，近三月的就选择容量小但是读写快的机器部署；</li><li>邻近，区域的距离或者法律法规限制；比如国内 swift 和海外 swift；</li><li>故障切换；</li></ol><h2 id="云服务"><a href="#云服务" class="headerlink" title="云服务"></a>云服务</h2><p>了解了云计算之后，我们就可以来看云服务了。</p><h3 id="云服务定义"><a href="#云服务定义" class="headerlink" title="云服务定义"></a>云服务定义</h3><p>很显然，云服务就是利用云计算的交付方式，来通过互联网提供给用户的服务。暨指由第三方提供商托管的基础架构、平台或软件，可通过互联网提供给用户。</p><h3 id="服务模式"><a href="#服务模式" class="headerlink" title="服务模式"></a>服务模式</h3><p>凡是用户无需下载其他软件而是直接通过互联网就能访问的所有基础架构、平台、软件或技术都可以视为云计算服务，包括以下即服务类解决方案。</p><table><thead><tr><th>IaaS</th><th>CaaS</th><th>PaaS</th><th>SaaS</th><th>FaaS</th></tr></thead><tbody><tr><td>基础架构即服务（IaaS）为用户提供计算、网络和存储资源。</td><td>容器即服务（CaaS）是一种云服务计算的模型，它允许用户使用内部数据中心或云，通过基于容器的抽象来部署和管理应用。</td><td>平台即服务（PaaS）为用户提供一个可运行应用的平台，以及运行所需的所有 IT 基础架构。</td><td>软件即服务（SaaS）为用户提供必备的云应用、应用运行平台以及平台的底层基础架构。</td><td>功能即服务（FaaS）是一种事件驱动型执行模型，它允许开发人员以功能的形式来构建、运行和管理应用包，无需维护基础架构。</td></tr></tbody></table><p>各服务维护范围，除去 FaaS。</p><table><thead><tr><th>On-site</th><th>IaaS</th><th>PaaS</th><th>SaaS</th></tr></thead><tbody><tr><td><strong>Applications</strong></td><td><strong>Applications</strong></td><td><strong>Applications</strong></td><td>Applications</td></tr><tr><td><strong>Data</strong></td><td><strong>Data</strong></td><td><strong>Data</strong></td><td>Data</td></tr><tr><td><strong>Runtime</strong></td><td><strong>Runtime</strong></td><td>Runtime</td><td>Runtime</td></tr><tr><td><strong>Middleware</strong></td><td><strong>Middleware</strong></td><td>Middleware</td><td>Middleware</td></tr><tr><td><strong>O&#x2F;S</strong></td><td><strong>O&#x2F;S</strong></td><td>O&#x2F;S</td><td>O&#x2F;S</td></tr><tr><td><strong>Virtualization</strong></td><td>Virtualization</td><td>Virtualization</td><td>Virtualization</td></tr><tr><td><strong>Servers</strong></td><td>Servers</td><td>Servers</td><td>Servers</td></tr><tr><td><strong>Storage</strong></td><td>Storage</td><td>Storage</td><td>Storage</td></tr><tr><td><strong>Networking</strong></td><td>Networking</td><td>Networking</td><td>Networking</td></tr></tbody></table><p><strong>加粗的内容</strong>是你需要管理和维护的。</p><h4 id="CaaS"><a href="#CaaS" class="headerlink" title="CaaS"></a>CaaS</h4><p>在云服务范畴内，CaaS 被认为是基础架构即服务（IaaS）的一种子集，介于 IaaS 和平台即服务（PaaS）之间。</p><p>CaaS 的基本资源为容器，它是云原生应用和微服务的常见部署机制。此外，CaaS 还可以提高环境之间的可移植性，无论是混合环境还是多云环境。</p><h4 id="FaaS"><a href="#FaaS" class="headerlink" title="FaaS"></a>FaaS</h4><p>一种在无状态容器中运行的事件驱动型计算执行模型，这些功能将利用服务来管理服务器端逻辑和状态。</p><p>它允许开发人员以功能的形式来构建、运行和管理这些应用包，无需维护自己的基础架构。</p><h3 id="云计算服务的原理"><a href="#云计算服务的原理" class="headerlink" title="云计算服务的原理"></a>云计算服务的原理</h3><p>我们在分类的时候 IaaS 提供的是基础架构，PaaS 提供的是平台，SaaS 提供的是软件。</p><p>那么这三种分别是什么？云计算是如何发布这三种服务的？</p><h4 id="云基础架构"><a href="#云基础架构" class="headerlink" title="云基础架构"></a>云基础架构</h4><p>将计算功能和硬件组件分离开。例如</p><ol><li>处理能力和 CPU 硬件分离开；</li><li>内存和 RAM 硬件分离开；</li><li>图形处理能力和 GPU 硬件分离开；</li><li>数据存储能力和磁盘等硬件分离开；</li></ol><p>怎么理解这个分离呢？举个例子，假设我只有一个 100 算力的 CPU，但是我作为云服务提供的时候，可以将这个 CPU 的 100 算力分开售卖，以满足不同客户群的使用需求，最终形成的售卖方案可能是：</p><ol><li>一个 50 算力的 SP；</li><li>三个 10 算力的 SSR；</li><li>五个 2 算力的 SR；</li><li>一百个 0.1 算力的 R；</li></ol><p>怎么做到这个呢？通过虚拟化来实现。在一个 100 算力的 CPU 上，分别虚拟出来上述的内容。CPU 如此，其他硬件资源也是类似的。</p><h4 id="云服务平台"><a href="#云服务平台" class="headerlink" title="云服务平台"></a>云服务平台</h4><p>云服务平台，就是在上述云基础架构的基础上，同时提供一套可以直接运行某种应用的环境。</p><p>实现云服务平台，除了上述的虚拟化技术之外，还要要求容器化、编排、API、路由、安全、管理和自动化等技术。</p><p>云平台是一种 PaaS。如果支持 PaaS 的基础架构组件具有高度可扩展性和可共享性，则可以将其视为云。PaaS 云的最佳例证包括公共云和托管私有云。</p><h4 id="云软件"><a href="#云软件" class="headerlink" title="云软件"></a>云软件</h4><p>提供商可以提供并最终被广泛接受的云服务是一个完整的 Web 应用，也称云软件或 SaaS。这需要最大规模的开发投资，因为云提供商实际上是在为客户提供在线应用。比如我们公司的简道云、九数云等。</p><p>作为云软件，很容易和传统软件混淆，或者基于不同的 client 形式难以区分。无论是通过 web 还是通过其他的桌面客户端，只要是需要通过互联网与云服务提供商提供的软件服务器进行通讯的，都是云软件。</p><p>云软件可以通过云原生方法提供，云原生是一种结合了小型、独立和松散耦合的微服务的应用架构。多个微服务可以打包至由容器编排引擎（如 Kubernetes ）管理的单个 Linux 容器中。最终产品是一个云应用，可通过微服务进行优化，而不会对整个应用中的其他微服务造成影响。</p><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2><p>好家伙，终于到云原生了。</p><p>就如上文所说，云原生是一种方法，一种结合了小型、独立和松散耦合的微服务的应用架构。</p><p>云原生包含四个要点。</p><h3 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h3><p>从字面上来看，“DevOps”一词是由英文 Development（开发）和 Operations （运维）组合而成。</p><p>DevOps 强调通过一系列手段来实现既快又稳的工作流程，使每个想法（比如一个新的软件功能，一个功能增强请求或者一个 bug 修复）在从开发到生产环境部署的整个流程中，都能不断地为用户带来价值。这种方式需要开发团队和运维团队密切交流、高效协作并且彼此体谅。此外，DevOps 还要能够方便扩展，灵活部署。有了 DevOps，需求最迫切的工作就能通过自助服务和自动化得到解决；通常在标准开发环境编写代码的开发人员也可与 IT 运维人员紧密合作，加速软件的构建、测试和发布，同时保障开发成果的稳定可靠。</p><p>当然，这意味着更改代码会更频繁，基础架构的使用也会更灵活。所以传统的管理策略无法满足这种需求。</p><p><strong>它是一种文化，也是一个流程，更是一组的平台和工具。</strong></p><h3 id="微服务（Microservices）"><a href="#微服务（Microservices）" class="headerlink" title="微服务（Microservices）"></a>微服务（Microservices）</h3><p>微服务既是一种架构，也是构建软件的方法。在微服务中，应用被拆分成最小的组件，彼此独立。不同于将所有组件内置于一个架构中的传统单体式应用构建方法，在微服务架构中，所有部分相互独立，通过合作来完成同一个任务。其中的每一个组件或流程都是一个微服务。这种软件开发方法强调细粒度、轻量化，力求在多个应用中共享相似的流程。它是针对云原生模型优化应用开发的主要组件。</p><p>微服务架构有助于更快地交付高质量的软件。使用微服务有助实现这一点，但也需要注意一些细节。仅仅将应用拆分成微服务是不够的，您还必须对微服务进行管理和编排，处理微服务创建和修改的数据。</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>应用编程接口（API）由一组用于集成应用软件和服务的工具、定义和协议组合而成。有了这类接口，您无需不断构建新的连接基础架构，就能让自己的产品和服务与其他产品和服务进行通信。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>对应用及其整个运行时环境（包括全部所需文件）一起进行打包或隔离。从而让您可以在不同环境（如开发、测试和生产等环境）之间轻松迁移应用，同时还可保留应用的全部功能。</p><p>容器使开发团队可以全心投入应用开发，而运维团队则专注于基础架构维护。容器编排是管理这些部署的方式。</p><p>Kubernetes 是一种可自动实施 Linux 容器操作的开源平台。它可以省去应用容器化过程的许多手动部署和扩展操作。Kubernetes 可提供一个便捷有效的平台，可以在物理机或虚拟机集群上调用和运行容器。Kubernetes 架构将集群分为不同的组件，这些组件要协同工作来维护集群的预期状态。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>简而言之，云原生，就是使用 DevOps 的方法搭建出一个完整的云端应用，这个应用由若干个运行在容器内部的微服务组成，它们之间借助 API 进行通信。</p><h3 id="How-to-Make-Change"><a href="#How-to-Make-Change" class="headerlink" title="How to Make Change"></a>How to Make Change</h3><p>首先从能够开展协作的自动化流程入手。也就是说，通过 DevOps 使开发和运维协同合作，让朝着共同目标努力并定期进行反馈。</p><p>容器提供理想的应用部署单元和独立的执行环境，为这些实践提供支持。凭借 DevOps 和容器，能更加轻松地以松散耦合服务的形式（如微服务）来发布和更新应用，而不是等待大型版本的发布。</p><p>云原生开发注重架构的模块性、松散耦合及其服务的独立性。每个微服务实现一种业务能力，在自己的流程中运行，并通过应用编程接口（API）或消息传递进行通信。该通信可通过服务层进行管理。</p><p>但是，作为云原生应用的一部分，<strong>无需始终从微服务开始以加速应用交付</strong>。仍然可以使用基于服务的实用架构来优化其传统应用。持续整合和持续部署（CI&#x2F;CD）等 DevOps 工作流以及全自动部署操作为该优化提供支持。</p><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><p>既然方法思想都变了，那么对应的技术栈层面很显然也要跟随改变。</p><p>历史就是这样演变的。我们从传统的 tomcat 开发到 spring boot，再到云端的 spring cloud。</p><p>云原生开发当然也会有专门的框架和解决方案。</p><p>之前提到的 <a href="https://www.redhat.com/zh/topics/cloud-native-apps/what-is-quarkus">quarkus</a> 就是其中一种。</p><p>不过由于时间的关系（我懒，进一步的内容放在下次的分享吧。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><a href="https://www.redhat.com/zh/topics/cloud">red hat cloud topic</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本意是希望了解一下什么是云原生（CloudNative），但是发现相关的名词解释很多。&lt;/p&gt;
&lt;p&gt;就顺带整理分享下，都是互联网老词了，老词新回顾，带领大家再冲冲浪。&lt;/p&gt;</summary>
    
    
    
    
    <category term="cloud" scheme="https://notes.yaohwu.xyz/tags/cloud/"/>
    
  </entry>
  
  <entry>
    <title>《原则：生活与工作》 读书笔记</title>
    <link href="https://notes.yaohwu.xyz/2021/11/21/principles-life-and-work-reading-notes/"/>
    <id>https://notes.yaohwu.xyz/2021/11/21/principles-life-and-work-reading-notes/</id>
    <published>2021-11-21T13:19:53.000Z</published>
    <updated>2021-11-28T13:53:14.574Z</updated>
    
    <content type="html"><![CDATA[<p>这是一份从微信读书导出的关于《原则：生活与工作》的读书笔记，还有待再整理。</p><span id="more"></span><p>◆ 2 跨越门槛 （1967—1979年）</p><p>认清相关事情的发展之后，一切看起来就符合逻辑了。</p><blockquote><blockquote><p>符合逻辑</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>几乎所有事情都以符合逻辑的因果关系不断发生过</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>准确地判断出哪些事情正在重演，并理解背后的因果关系</p></blockquote></blockquote><p>skr</p><blockquote><blockquote><p>来自西班牙，名叫芭芭拉</p></blockquote></blockquote><p>了解你的领域</p><blockquote><blockquote><p>我了解几乎一切能想到的、与这两个市场有关的事情</p></blockquote></blockquote><p>自信点把像去掉</p><blockquote><blockquote><p>整个过程像是一部有着符合逻辑的因果关系的美丽机器。通过理解这些关系，我就能得出用来建立模型的决策规则（或者说原则）。</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>把复杂的系统设想为机器，发现其内部的因果关系，把处理这些因果关系的原则写下来，将其输入计算机，从而让计算机为我“决策”，所有这些后来都成了标准做法。</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>总是存在会给你造成重大损失的风险</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>假设自己没有看到全部</p></blockquote></blockquote><p>很强</p><blockquote><blockquote><p>我给儿子起名“德温”，而“德温”是人类所知的最早的牛种之一，也是最早输入美国的牛种之一，并以繁殖率高著称</p></blockquote></blockquote><p>◆ 3 我的低谷 （1979—1982年）</p><p>&lt;&gt;</p><blockquote><blockquote><p>在每个投资者的职业生涯中，都有焦虑的时刻，你对未来的期待与真正发生的情况不符，你不知道自己面临的是巨大的机会还是灾难性的错误。</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>时机就是一切</p></blockquote></blockquote><p>冷静，相信自己总有还未考虑到的场景</p><blockquote><blockquote><p>我离谱地过度自信，并放纵自己被情绪左右</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>研究历史的价值</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>总结出经过仔细验证的永恒和普适的决策原则</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>时机</p></blockquote></blockquote><p>一个开放成功的团队氛围</p><blockquote><blockquote><p>一个创意择优的机构，鼓励经过深思熟虑的意见不一致，根据不同人的相对长处分析和权衡他们的观点。</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>使人们相互对立的观点公开化，并对其进行分析，让我对人们的思考方式有了很多的了解。我逐渐发现，人们的最大缺点与其最大优点互为正反面。例如，一些人倾向于过度冒险，而其他人的风险规避性过强；一些人过度关注细节，而其他人的思维过于宏观。大多数人都是在某个方面过度，而在另一方面不足。通常，当我们遵循自己的自然秉性做事时，我们可能考虑不到自身的弱点，这将导致我们走向失败。最重要的是失败之后怎么做。成功的人改变他们的做法，这使他们能够继续利用自己的优势，弥补自身的不足，而不成功的人不会这样做。在后文中，我将描述改变的具体策略，但在这里需要注意的重要一点是，只有当你能承认甚至接受自身的弱点时，你才能做出对自身有益的改变。</p></blockquote></blockquote><p>◆ 4 我的试炼之路 （1983—1994年）</p><blockquote><blockquote><p>靠水晶球谋生的人注定要吃碎在地上的玻璃</p></blockquote></blockquote><p>没有快速验证的环境就从历史数据中想办法快速验证，现在的ML就是在这样的大背景下开展的。</p><blockquote><blockquote><p>如果我把这些标准转化成公式（现在更时髦的叫法是“算法”），然后用这些公式计算历史数据，我就能检测，假如把我的这些公式运用到历史交易中，效果会怎么样</p></blockquote></blockquote><p>人类早期的ML模型训练和参数优化</p><blockquote><blockquote><p>我与计算机互相帮助</p></blockquote></blockquote><p>德州朴克每把都看牌，但是只有自己赢面大的时候才额外加注（手动狗头</p><blockquote><blockquote><p>只对你有高度信心的投资对象进行冒险押注，并对这些对象进行充分的分散投资</p></blockquote></blockquote><p>很多人看到的是成熟和选择的重要性，但是这句话的前提是勤奋和有创造性的工作。</p><blockquote><blockquote><p>我了解到，如果你以勤奋和有创造性的方式工作，你几乎可以得到你想要的任何东西，但你不可能同时得到所有东西。成熟意味着你可以放弃一些好的选择，从而追求更好的选择。</p></blockquote></blockquote><p>苏州的丝巾吗？（</p><blockquote><blockquote><p>我还记得有一次，当时只有10岁左右的大儿子德温，在中国以每条1美元的价格购买了许多黑丝巾，然后在圣诞节前夕在一个购物中心以每条20美元的价格卖出。这仅仅是展现他商业天赋的最初迹象。</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>有意义的人际关系是指开放诚恳的关系，人们彼此坦诚相待。</p></blockquote></blockquote><p>这是一个独特的思维方式，因为大多数人遇到这种情况想到的是只有加重惩罚才会避免出现更多的问题。更重的惩罚意味着更少的错误，当错误不可避免，那么面对错误降低反应才会让错误提前暴露出来。这就是人性。</p><blockquote><blockquote><p>这是一个可怕的、代价高昂的失误，而我不能做出太激烈的反应，比如把罗斯炒了以儆效尤，告诉大家我们不能容忍错误。因为错误总是免不了的，所以这么做只会促使其他人隐藏错误，而这将导致更大、代价更高的错误。</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>管理工具在促使人们采用正确的行为方式方面发挥着重要作用</p></blockquote></blockquote><p>那以如何让其他人能够坦城地讲出各自的相处原则呢？自身坦诚肯定是第一位的。</p><blockquote><blockquote><p>人们应当把各自的相处原则说得极为清楚</p></blockquote></blockquote><p>我的相处原则是什么呢？我其实并不以高标准要求别人，我可以很耐心地和他人摆事实讲道理，但是一旦我发现对方难以认同我表述的观点，不按照我认为的正确的方案行事，而且不能给出我认可的理由或者一个更好的解决方案，那么我就会逐渐失去耐心，开始发火。</p><blockquote><blockquote><p>各自的相处原则</p></blockquote></blockquote><p>可以尝试在团队内部去做类似的事情</p><blockquote><blockquote><p>我们开始书面记录我们的原则，这种做法持续了几十年，最终形成了“工作原则”。这些原则既是我们一致同意的相处规范，也是我对我们如何处理不断出现的新情况的思考。因为大多数情况都是以略微不同的形式不断出现的，所以这些原则被持续改进</p></blockquote></blockquote><p>每个人对待共同的事情都要做到坦诚</p><blockquote><blockquote><p>把我们的真实想法摆在桌面上</p></blockquote></blockquote><p>要经过有效的沟通。</p><blockquote><blockquote><p>存在经过深思熟虑的分歧，但人们愿意在相互了解的过程中更改观点；</p></blockquote></blockquote><p>还是那句话：利用欲望让自己努力，控制欲望让自己快乐。</p><blockquote><blockquote><p>每个人的大脑都有两部分——层次较高的逻辑部分与层次较低的情绪部分。我称此为“两个你”。它们会争夺对于一个人的控制权。管理这一冲突的方式，是我们行为最重要的驱动因素。</p></blockquote></blockquote><p>&lt;&gt;</p><blockquote><blockquote><p>大脑的逻辑部分可以轻易理解了解自身弱点是一件好事（因为这是克服弱点的第一步），但大脑的情绪部分通常讨厌这么做。</p></blockquote></blockquote><p>◆ 5 终极恩惠 （1995—2010年）</p><p>为啥要强调年轻的程序员（</p><blockquote><blockquote><p>随着系统里的决策规则和数据变得越来越复杂，我们聘用了年轻的程序员，他们能更好地把指示转化为代码，</p></blockquote></blockquote><p>一个足够优秀的产品的起源可能只是一个不经意的想法</p><blockquote><blockquote><p>到20世纪90年代中期，我有了足够的钱为我的家庭设立一个信托，所以我开始思考，为了将财富传承给多代人，最好的资产配置组合应当是什么样子。</p></blockquote></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;这是一份从微信读书导出的关于《原则：生活与工作》的读书笔记，还有待再整理。&lt;/p&gt;</summary>
    
    
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>JDK 14 Features</title>
    <link href="https://notes.yaohwu.xyz/2020/03/16/jdk-14-features/"/>
    <id>https://notes.yaohwu.xyz/2020/03/16/jdk-14-features/</id>
    <published>2020-03-16T01:09:35.000Z</published>
    <updated>2021-05-14T11:14:42.733Z</updated>
    
    <content type="html"><![CDATA[<p>按照计划，明天（ 3 月 17 号） JDK 14 就要发布了，虽然距离真正使用还是比较远，但事先了解一下新特性还是比较好的，</p><span id="more"></span><p>按照计划，明天（ 3 月 17 号） JDK 14 就要发布了，虽然距离真正使用还是比较远，但事先了解一下新特性还是比较好的。</p><h2 id="JEP-305-Pattern-Matching-for-instanceof-Preview"><a href="#JEP-305-Pattern-Matching-for-instanceof-Preview" class="headerlink" title="JEP 305 Pattern Matching for instanceof (Preview)"></a>JEP 305 Pattern Matching for instanceof (Preview)</h2><p><a href="https://openjdk.java.net/jeps/305">JEP 305</a> 将会增强 instanceof 的模式匹配。<br>可以更简洁安全地表示对象类型的判断。</p><p>之前我们在代码中使用 instanceof:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 obj 是 String</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    <span class="comment">// 转换 obj 变成 String s</span></span><br><span class="line">    String s = (Sting) obj;</span><br><span class="line">    <span class="comment">// use s</span></span><br><span class="line">    s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现，上面的写法有三个步骤：</p><ol><li>判断类型；</li><li>强制类型转换；</li><li>使用转换后的类型；</li></ol><p>强制类型转换，由于不能确保先进行类型检查，所以是非常不安全的。<br>使用新的特性能更好的处理这样的问题，并且更简洁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试 obj 是 String 并转换为 s</span></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s) &#123;</span><br><span class="line">    <span class="comment">// use s</span></span><br><span class="line">    s.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将类型判断和类型转换放在一起，不再会出现遗漏等情况，更加安全，同时从语法上来看也更简洁。<br>需要注意的是，绑定变量 s 的范围由包含的表达式和语句的语义确定。</p><p>例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(obj <span class="keyword">instanceof</span> String s)) &#123;</span><br><span class="line">    <span class="comment">// no</span></span><br><span class="line">    .. s.contains(..) ..</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// yes</span></span><br><span class="line">    .. s.contains(..) ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s &amp;&amp; <span class="comment">/* yes */</span> s.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// yes</span></span><br><span class="line">    .. s.contains(..) ..</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (obj <span class="keyword">instanceof</span> String s || <span class="comment">/* no */</span> s.length() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// no</span></span><br><span class="line">    .. s.contains(..) ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有在表达式和语义都确认的情况下，s 才能被正确的使用。</p><p>这个特性能够帮助我们将代码变得更清晰：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// old</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString) &amp;&amp;</span><br><span class="line">        ((CaseInsensitiveString) o).s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (o <span class="keyword">instanceof</span> CaseInsensitiveString cis) &amp;&amp;</span><br><span class="line">        cis.s.equalsIgnoreCase(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JEP-343-Packaging-Tool-Incubator"><a href="#JEP-343-Packaging-Tool-Incubator" class="headerlink" title="JEP 343 Packaging Tool (Incubator)"></a>JEP 343 Packaging Tool (Incubator)</h2><p><a href="https://openjdk.java.net/jeps/343">JEP 343</a> 将提供一个打包独立 java 应用程序的 cli 工具 jpackage。支持使用 ToolProviderAPI 编程调用，不支持交叉编译，打包格式包括 Windows 上的 msi 与exe，macOS 上的 pkg 和 dmg，Linux 上的 deb 和 rpm。</p><h2 id="JEP-345-NUMA-Aware-Memory-Allocation-for-G1"><a href="#JEP-345-NUMA-Aware-Memory-Allocation-for-G1" class="headerlink" title="JEP 345 NUMA-Aware Memory Allocation for G1"></a>JEP 345 NUMA-Aware Memory Allocation for G1</h2><p>通过 实现 NUMA 感知内存分配，提供了 G1 在大型机器上的性能。</p><p>&#x2F;&#x2F;todo more</p><h2 id="JEP-349-JFR-Event-Streaming"><a href="#JEP-349-JFR-Event-Streaming" class="headerlink" title="JEP 349 JFR Event Streaming"></a>JEP 349 JFR Event Streaming</h2><p><a href="https://openjdk.java.net/jeps/349">JEP 349</a> Expose JDK Flight Recorder data for continuous monitoring.</p><p>&#x2F;&#x2F; todo more</p><h2 id="JEP-352-Non-Volatile-Mapped-Byte-Buffers"><a href="#JEP-352-Non-Volatile-Mapped-Byte-Buffers" class="headerlink" title="JEP 352 Non-Volatile Mapped Byte Buffers"></a>JEP 352 Non-Volatile Mapped Byte Buffers</h2><p><a href="https://openjdk.java.net/jeps/352">JEP 352</a> Add new JDK-specific file mapping modes so that the FileChannel API can be used to create MappedByteBuffer instances that refer to non-volatile memory.</p><p>&#x2F;&#x2F; todo more</p><h2 id="JEP-358-Helpful-NullPointerExceptions"><a href="#JEP-358-Helpful-NullPointerExceptions" class="headerlink" title="JEP 358 Helpful NullPointerExceptions"></a>JEP 358 Helpful NullPointerExceptions</h2><p><a href="https://openjdk.java.net/jeps/358">JEP 358</a> 通过精准描述哪个变量是 null 来提高 jvm 生成的 NPE 的可用性。</p><p>这可以说是一个非常好的特性了，在很多代码中，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.b.i = <span class="number">99</span>;</span><br><span class="line">a[i][j][<span class="number">3</span>] = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> i = a.get().pop().size();</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>等等这种类型的代码中，一旦其中出现 npe 是很难判断就是哪一个值是 null 的。</p><p>但是通过这个新特性，就能够提供更丰富的 null 信息：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cannot <span class="built_in">read</span> field <span class="string">&quot;c&quot;</span> because <span class="string">&quot;a.b&quot;</span> is null;</span><br><span class="line">Cannot load from object array because <span class="string">&quot;a[i][j]&quot;</span> is null</span><br><span class="line">Cannot invoke <span class="string">&quot;x.pop()&quot;</span> because the <span class="built_in">return</span> value of <span class="string">&quot;a.get()&quot;</span> is null</span><br></pre></td></tr></table></figure><p>等等；不仅能够精确识别 null，还能提供不能进一步操作的具体原因。对于分析日志定位问题非常有帮助。</p><p>要启用这个功能，需要添加 JVM 标识：</p><blockquote><p>-XX:+ShowCodeDetailsInExceptionMessages</p></blockquote><p>这个功能在未来可能会默认开启。<br>但是这个有一个风险就是，这个信息可能包含源代码中的变量名。暴露此信息可能被视为安全风险。</p><h2 id="more"><a href="#more" class="headerlink" title="more"></a>more</h2>]]></content>
    
    
    <summary type="html">&lt;p&gt;按照计划，明天（ 3 月 17 号） JDK 14 就要发布了，虽然距离真正使用还是比较远，但事先了解一下新特性还是比较好的，&lt;/p&gt;</summary>
    
    
    
    
    <category term="generic" scheme="https://notes.yaohwu.xyz/tags/generic/"/>
    
  </entry>
  
  <entry>
    <title>高效能人士的七个习惯阅读笔记</title>
    <link href="https://notes.yaohwu.xyz/2019/10/27/read-The-Habits-of-Highly-Effective-People/"/>
    <id>https://notes.yaohwu.xyz/2019/10/27/read-The-Habits-of-Highly-Effective-People/</id>
    <published>2019-10-27T08:19:53.000Z</published>
    <updated>2021-05-14T11:14:42.735Z</updated>
    
    <content type="html"><![CDATA[<p>在读书计划选书的时候，我觉得我有必要提升一下自我管理的一些能力，因此选择了这本书。<br>这些是我读书的收获。</p><span id="more"></span><p>但是大致翻阅之后，书中的一个思想影响了我：</p><p><code>建议各位不要对本书等闲视之，大略读过便束之高阁。当然，你不妨从头到尾浏览一遍， 以了解全书梗概。不过我希望在你改进自我的成长过程中，本书能时时与你为伴。本书在编排方式上分 成几个循序渐进的章节，便于读者随时参阅并付诸行动。</code></p><p>作者说它不是一本一般的书，不能看完就丢弃，要时常与我为伴，还是循序渐进编排好的，让我随时参阅。这完全符合我对于<strong>工具书</strong>的定义。</p><p>之后我就尝试着我阅读工具书，甚至是阅读框架 guide 文档或者 api 文档的方式去阅读它。</p><p>我制定了一个阅读工具书的流程，按照这个流程来阅读：</p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>我目前遇到了什么问题，或者说我期望这次阅读能够帮我解决什么问题。</p><p>我这次的问题，就是选书时期望解决的，自我管理方面的，主要是时间管理以及效率的提升。</p><h2 id="自身的解决方案"><a href="#自身的解决方案" class="headerlink" title="自身的解决方案"></a>自身的解决方案</h2><p>针对我提出的问题，现在我有什么解决方案呢？</p><p>时间管理方面，就是自己排出一个优先级，之前其他人也分享了时间管理方法，重要紧急、不重要不紧急等等。但是我好像从中受益不多。一个是事情的划分不清晰，分不清楚；另外是，如何提升那些紧急但不重要的事情的处理效率，现在还没有系统的方法或者说理论。</p><h2 id="筛选阅读"><a href="#筛选阅读" class="headerlink" title="筛选阅读"></a>筛选阅读</h2><p>从头到位浏览了一遍后，我筛选出了几个章节模块，从他们的标题或者概览中，我猜测有解决我问题的答案。<br>几个章节模块分别是：</p><ol><li>第一部分-重新探索自我-第二章：七个习惯概论</li><li>第二部分-个人领域的成功：从依赖到独立</li><li>第四部分-自我提升和完善-第十章-习惯七-不断更新</li></ol><h2 id="阅读"><a href="#阅读" class="headerlink" title="阅读"></a>阅读</h2><p>我来读……</p><h2 id="总结筛选阅读的收获"><a href="#总结筛选阅读的收获" class="headerlink" title="总结筛选阅读的收获"></a>总结筛选阅读的收获</h2><p>由于我是带着问题来读的，经过这样的筛选阅读，我可能找到了部分我问题的解决方案，也有可能收获一些其他知识。</p><h3 id="总结其他收获"><a href="#总结其他收获" class="headerlink" title="总结其他收获"></a>总结其他收获</h3><h4 id="了解了书名中的-7-个习惯以及人的成熟模型"><a href="#了解了书名中的-7-个习惯以及人的成熟模型" class="headerlink" title="了解了书名中的 7 个习惯以及人的成熟模型"></a>了解了书名中的 7 个习惯以及人的成熟模型</h4><p><img src="/resources/image/7.png" alt="7个习惯及成熟模型"></p><p>书里将习惯定义为“知识”、“技巧”与“意愿”相互交织的结果。<br>知识是理论范畴，指点“做什么”及“为何做”；技巧告诉“如何做”；意愿促使“想要做”。要养成一种习惯，三者缺一不可。</p><p>简单说，习惯是知道做什么、为何做以及如何做，并且想要做的这样一个行为。这才是一个习惯。</p><p>相对于我们日常生活中对于习惯的理解可以说相当拔高了。</p><p>我有聆听他人倾诉的习惯，需要我愿意聆听他人之外，还得知道如何聆听，而不是便听他说边玩手机。</p><p>七个习惯：</p><ol><li>积极主动，主动承担责任</li><li>以终为始，先定目标后行动</li><li>要事第一，总是按照事务重要性顺序安排生活并付诸实践</li><li>双赢思维，<del>就是我要赢两次</del>，基于双方的利益进行思考</li><li>知彼解己，先理解别人，再争取被人的理解</li><li>综合能效，寻找第三种更好的方案</li><li>不断更新，就是不断提升自己</li></ol><p>另外一个就是一个人的成熟模型。</p><p>这个很好理解，人从依赖别人，到独立，再到互相依赖。<br>可以那身边的例子作为一个对比：</p><ol><li>依赖别人，刚入职，啥都不懂，得各种看文档；自身重要性比较低，基本不重要；</li><li>独立，熟悉点了，bug 一来，谁都别管我，这个我知道怎么改并且知道怎么改得又快又好；自身开始变得重要；</li><li>互相依赖，更厉害了，你写了个新功能，都让你出个文档讲讲；自身变得较为重要；</li></ol><p>最后就是效能（产出&#x2F;产能 的平衡）</p><p>高效能人士的 7 个习惯，穿插在成熟模型中间，构成了本书的一个循序渐进的结构。</p><h4 id="四代时间管理的演进"><a href="#四代时间管理的演进" class="headerlink" title="四代时间管理的演进"></a>四代时间管理的演进</h4><p><code>如何分辨轻重缓急与培养组织能力，是时间管理的精髓。</code></p><ol><li>第一代理论着重利用便条与备忘录，在忙碌中调配时间与精力。</li><li>第二代理论强调行事历与日程表，反映出时间管理已注意到规划未来的重要。</li><li>第三代是目前正流行、讲求优先顺序的观念。也就是依据轻重缓急设定短、中、长期目标，再逐<br>日订定实现目标的计划，将有限的时间、精力加以分配，争取最高的效率。</li><li>第四代是主张关键不在于时间管理，而在于个人管理。与其着重于时间与事务的安排，不如<br>把重心放在维持产出与产能的平衡上。</li></ol><h3 id="问题的解决方案"><a href="#问题的解决方案" class="headerlink" title="问题的解决方案"></a>问题的解决方案</h3><h4 id="变被动为主动提升效率-积极主动"><a href="#变被动为主动提升效率-积极主动" class="headerlink" title="变被动为主动提升效率-积极主动"></a>变被动为主动提升效率-积极主动</h4><p>书中讲的，积极主动不仅是一个态度，更多的其实是一个责任感，是人的一种天性。<br>就像我之前在目标和维护拆分的时候说的，每一个研发其实都乐意去改自身改出来的 bug。这其实就是一种主动承担责任的天性。</p><p>但是问题在于当认为自身没有责任的时候怎么办。</p><p>我有时候就这样，这个 bug 一看 n 年前遗留的问题，完全不想改，不想深入挖掘，总是想让产品按照设计如此的方案退回。真的对这个问题没什么责任感。除非我愿意，否则没人能让我改这个 bug。</p><p>这时候怎么办？</p><ol><li><p>转换思维发现价值</p><ol><li>我该如何应对？如果这个 bug 就这样了，那我找到一种临时解决方案的话是不是就是有价值的？这样我是否愿意主动呢？至少提供个临时方案，说不定就能顺带针对 bug 去做分析？至少还能怼赢产品。改 bug 不乐意，怼产品呢？</li><li>自我意识检讨自身（自我催眠-我行我能我可以）；</li><li>我能不能找个理由或者找到问题的关键然后转给不乐意也得乐意的对应负责人？</li><li>我能不能从其他环节上减少这样的问题发生？</li><li>……</li></ol></li><li><p>实在没办法的就只能保持平静，将自己被动的情绪调整成对效率影响最低。</p></li></ol><h4 id="使命宣言-以终为始-自我领导"><a href="#使命宣言-以终为始-自我领导" class="headerlink" title="使命宣言-以终为始,自我领导"></a>使命宣言-以终为始,自我领导</h4><ol><li>给自己定一个使命宣言-每个客户 bug 三天内都至少跟进一次？以及任何你认为好的宣言，守时、亲和、详细的工作日志、广受好评的开放文档……</li><li>针对使命宣言付诸实践；</li><li>扮演法，将自己代入到生活中不同的角色中，培养个人使命的这个习惯；</li></ol><h4 id="时间管理-要事第一"><a href="#时间管理-要事第一" class="headerlink" title="时间管理-要事第一"></a>时间管理-要事第一</h4><p><img src="/resources/image/time-square.png" alt="时间管理矩阵"></p><p>这有什么特别的？大道理大家都知道，做得还是不好该怎么办？</p><p>是不是真的知道这些道理？</p><ol><li><p>认清事情的划分<br>第一类事务既紧迫又重要，需要立即处理，通常被称为“危机”或“问题”。<br>第二类事务包括建立人际关系、撰写使命宣言、<strong>规划长期目标、防患于未然</strong>等等。人人都知道这些事很重要，却因尚未迫在眉睫，反而避重就轻。<br>如果你过分注重第一类事务，那么它们的范围就会变得越来越大，最终占据你全部的时间和精力。<br>高效能人士的脑子里装的不是问题，而是机会。他们不会在各种各样的问题上浪费时间和精力，他们的思维定式是预防型的，总是能够做到防患于未然。<br>在个人管理上，<strong>着重虽不紧迫却极重要的事</strong>，找到平衡重要紧急事务和重要不紧急事务之间的关系；</p></li><li><p>第二类活动是有效自我管理的核心内容，需要将生活中心转移到第二类事务；<br>每周都围绕<strong>虽不紧迫却极重要</strong>的事情，不是按照事情的急迫程度而是<strong>重要程度</strong>来做安排。</p><ol><li>确认角色，这周要扮演什么角色？bug 修复者？目标推进者？单元测试完善者？</li><li>选择目标，针对角色制定目标；</li><li>安排进度，具体安排时间；</li><li>每日调整，<strong>第二类事务为中心</strong>，每日计划就变成了依据这个中心进行的调整；</li></ol></li></ol><p>之前自身的解决方案问题出在事情的划分上，感觉所有的问题都好象是又重要又紧急的。</p><h4 id="不断更新"><a href="#不断更新" class="headerlink" title="不断更新"></a>不断更新</h4><p><img src="/resources/image/4-options.png" alt="4 options"></p><p>重点是<strong>平衡更新</strong>,每个方向上都要不断成长，学习、坚持、实践、再学习、再坚持、再实践……</p><h2 id="对比自身解决方案和新收获的解决方案"><a href="#对比自身解决方案和新收获的解决方案" class="headerlink" title="对比自身解决方案和新收获的解决方案"></a>对比自身解决方案和新收获的解决方案</h2><p>上文都总结对比过了。</p><h2 id="下一个问题"><a href="#下一个问题" class="headerlink" title="下一个问题"></a>下一个问题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在读书计划选书的时候，我觉得我有必要提升一下自我管理的一些能力，因此选择了这本书。&lt;br&gt;这些是我读书的收获。&lt;/p&gt;</summary>
    
    
    
    
    <category term="read" scheme="https://notes.yaohwu.xyz/tags/read/"/>
    
  </entry>
  
  <entry>
    <title>设计软件的思想和方式</title>
    <link href="https://notes.yaohwu.xyz/2019/09/25/software-design/"/>
    <id>https://notes.yaohwu.xyz/2019/09/25/software-design/</id>
    <published>2019-09-25T08:12:57.000Z</published>
    <updated>2022-04-06T04:18:14.850Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章大致讲一些设计软件使用的原则和思想，以及一些具体的模式。其实软件行业发展这么多年来，已经解决了大量的问题。本文讲的这些内容其实全是这些为了解决问题而发明的有效的方法。</p><p>无论是适用广泛的 23 种设计模式，还是其他对于软件结构的抽象，其实类似这样的东西都能被叫做 Pattern。若干个 Pattern 组合起来，就构成了一个 Architecture。</p><span id="more"></span><h2 id="面向对象的-SOLID-原则"><a href="#面向对象的-SOLID-原则" class="headerlink" title="面向对象的 SOLID 原则"></a>面向对象的 SOLID 原则</h2><p>在讲 23 种设计模式之前，我们先来看看 SOLID 原则。</p><p>其实在我之前的分享文章<a href="https://yaohwu.xyz/#/posts/9">耦合和聚合以及软件设计的一些理论知识</a><br>中就已经提到过这些原则。在这边再详细展开说一下。</p><h3 id="Single-responsibility-principle"><a href="#Single-responsibility-principle" class="headerlink" title="Single responsibility principle"></a>Single responsibility principle</h3><p>单一职责原则，认为对象应该具有单一职责的概念。每个类都应该有单一的职责，并且该职责由这个类完全封装起来。<br>这样的结构让这个类非常健壮，修改自己类的功能，不会影响到其他的功能。<br>比如，一个报表需要导出，那么就专门搞一个导出器类来完成导出这个功能，而不是放在报表这个类中，这样即使修改导出的功能，也不会影响报表其他功能的正常使用。</p><h3 id="Open–closed-principle"><a href="#Open–closed-principle" class="headerlink" title="Open–closed principle"></a>Open–closed principle</h3><p>开闭原则，软件中的对象（类，模块，函数等等）应该对于扩展是开放的，对于修改是封闭的。这是一个非常重要的原则。对于这个原则，有两种理解：</p><p>最初的理解：</p><ol><li>如果一个模块仍可以扩展，那么它是一个开放的模块。</li><li>如果一个模块需要被其他模块使用，那么这个模块必须已经包含已定义好的稳定的描述，这些描述将不再可被修改。</li><li>如果需要将一个模块的功能进行重新修改，那么可以通过继承的方式，可以重用已有的实现。</li></ol><p>后续的理解，也就是现在被大家接受的理解：</p><ol><li>使用抽象的接口。</li><li>接口的实现是可以被修改的，并且可以通过多态在多种实现间实现替换。</li><li>由于继承自抽象接口，因此接口规范可以被重用，但是不能重用实现。</li><li>接口是不可以修改的，但是新的实现必须要实现这个接口。</li></ol><p>旧理解，强调更多的是一个稳定的已定义好的默认实现；新理解，强调更多的是一个稳定的已定义好的抽象接口。</p><p>例如还是拿报表的导出来说，我们在设计导出逻辑时，使用的是一个抽象的导出接口，可以没有任何实现，然后可以提供一种导出器比如导出 xlsx 作为一个默认的实现。当我们要做扩展的时候，应该要去重新实现抽象的导出接口，而不是继承已有的 xlsx 导出器做修改，当然更不是直接修改 xlsx 导出器。这样新的导出器实现只是依赖导出器接口，而不是依赖默认的导出器，避免默认导出器修改时被影响，也就是面向接口编程。</p><h3 id="Liskov-substitution-principle"><a href="#Liskov-substitution-principle" class="headerlink" title="Liskov substitution principle"></a>Liskov substitution principle</h3><p>里氏替换原则，在不改变程序正确性的同时，任何对象都可以由其子类型对象替换。</p><p><code>Let q(x) be a property provable about objects x of type T. Then q(y) should be true for objects y of type S where S is a subtype of T.</code></p><p>里氏替换原则有至少以下两种含义：</p><ol><li>里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。</li><li>如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合 LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化的，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。</li></ol><p>不符合 LSP 的最常见的情况是，父类和子类都是可实例化的非抽象类，且父类的方法被子类重新定义，这一类的实现继承会造成父类和子类间的强耦合，也就是实际上并不相关的属性和方法牵强附会在一起，不利于程序扩展和维护。</p><p>尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承。</p><p><code>正方形不是长方形。</code></p><h3 id="Interface-segregation-principle"><a href="#Interface-segregation-principle" class="headerlink" title="Interface segregation principle"></a>Interface segregation principle</h3><p>接口隔离原则，多个特定客户端的接口要优于一个通用的接口。</p><ol><li>客户端客户端不应该依赖他不需要的接口；不依赖不需要的接口，降低耦合；</li><li>类见的依赖关系应该建立在最小的接口上；最小也不是无限制最小，而是达到要求的最小的接口，提高内聚。</li></ol><h3 id="Dependency-inversion-principle"><a href="#Dependency-inversion-principle" class="headerlink" title="Dependency inversion principle"></a>Dependency inversion principle</h3><p>依赖反转原则。</p><ol><li>高层次的模块不应该依赖于低层次的模块，两者都应该依赖于抽象接口；降低层与层之间的耦合。</li><li>抽象接口不应该依赖于具体实现。而具体实现则应该依赖于抽象接口；面向接口编程。</li></ol><p>由 Resource 依赖 Store 变成 Resource 依赖 StoreProvider，Store 实现 StoreProvider。</p><h2 id="分门别类的学习设计模式"><a href="#分门别类的学习设计模式" class="headerlink" title="分门别类的学习设计模式"></a>分门别类的学习设计模式</h2><p>经过上述的学习，我们已经知道，这些原则都是前辈总结出来的使得软件清晰可读以及可扩展时可以应用的指南，都是一个思想，具体在代码中怎么运用还需要我们面对实际情况去灵活运用。<br>那么，设计模式就是更细层面上指导我们运用的细则。虽然说是细则，但是在不同的业务及需求背景下，也会有更灵活的运用，写出的代码可能不是任何设计模式的一种。<br>所以，还是要明确一点的是，我们学东西，重要的是学 idea，次要的是学 technique。我们通过学习更细层次上的设计模式，来将比较抽象难理解的 SOLID 原则搞懂，来学习如何合理的组织我们的代码，如何解耦，如何真正的达到对修改封闭对扩展开放的效果，让我们的代码更符合上面提到的面向对象的 SOLID 原则或者一些其他原则。我们是怀着这样的目的去学习设计模式的，而不是为了去背诵这些模式。</p><p>为了合理的利用设计模式，我们应该明白一个概念，叫做扩展点。扩展点不是天生就有的，而是设计出来的。我们设计一个软件的架构的时候，我们也要同时设计一下哪些地方以后可以改，哪些地方以后不能改。倘若你的设计不能满足现实世界的需要，那你就要重构，把有用的扩展点加进去，把没用的扩展点去除掉。</p><p>学习完设计模式我们要达成什么目标呢？假如看到一个代码结构，我们应该能：</p><ol><li>讲出这个结构的代码有何优劣；</li><li>讲出符合哪些 SOLID 原则；</li><li>讲出扩展点在什么地方，如何扩展；</li><li>更厉害的是，如果需求向不同的方向变更，应该怎么将这段代码修改成一个更符合需求变更方向的结构。</li></ol><p>如果能达成这个目标，那么我们的学习就是非常成功的。</p><h3 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h3><p>todo</p><h3 id="建造者模式-Builder-Pattern"><a href="#建造者模式-Builder-Pattern" class="headerlink" title="建造者模式(Builder Pattern)"></a>建造者模式(Builder Pattern)</h3><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li><li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li><li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li><li>初始化一个对象时，参数过多，或者很多参数具有默认值</li><li>Builder模式不适合创建差异性很大的产品类，产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li><li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li></ul><h4 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h4><p>最主要的用处就是配合链式调用的，来实现一个 builder，使得大量参数的对象或者有很多默认值的对象能够清晰的创建。</p><p>至于其他的用法，见仁见智，我认为都可以使用一些简单工厂或者静态的 builder 方法来实现。<br>在很多 IDE 中，都有为复杂对象自动生成对应 builder 类的插件，比如在 intellij IDEA 中，就有类似的插件<a href="https://plugins.jetbrains.com/plugin/6585-builder-generator">builder-generator</a>。</p><h3 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h3><h4 id="适配器模式适用场景"><a href="#适配器模式适用场景" class="headerlink" title="适配器模式适用场景"></a>适配器模式适用场景</h4><p>讲一个类的接口，转换成客户期望的另外一个接口。让原本接口不兼容的类可以合作无间。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li><p>使用组合来实现，对象适配器<br>针对被适配的实例来进行适配，使用对象的组合来实现。在调用是，所有的方法，都被委托给被适配的对象。</p><p><img src="https://cdn.jsdelivr.net/gh/yaohwu/link-image/static/eGoQni.png" alt="对象适配器 UML 图"></p></li><li><p>使用继承来实现，类适配器</p><p>因为使用的是继承，所以更像是调用者和被适配者之间的粘合剂。</p><p>总是使用一个适配器实例即可，不会在不同的被适配对象实例间创建不同的适配器。</p><p><img src="https://cdn.jsdelivr.net/gh/yaohwu/link-image/static/0VlslE.png" alt="类适配器 UML 图"></p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;这篇文章大致讲一些设计软件使用的原则和思想，以及一些具体的模式。其实软件行业发展这么多年来，已经解决了大量的问题。本文讲的这些内容其实全是这些为了解决问题而发明的有效的方法。&lt;/p&gt;
&lt;p&gt;无论是适用广泛的 23 种设计模式，还是其他对于软件结构的抽象，其实类似这样的东西都能被叫做 Pattern。若干个 Pattern 组合起来，就构成了一个 Architecture。&lt;/p&gt;</summary>
    
    
    
    
    <category term="design pattern" scheme="https://notes.yaohwu.xyz/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>泛型（Generic）-泛型怎么用，来大幅提高代码可读性和易用性</title>
    <link href="https://notes.yaohwu.xyz/2019/08/14/how-to-use-java-generic/"/>
    <id>https://notes.yaohwu.xyz/2019/08/14/how-to-use-java-generic/</id>
    <published>2019-08-14T08:09:35.000Z</published>
    <updated>2021-05-14T11:14:42.733Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Before generics, you had to cast every object you read from a collection.<br>If someone accidentally inserted an object of the wrong type, casts could fail at runtime.<br>With generics, you tell the compiler what types of objects are permitted in each collection.<br>The compiler inserts casts for you automatically and tells you at compile time if you try to insert an object of the wrong type.<br>This results in programs that are both safer and clearer, but these benefits come with complications.<br>In release 1.5, generics were added to Java.</p></blockquote><p>原本以为是一个很简单的东西，后来研究了发现，其实还是有不少知识可以学习。</p><span id="more"></span><h2 id="正面回答"><a href="#正面回答" class="headerlink" title="正面回答"></a>正面回答</h2><p>这个问题可以通过两方面来回答。</p><ol><li>怎么来大幅提高代码可读性和易用性？<br>其中有一种方式叫做用泛型。</li><li>泛型怎么用？<br>继续读本文。</li></ol><h2 id="什么是范型"><a href="#什么是范型" class="headerlink" title="什么是范型"></a>什么是范型</h2><p>范型，其实单独解释这个泛型是很困难的，就比如有人问你什么是书一样，这时候最好的回答就是直接拿一本书放到他面前告诉他，这就是书。</p><p>或者我们也可以从功能上来解释，泛型提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型，其本质是参数化类型。</p><h2 id="怎么理解泛型"><a href="#怎么理解泛型" class="headerlink" title="怎么理解泛型"></a>怎么理解泛型</h2><h3 id="这样"><a href="#这样" class="headerlink" title="这样"></a>这样</h3><p>对于泛型来说，网上有一种比较流行的理解方式，就是泛型提供了一种“模板”。</p><p>就拿 <code>ArrayList</code> 来说，假设需要一种 <code>String</code> 的 <code>ArrayList</code>，那么需要写一个 <code>StringArrayList</code> 类，又需要一种 <code>Integer</code> 的 <code>ArrayList</code>，那么需要写一个 <code>IntegerArrayList</code> 类。</p><p>为了减少这种类型的代码越来越多，因此将 <code>ArrayList</code> 变成了 <code>ArrayList&lt;T&gt;</code>，提供了一种“模板”，可以方便的完成各种类型的 <code>ArrayList</code>。</p><h3 id="不"><a href="#不" class="headerlink" title="不"></a>不</h3><p>我不是很赞同这种理解方式，虽然这种理解方式一定程度上确实能帮助我们理解泛型在代码复用方面给我们带来的好处，但是这种对泛型的理解很容易落入片面，因为完全可以不用泛型，就实现这种级别的代码复用，并且这种理解方式不符合 java 语言规范的发展历史，不能让我们看到 java 语言规范内部设计时的思考。</p><p>我来说一下我是如何理解的。</p><p>泛型是 <code>java</code> 在 <code>1.5</code> 版本时引入的特性，如果我们现在不用泛型，那么写出的代码就是 <code>1.5</code> 版本之前的代码。就拿操作 <code>ArrayList</code> 来说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 操作一个 String 的 ArrayList</span></span><br><span class="line">ArrayList strList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">strList.add(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line">strList.add(<span class="string">&quot;str2&quot;</span>);</span><br><span class="line">strList.remove(<span class="string">&quot;str1&quot;</span>);</span><br><span class="line">String str2 = (String) strList.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作一个 Integer 的 ArrayList</span></span><br><span class="line">ArrayList intList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">intList.add(<span class="number">1</span>);</span><br><span class="line">intList.add(<span class="number">2</span>);</span><br><span class="line">intList.remove(<span class="number">1</span>);</span><br><span class="line">Integer int2 = (Integer) intList.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>可以看到，即使是在 <code>1.5</code> 版本之前的代码中，需要 <code>StringArrayList</code> 或者 <code>IntegerArrayList</code> 时，直接使用 <code>ArrayList</code> 就可以了，<code>ArrayList</code> 可不是直到 <code>1.5</code> 才有的，<code>ArrayList</code> 中使用 <code>Object[]</code> 数组来实现，因为万物都可以向上转型成 <code>Object</code> 因此也就不必要每一个类型都有一个 <code>TypeArrayList</code>，这已经实现了代码复用。</p><p>但是确实又不方便的地方，哪里呢？</p><ol><li>需要强制类型转换，不够安全，不够方便；</li><li>没有类型检查，往一个类型为 <code>String</code> 的 <code>ArrayList</code> 的插入一个 <code>Integer</code> 对象是可以的。</li></ol><p>正是这两个原因，才在 <code>1.5</code> 引入的泛型。泛型来的目的是为了解决类型检查以及强制类型转换。泛型，让代码更清楚更安全，和“模板”以及代码复用只有很小的关系。</p><p>更清楚，指明类型，无需主动强制转换，直接调用相应方法；更安全，类型检查，提供保证安全的强制转换。</p><p>到了这一步，这么明显的好处，显然，在 <code>1.5</code> 版本引入泛型的特性是迫在眉睫的，但是有一个问题，怎么兼容？</p><p>新加的泛型对于旧代码来说是完全没有意义的，因为旧代码在旧版本上也能够正常运行。但是如何保证引入泛型的同时，旧代码在新版本上也能正常运行呢？</p><p>在详细说这个之前，我们先介绍一个名词，叫做 <code>可具化类型</code>（<code>reifiable type</code>），指的是 在运行期间类型完全可用的类型，例如 声明成 A 类型，那么在运行期间就一直是 A 类型，不会发生变化。</p><p>一种方式就是不改旧版本的东西，而是完全来一套新的类库。拿 <code>ArrayList</code> 来说，就是保留 <code>ArrayList</code>，同时提高一个新的泛化 <code>ArrayList</code> 我们假设叫做 <code>GArrayList</code>。</p><p>这两个是完全不一样的类型，并且都是可具化的类型，这就意味着，在运行时，这两个类库是完全独立的，这样旧代码就只能在旧版本的逻辑中运行，新版本也只能在新版本的逻辑中运行。</p><p>旧版本代码向新版本代码迁移变得非常困难，一个应用假如希望迁移到新版本代码中，那么它必须提供两个版本的代码，并且这种兼容方案会在所有代码中飞速传播，如果当时的 <code>java</code> 社区采用这种方案，那么我们现在可能学习使用的就是 <code>java 2</code>。</p><p>这种方式显然不能够满足兼容的需求，因此泛型系统的设计向寻求迁移兼容性上转变，允许现有代码可以用泛型也可以不用，这样不会再彼此独立开发的软件中间加任何依赖。</p><p>既然 <code>ArrayList</code> 和 <code>GArrayList</code> 需要迁移兼容性，那么就不能创造一个完全可具化的泛型系统。怎么办呢，<code>类型擦除</code>（<code>type erasure</code>）。</p><p>其实类型擦除和可具化类型本身就是相对的概念，可具化就是不会被擦除的类型，会进行类型擦除的就不是可具化类型。</p><p><code>java</code> 的泛型系统就是借助类型擦除来实现的，类型擦除是一种映射，即将（可能包含参数化类型和类型变量的）类型映射为（不再是参数化类型或类型变量的）类型，也就是无论何种类型的 ArrayList，在编译后都会无类型的 <code>ArrayList</code>。</p><h3 id="类型擦除带来的弊端"><a href="#类型擦除带来的弊端" class="headerlink" title="类型擦除带来的弊端"></a>类型擦除带来的弊端</h3><p>到这里，我们已经知道为什么使用类型擦除来实现泛型了。</p><p>类型擦除也给 <code>java</code> 的泛型系统带来了很多弊端：</p><ol><li>因为泛型都是引用类型，最终都会被擦除成 <code>Object</code>，因此基本类型会进行包装；<br>就像 <code>Object a = 1;</code> a 其实是 <code>Integer</code> 一样；</li><li>无法取得带泛型的 <code>Class</code><br>无论 <code>ArrayList&lt;String&gt;</code> 还是 <code>ArrayList&lt;Integer&gt;</code> 实例拿到的 <code>class</code> 都是 <code>ArrayList.class</code></li><li>因为无法获取带泛型的 <code>Class</code>，因此也就没办法判断带泛型类型的类型<br>运行时无法判断 <code>list</code> 是 <code>ArrayList&lt;String&gt;</code> 还是 <code>ArrayList&lt;Integer&gt;</code></li><li>无法实例化泛型 <code>T</code></li></ol><h2 id="哪三种泛型用法"><a href="#哪三种泛型用法" class="headerlink" title="哪三种泛型用法"></a>哪三种泛型用法</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.t = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Dock</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericMethodTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;%s &quot;</span>, element);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用泛型注意哪些"><a href="#使用泛型注意哪些" class="headerlink" title="使用泛型注意哪些"></a>使用泛型注意哪些</h2><h3 id="使用泛型，不要使用原生类型（raw-type）"><a href="#使用泛型，不要使用原生类型（raw-type）" class="headerlink" title="使用泛型，不要使用原生类型（raw type）"></a>使用泛型，不要使用原生类型（raw type）</h3><p>每个泛型都有一个不带任何实际类型参数的类型，那种类型就是原生类型，比如 <code>ArrayList&lt;T&gt;</code> 的原生类型是 <code>ArrayList</code>。</p><p>这一点就是要求我们使用泛型，因为泛型能够代码类型检查并且代码也更清楚，如果使用原生类型，那么就失去了泛型在安全性以及表述性上的优势。</p><p>两个例外：</p><ol><li><code>List&lt;String&gt;.class</code></li><li><code>o instanceof Set&lt;String&gt;</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set)&#123;</span><br><span class="line">    Set&lt;?&gt; m = (Set&lt;?&gt;) o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Set</code>，<code>Set&lt;Object&gt;</code>，<code>Set&lt;?&gt;</code> 的区别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        put1(<span class="keyword">new</span> HashSet&lt;Object&gt;(), <span class="string">&quot;a&quot;</span>);</span><br><span class="line">        put2(<span class="keyword">new</span> HashSet&lt;Object&gt;(), <span class="string">&quot;b&quot;</span>);</span><br><span class="line">        put3(<span class="keyword">new</span> HashSet&lt;Object&gt;(), <span class="string">&quot;c&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put1</span><span class="params">(Set&lt;?&gt; objects, Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// compile error</span></span><br><span class="line">        objects.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put2</span><span class="params">(Set&lt;Object&gt; objects, Object o)</span> </span>&#123;</span><br><span class="line">        objects.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">put3</span><span class="params">(Set objects, Object o)</span> </span>&#123;</span><br><span class="line">        objects.add(o);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong><code>Set</code></strong> 是原生类型，只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的；它脱离了泛型系统，是不安全的。<br><strong><code>Set&lt;Object&gt;</code></strong> 是参数化类型，表示可以包含任何对象类型的一个集合；是安全的。<br><strong><code>Set&lt;?&gt;</code></strong> 则是一个无限制的通配符类型，表示只能包含某种未知对象类型的一个集合；是安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(Set&lt;?&gt; objects, Set&lt;?&gt; objects2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Object object : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (objects2.contains(object)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消除非受检警告"><a href="#消除非受检警告" class="headerlink" title="消除非受检警告"></a>消除非受检警告</h3><p>在使用泛型编程的过程中，会收到很多编译器警告，这些是使用泛型类型检查的好处，我们应该尽可能的消除这些警告。</p><p>如果无法消除警告，也应该始终在尽可能小的范围中使用 <code>SuppressWarnings</code> 注解并且加注释来说明原因；永远不要将 <code>SuppressWarnings</code> 注解放在类上来消除非受检警告。</p><h3 id="使用列表优先于数组"><a href="#使用列表优先于数组" class="headerlink" title="使用列表优先于数组"></a>使用列表优先于数组</h3><p>数组和泛型相比，有两个不同点：</p><p>数组是协变的，泛型是不可变的<br>例如，<code>Sub</code> 是 <code>Par</code> 的子类，那么数组类型 <code>Sub[]</code> 是 <code>Par[]</code> 的子类，但是 <code>List&lt;Sub&gt;</code> 和 <code>List&lt;Par&gt;</code> 之间没有任何父子类关系；<br>数组是可具化的，泛型要进行类型擦除<br>因此，不要出现数组和泛型混用的情况，如果出现这样的情况，优先使用列表而不是数组。</p><h3 id="优先考虑泛型"><a href="#优先考虑泛型" class="headerlink" title="优先考虑泛型"></a>优先考虑泛型</h3><p>这一条看似和第一条重复，其实侧重点不同，第一条侧重使用泛型，这一条侧重定义新的泛型。</p><p>当你发现你的代码中需要获取对象并进行转化，那么可以考虑使用泛型了。</p><h3 id="优先考虑泛型方法"><a href="#优先考虑泛型方法" class="headerlink" title="优先考虑泛型方法"></a>优先考虑泛型方法</h3><p>如同类能够从泛型中收益，方法也可以。静态工具方法尤其适合泛型化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableCollection&lt;&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用有限制通配符来提升-API-的灵活性"><a href="#利用有限制通配符来提升-API-的灵活性" class="headerlink" title="利用有限制通配符来提升 API 的灵活性"></a>利用有限制通配符来提升 <code>API</code> 的灵活性</h3><p>使用 <code>super</code>（T 及 T 的所有父类），<code>extends</code>（T 及 T 的所有子类） 和 <code>?</code>（<code>? extends Object</code>，无边界）来提高 <code>api</code> 的灵活性。<br>使用 <strong>交集类型</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;AA&gt; aas = <span class="keyword">new</span> ArrayList&lt;AA&gt;();</span><br><span class="line">        <span class="keyword">new</span> Docker&lt;A&gt;().pushAll(aas);</span><br><span class="line">        List&lt;A&gt; as = <span class="keyword">new</span> ArrayList&lt;A&gt;();</span><br><span class="line">        <span class="keyword">new</span> Docker&lt;AA&gt;().popAll(as);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">a</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">AA</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">b</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">A</span> &amp; <span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">        T t;</span><br><span class="line"></span><br><span class="line">        <span class="function">String <span class="title">c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> t.a() + t.b();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Docker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        Collection&lt;T&gt; ts;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Collection&lt;? extends T&gt; collection)</span> </span>&#123;</span><br><span class="line">            ts.addAll(collection);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; collection)</span> </span>&#123;</span><br><span class="line">            collection.addAll(ts);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="几个分享会问题"><a href="#几个分享会问题" class="headerlink" title="几个分享会问题"></a>几个分享会问题</h2><ol><li>对于 Java 泛型的弊端，我们应该如何规避？</li><li>哪种情况下的强转是被认为安全的，可以忽略的？哪些不是？代码中找得到例子么？</li><li>哪些非受检警告是很难消除的，代码中能找得到例子么?</li><li>举几个数组和泛型冲突的例子？</li><li>如何实现一个类型安全的异构容器？</li></ol><p>类型安全的异构容器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clazz.cast(map.get(clazz));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(Class&lt;T&gt; clazz, T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;clazz should not be null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(clazz, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Favorites favorites = <span class="keyword">new</span> Favorites();</span><br><span class="line">        favorites.put(String.class, <span class="string">&quot;String value&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 局限性1</span></span><br><span class="line">        Class clazz = getStringClass();</span><br><span class="line">        favorites.put(clazz, <span class="number">2</span>);</span><br><span class="line">        favorites.put(clazz, <span class="keyword">new</span> Object());</span><br><span class="line">        <span class="comment">// 局限性2</span></span><br><span class="line">        <span class="comment">// error</span></span><br><span class="line">        <span class="comment">// favorites.put(List&lt;String&gt;.class, new ArrayList&lt;String&gt;());</span></span><br><span class="line">        favorites.put(List.class, <span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">getStringClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.class;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Before generics, you had to cast every object you read from a collection.&lt;br&gt;If someone accidentally inserted an object of the wrong type, casts could fail at runtime.&lt;br&gt;With generics, you tell the compiler what types of objects are permitted in each collection.&lt;br&gt;The compiler inserts casts for you automatically and tells you at compile time if you try to insert an object of the wrong type.&lt;br&gt;This results in programs that are both safer and clearer, but these benefits come with complications.&lt;br&gt;In release 1.5, generics were added to Java.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原本以为是一个很简单的东西，后来研究了发现，其实还是有不少知识可以学习。&lt;/p&gt;</summary>
    
    
    
    
    <category term="generic" scheme="https://notes.yaohwu.xyz/tags/generic/"/>
    
  </entry>
  
  <entry>
    <title>mock-test 2 EasyMock &amp; PowerMock</title>
    <link href="https://notes.yaohwu.xyz/2019/03/10/mock-test-2-easymock-powermock/"/>
    <id>https://notes.yaohwu.xyz/2019/03/10/mock-test-2-easymock-powermock/</id>
    <published>2019-03-10T07:57:20.000Z</published>
    <updated>2021-05-14T11:14:42.735Z</updated>
    
    <content type="html"><![CDATA[<p>从遇到的问题出发，反向总结一下这段时间写单元测试的一些方法。</p><span id="more"></span><h2 id="1-EasyMock"><a href="#1-EasyMock" class="headerlink" title="1.EasyMock"></a>1.EasyMock</h2><p>EasyMock 主要也就分 mock expect replay 和 verify 这四个过程。</p><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><h4 id="mock-的方式"><a href="#mock-的方式" class="headerlink" title="mock 的方式"></a>mock 的方式</h4><ul><li>在方法中直接 mock</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 在方法中直接mock</span></span><br><span class="line">    Singer defaultSinger = EasyMock.mock(Singer.class);</span><br><span class="line">    Singer strictSinger = EasyMock.strictMock(Singer.class);</span><br><span class="line">    Singer niceSinger = EasyMock.niceMock(Singer.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>使用注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(EasyMockRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用注解</span></span><br><span class="line">    <span class="meta">@Mock(MockType.STRICT)</span></span><br><span class="line">    <span class="keyword">private</span> Singer strictSingerAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock(MockType.NICE)</span></span><br><span class="line">    <span class="keyword">private</span> Singer niceSingerAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> Singer defaultSingerAnnotation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用注解处理一些依赖注入</strong>，例如：<br>被测试类 VocalConcert 里面依赖了一个 Singer 类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VocalConcert</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Singer singer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VocalConcert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Vocal Concert Show: &quot;</span> + singer.show();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Vocal Concert Show: ...&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，这样写就可以直接将 mock 得到的 defaultMockSinger 注入到 concert 当中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(EasyMockRunner.class)</span></span><br><span class="line"><span class="comment">// 或者是 @RunWith(PowerMockRunner.class) 都可以</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VocalConcertTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestSubject</span></span><br><span class="line">    <span class="keyword">private</span> VocalConcert concert = <span class="keyword">new</span> VocalConcert();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> Singer defaultMockSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVocalConcert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EasyMock.expect(defaultMockSinger.show()).andReturn(<span class="string">&quot;defaultMockSinger show&quot;</span>).anyTimes();</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(defaultMockSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(concert.show());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想使用默认的 test runner，那么可以采用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VocalConcertTest3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Rule</span></span><br><span class="line">    <span class="keyword">public</span> EasyMockRule mocks = <span class="keyword">new</span> EasyMockRule(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@TestSubject</span></span><br><span class="line">    <span class="keyword">private</span> VocalConcert concert = <span class="keyword">new</span> VocalConcert();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> Singer defaultMockSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVocalConcert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EasyMock.expect(defaultMockSinger.show()).andReturn(<span class="string">&quot;defaultMockSinger show&quot;</span>).anyTimes();</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(defaultMockSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(concert.show());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="mock-的策略"><a href="#mock-的策略" class="headerlink" title="mock 的策略"></a>mock 的策略</h4><ul><li>default</li></ul><p>默认策略，使用 Easy.mock(XXX.class) 或者 @Mock 注解；</p><p>不介意方法是否按照 expect 的顺序进行调用，verify <strong>会</strong>针对所有期望被调用但是实际上没有调用的方法抛出异常。</p><ul><li>strict</li></ul><p>strict 策略，使用 Easy.strictMock(XXX.class) 或者 @Mock(MockType.STRICT) 注解；</p><p>相比 default 的方式，这种更为严格，所有调用的方法需要严格按照 expect 的顺序进行调用，否则会抛出异常；verify 也<strong>会</strong>针对所有期望被调用但是实际上没有调用的方法抛出异常。</p><ul><li>nice</li></ul><p>nice 策略，使用 EasyMock.niceMock(Nice.class) 或者 @Mock(MockType.NICE) 注解；</p><p>相比 default 的方式，这种更为宽松，不介意调用顺序和次数，verify <strong>不会</strong>针对所有期望被调用但是实际上没有调用的方法抛出异常。同时，针对未期望的方法调用不会像 default 或者 strict 那样抛出 AssertionError 错误，而是返回对应的空值 0，null 或者 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(EasyMockRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingerTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> Singer defaultSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock(MockType.STRICT)</span></span><br><span class="line">    <span class="keyword">private</span> Singer strictSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Mock(MockType.NICE)</span></span><br><span class="line">    <span class="keyword">private</span> Singer niceSinger;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// default</span></span><br><span class="line">        EasyMock.expect(defaultSinger.getName()).andReturn(<span class="string">&quot;yaohwu&quot;</span>).once();</span><br><span class="line">        EasyMock.expect(defaultSinger.getBirthday()).andReturn(<span class="keyword">new</span> Date()).once();</span><br><span class="line">        EasyMock.expect(defaultSinger.getName()).andReturn(<span class="string">&quot;new yaohwu&quot;</span>).once();</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(defaultSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(defaultSinger.getBirthday());</span><br><span class="line">        System.out.println(defaultSinger.getName());</span><br><span class="line">        System.out.println(defaultSinger.getName());</span><br><span class="line"></span><br><span class="line">        EasyMock.verify(defaultSinger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// strict</span></span><br><span class="line">        EasyMock.expect(strictSinger.getName()).andReturn(<span class="string">&quot;yaohwu&quot;</span>).once();</span><br><span class="line">        EasyMock.expect(strictSinger.getBirthday()).andReturn(<span class="keyword">new</span> Date()).once();</span><br><span class="line">        EasyMock.expect(strictSinger.getName()).andReturn(<span class="string">&quot;new yaohwu&quot;</span>).once();</span><br><span class="line"></span><br><span class="line">        EasyMock.replay(strictSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(strictSinger.getName());</span><br><span class="line">        System.out.println(strictSinger.getBirthday());</span><br><span class="line">        System.out.println(strictSinger.getName());</span><br><span class="line"></span><br><span class="line">        EasyMock.verify(strictSinger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// nice</span></span><br><span class="line">        EasyMock.expect(niceSinger.getName()).andReturn(<span class="string">&quot;yaohwu&quot;</span>).once();</span><br><span class="line">        <span class="comment">//EasyMock.expect(niceSinger.getBirthday()).andReturn(new Date()).once();</span></span><br><span class="line">        <span class="comment">//EasyMock.expect(niceSinger.getName()).andReturn(&quot;new yaohwu&quot;).once();</span></span><br><span class="line"></span><br><span class="line">        EasyMock.replay(niceSinger);</span><br><span class="line"></span><br><span class="line">        System.out.println(niceSinger.getBirthday());</span><br><span class="line">        System.out.println(niceSinger.getName());</span><br><span class="line">        System.out.println(niceSinger.getName());</span><br><span class="line"></span><br><span class="line">        EasyMock.verify(niceSinger);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="局部-mock"><a href="#局部-mock" class="headerlink" title="局部 mock"></a>局部 mock</h4><p>部分场景下，只希望 mock 部分方法，针对其余的方法希望能保留默认行为。这种场景一般是由于设计不好，如果非得局部 mock 也可以。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingerTest3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Singer singer =</span><br><span class="line">                EasyMock.partialMockBuilder(Singer.class)</span><br><span class="line">                        .addMockedMethod(<span class="string">&quot;getName&quot;</span>)</span><br><span class="line">                        .createMock();</span><br><span class="line"></span><br><span class="line">        EasyMock.expect(singer.getName()).andReturn(<span class="string">&quot;yaohwu&quot;</span>);</span><br><span class="line">        EasyMock.replay(singer);</span><br><span class="line"></span><br><span class="line">        System.out.println(singer.getName());</span><br><span class="line">        Assert.assertNull(singer.getBirthday());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>EasyMock 不能 mock final 和 private 的方法，即使 mock 了，实际执行的还是默认的行为；</li><li>对象实例化是通过 <a href="http://objenesis.org/">objenesis</a> 做到的，和我们的 rpc 反序列化时获取实例策略是一样的，<strong>不会触发任何执行任何构造方法</strong>，因此类中的变量不会被初始化。</li></ol><h3 id="expect"><a href="#expect" class="headerlink" title="expect"></a>expect</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Singer defaultSinger = EasyMock.mock(Singer.class);</span><br><span class="line">        <span class="comment">// 对存在返回值的方法进行录制</span></span><br><span class="line">        EasyMock.expect(defaultSinger.show()).andReturn(<span class="string">&quot;fff&quot;</span>).once();</span><br><span class="line">        EasyMock.expect(defaultSinger.getName()).andReturn(<span class="string">&quot;b&quot;</span>).once();</span><br><span class="line">        <span class="comment">// 对没有返回值的方法进行录制</span></span><br><span class="line">        defaultSinger.setName(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        EasyMock.expectLastCall()</span><br><span class="line">                .andThrow(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;Error Cannot Reset Name&quot;</span>)).once()</span><br><span class="line">                .andVoid().once()</span><br><span class="line">                .andThrow(<span class="keyword">new</span> RuntimeException(<span class="string">&quot;Error Cannot Reset Name For More Times&quot;</span>)).anyTimes();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>times andReturn andThrow 是可以被链式调用的，并且可以是多组组合使用</li></ul><p>因此要注意顺序，一般情况，andReturn() 或者 andThrow() 在前，times() 放在最后。</p><h4 id="andStubXXX"><a href="#andStubXXX" class="headerlink" title="andStubXXX"></a>andStubXXX</h4><p>上面使用的 expect 是我们期望进行的录制并希望参与 verify 的，假设部分方法，我们也希望他们对调用做出反应，同时也不在乎他们何时何地被调用多少次，那么可以使用 andStub 开头的方法。</p><p>&#96;</p><p>EasyMock.expect(defaultMockSinger.getName()).andStubReturn(“”);<br>EasyMock.expect(defaultMockSinger.getBirthday()).andStubThrow(new RuntimeException(“Error e”));<br>&#96;</p><h4 id="参数匹配"><a href="#参数匹配" class="headerlink" title="参数匹配"></a>参数匹配</h4><p>&#96;</p><p>EasyMock.expect(dictionary.get(EasyMock.eq(1001L), EasyMock.anyObject(Calculator.class)))<br>        .andReturn(“J”).anyTimes();<br>&#96;</p><p>有时候，我们并不确认实际调用的参数是什么或者说实际上的参数是一个范围，那么我们就可以用到参数匹配。</p><p>EasyMock 中提供了多种多样的线程的方法来供我们使用。</p><p>需要注意的是，<strong>被调用方法的参数要么全部使用确定的值，要么全部使用参数匹配器</strong>，不能出现下面这种场景。</p><p>&#96;</p><p>EasyMock.expect(dictionary.get(1000L, EasyMock.anyObject(Calculator.class)))<br>        .andReturn(“J”).anyTimes();<br>&#96;</p><h5 id="自定义参数匹配器"><a href="#自定义参数匹配器" class="headerlink" title="自定义参数匹配器"></a>自定义参数匹配器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EasyMock</span></span>&#123;</span><br><span class="line">    <span class="comment">// EasyMock.endsWith() 的实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">            reportMatcher(<span class="keyword">new</span> EndsWith(suffix));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EndsWith</span> <span class="keyword">implements</span> <span class="title">IArgumentMatcher</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">5159338714596685067L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String suffix;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EndsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 匹配规则</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(Object actual)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (actual <span class="keyword">instanceof</span> String) &amp;&amp; ((String) actual).endsWith(suffix);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不匹配时的输出信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTo</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">        buffer.append(<span class="string">&quot;endsWith(\&quot;&quot;</span> + suffix + <span class="string">&quot;\&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="andAnswer-和-andDelegateTo"><a href="#andAnswer-和-andDelegateTo" class="headerlink" title="andAnswer() 和 andDelegateTo()"></a>andAnswer() 和 andDelegateTo()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo 我没怎么用到，等用到了再补充</span></span><br></pre></td></tr></table></figure><h2 id="verify"><a href="#verify" class="headerlink" title="verify"></a>verify</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testA</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 录制</span></span><br><span class="line">        expect();</span><br><span class="line">        <span class="comment">// 设定未回放状态</span></span><br><span class="line">        replay();</span><br><span class="line">        <span class="comment">// 调用业务逻辑进行测试</span></span><br><span class="line">        test();</span><br><span class="line">        <span class="comment">// 验证录制的方法调用的 times() 是否符合预期，如果和预期不符合，会抛出异常显示多或者少</span></span><br><span class="line">        verrify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>mock 对象是可以被重用的，使用 reset 方法，让他变回起初的“白纸”状态。<br>还可以通过 reset 修改策略。<br>resetToNice(mock), resetToDefault(mock), resetToStrict(mock).</p><h2 id="PowerMock"><a href="#PowerMock" class="headerlink" title="PowerMock"></a>PowerMock</h2><p>PowerMock 也有和 Mockito 配合的 api, 这里就不关注了，主要说和 EasyMock 配合的。</p><p>PowerMock is a Java framework that allows you to unit test code normally regarded as untestable.</p><p>处理 EasyMock 不能处理的 mock 场景。</p><h3 id="mock-static"><a href="#mock-static" class="headerlink" title="mock static"></a>mock static</h3><h4 id="common-mock-static"><a href="#common-mock-static" class="headerlink" title="common mock static"></a>common mock static</h4><ol><li>类上加注解 @RunWith(PowerMockRunner.class)</li><li>类上加注解 @PrepareForTest(ClassThatContainsStaticMethod.class)</li><li>mock PowerMock.mockStatic(ClassThatContainsStaticMethod.class)</li><li>expect EasyMock.expect(ClassThatContainsStaticMethod.xxx())</li><li>replay PowerMock.replay(ClassThatContainsStaticMethod.class)</li><li>verify PowerMock.verify(ClassThatContainsStaticMethod.class)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;GeneralContext.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaScriptImplTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JavaScriptImpl script;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> RepositoryDeal repositoryDeal;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        script = <span class="keyword">new</span> JavaScriptImpl();</span><br><span class="line">        script.setContent(<span class="string">&quot;console.log(&#x27;a&#x27;)&quot;</span>);</span><br><span class="line">        script.setParameters(<span class="keyword">new</span> ParameterProvider[]&#123;<span class="keyword">new</span> Parameter(<span class="string">&quot;p1&quot;</span>, <span class="string">&quot;中文!+&quot;</span>)&#125;);</span><br><span class="line">        script.addJSImort(<span class="string">&quot;imported.js&quot;</span>);</span><br><span class="line"></span><br><span class="line">        repositoryDeal = EasyMock.mock(RepositoryDeal.class);</span><br><span class="line">        EasyMock.replay(repositoryDeal);</span><br><span class="line"></span><br><span class="line">        PowerMock.mockStatic(GeneralContext.class);</span><br><span class="line">        EasyMock.expect(GeneralContext.getCurrentAppNameOfEnv()).andReturn(<span class="string">&quot;webroot&quot;</span>).anyTimes();</span><br><span class="line">        GeneralContext.listenPluginRunningChanged(EasyMock.anyObject(PluginEventListener.class));</span><br><span class="line">        EasyMock.expectLastCall().anyTimes();</span><br><span class="line">        GeneralContext.listenPlugin(</span><br><span class="line">                EasyMock.eq(PluginEventType.AfterStop), EasyMock.anyObject(PluginEventListener.class), EasyMock.anyObject(PluginFilter.class));</span><br><span class="line">        EasyMock.expectLastCall().anyTimes();</span><br><span class="line"></span><br><span class="line">        PowerMock.replayAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCreateJS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do xxx</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意，PowerMock 的 replayAll 并不会触发 EasyMock 的 replay(xxx) 因此还是要分开调用，EasyMock 只是负责给 PowerMock mock 的对象预设行为，replay 和 verify PowerMock 和 EasyMock 两者还是各走各的。</li></ul><h4 id="mock-partial-static-or-private-method"><a href="#mock-partial-static-or-private-method" class="headerlink" title="mock partial static or private method"></a>mock partial static or private method</h4><p>如下的代码中就只是 mock 了  <strong>MimeUtility</strong> 其中的两个方法。<br>其中 <strong>getDefaultMIMECharset</strong> 不是一个 <strong>public</strong> 的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ....</span></span><br><span class="line">PowerMock.mockStaticPartial(MimeUtility.class, <span class="string">&quot;getDefaultJavaCharset&quot;</span>, <span class="string">&quot;getDefaultMIMECharset&quot;</span>);</span><br><span class="line">EasyMock.expect(MimeUtility.getDefaultJavaCharset()).andAnswer(<span class="keyword">new</span> IAnswer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;GBK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).once().andAnswer(<span class="keyword">new</span> IAnswer&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).once();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    PowerMock.expectPrivate(MimeUtility.class, <span class="string">&quot;getDefaultMIMECharset&quot;</span>).andAnswer(<span class="keyword">new</span> IAnswer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;GBK&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).once().andAnswer(<span class="keyword">new</span> IAnswer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">answer</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;UTF-8&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).once();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    Assert.fail(e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h3 id="mock-final"><a href="#mock-final" class="headerlink" title="mock final"></a>mock final</h3><p>和 mock static 一样<br>区别仅在于 <code>PowerMock.mockStatic</code> 和 <code>PowerMock.createMock</code>；</p><h3 id="mock-private"><a href="#mock-private" class="headerlink" title="mock private"></a>mock private</h3><p>用到的不多，如果出现这样的单元测试，优先考虑是不是设计上有问题或者有没有通过 public 方法的单元测试覆盖到的方法。</p><p>如果实在需要，可以参考<a href="https://github.com/powermock/powermock/wiki/MockPrivate">MockPrivate</a>。</p><h3 id="一些-Mock-技巧"><a href="#一些-Mock-技巧" class="headerlink" title="一些 Mock 技巧"></a>一些 Mock 技巧</h3><h4 id="SuppressStaticInitializationFor-“xxx-xxx-xxx”-和-suppress-策略"><a href="#SuppressStaticInitializationFor-“xxx-xxx-xxx”-和-suppress-策略" class="headerlink" title="@SuppressStaticInitializationFor(“xxx.xxx.xxx”) 和 suppress 策略"></a>@SuppressStaticInitializationFor(“xxx.xxx.xxx”) 和 suppress 策略</h4><p>假设单元测试用到了一个其他类的静态方法，但是这个类的初始化中做了很多单元测试不感知的工作，例如可能读取了授权证书等等。<br>这时候如果使用 powermock 对静态方法进行 mock 会触发这些初始化操作，但是由于相应的模块没有启动，这些初始化可能会失败，导致 mock 不了。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Service service = OtherModuleService.getService();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        authenticateLicense();</span><br><span class="line">        doSomethingSpecialDependsOnOtherModule();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有这样的场景，可以使用 @SuppressStaticInitializationFor(“xxx.xxx.xxx”) 注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor(&quot;com.xx.SessionManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Manager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Record&gt; RECORDS = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Manager Init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;Manager.class&#125;)</span></span><br><span class="line"><span class="comment">//@SuppressStaticInitializationFor(&quot;com.v2.yaohwu.gov.Manager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List expected = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        PowerMock.mockStatic(Manager.class);</span><br><span class="line">        EasyMock.expect(Manager.getAllRecord()).andReturn(expected).anyTimes();</span><br><span class="line"></span><br><span class="line">        PowerMock.replayAll();</span><br><span class="line">        List result = Manager.getAllRecord();</span><br><span class="line">        System.out.println(result.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Manager Init</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>如果放开@SuppressStaticInitializationFor(“com.v2.yaohwu.gov.Manager”) 的注释，那么输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>@SuppressStaticInitializationFor 可以阻止静态变量的声明以及静态代码块的运行。</p><p>如果需要部分变量初始化，那么可以使用 WhiteBox 的 api 对变量进行赋值 例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PrepareForTest(&#123;Manager.class&#125;)</span></span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor(&quot;com.v2.yaohwu.gov.Manager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ManagerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 正常测试</span></span><br><span class="line">        List expected = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        PowerMock.mockStatic(Manager.class);</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        EasyMock.expect(Manager.getAllRecord()).andReturn(expected).anyTimes();</span><br><span class="line"></span><br><span class="line">        PowerMock.replayAll();</span><br><span class="line">        List result = Manager.getAllRecord();</span><br><span class="line">        System.out.println(result.size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取变量 RECORDS 的值</span></span><br><span class="line">        System.out.println((String) Whitebox.getInternalState(Manager.class, <span class="string">&quot;RECORDS&quot;</span>));</span><br><span class="line">        <span class="comment">// 输出 null SuppressStaticInitializationFor 注解阻止了 RECORDS 的初始化</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对 Manager 中的私有变量进行赋值</span></span><br><span class="line">        List expected2 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 私有变量 RECORDS 中加入 一个 Manager 私有内部类 Record 的一个实例</span></span><br><span class="line">            <span class="comment">//noinspection unchecked</span></span><br><span class="line">            expected2.add(Whitebox.newInstance(Whitebox.getInnerClassType(Manager.class, <span class="string">&quot;Record&quot;</span>)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            Assert.fail(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将变量 RECORDS 赋值</span></span><br><span class="line">        Whitebox.setInternalState(Manager.class, <span class="string">&quot;RECORDS&quot;</span>, expected2);</span><br><span class="line">        <span class="comment">// 获取变量 RECORDS 的值</span></span><br><span class="line">        System.out.println(((List) Whitebox.getInternalState(Manager.class, <span class="string">&quot;RECORDS&quot;</span>)).size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="其他的-suppress-场景"><a href="#其他的-suppress-场景" class="headerlink" title="其他的 suppress 场景"></a>其他的 suppress 场景</h5><ol><li>suppress(constructor(XXX.class)) 处理构造函数</li><li>suppress(method(XXX.class, “methodName”)) 处理方法</li><li>suppress(field(XXX.class, “fieldName”)) 处理变量</li></ol><p>以上都要和 @PrepareForTest(XXX.class) 配合使用。<a href="https://github.com/powermock/powermock/wiki/Suppress-Unwanted-Behavior">link</a></p><h4 id="PowerMockIgnore"><a href="#PowerMockIgnore" class="headerlink" title="@PowerMockIgnore"></a>@PowerMockIgnore</h4><p>PowerMock 采用自定义类加载器的方式加载被测试类，如果出现类型转换异常或者类加载器形式的错误，那么可以使用 @PowerMockIgnore 注解，让 PowerMock 从系统类加载器中获取类。</p><p>出现的类型转换异常：</p><p><code>xxx.xxx.xxx.xxx cannot be cast to xxx.xxx.xxxProvider</code></p><p>也不仅仅局限于这个异常，如果你看到你一个不能解决的异常，其中有 package name 的信息，那么可以尝试使用 <strong>@PowerMockIgnore</strong>。</p><p>一般这些类有 “javax.crypto.*“,”javax.net.ssl.*“,”sun.security.ssl.*“ 等。</p><p>使用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(PowerMockRunner.class)</span></span><br><span class="line"><span class="meta">@PowerMockIgnore(&#123;&quot;javax.crypto.*&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXTest</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>参考文档</p><ul><li><a href="http://easymock.org/">easymock</a></li><li><a href="https://github.com/powermock/powermock/wiki">powermock</a></li><li><a href="https://github.com/powermock/powermock/wiki/FAQ">powermock QA</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;从遇到的问题出发，反向总结一下这段时间写单元测试的一些方法。&lt;/p&gt;</summary>
    
    
    
    
    <category term="unit-test" scheme="https://notes.yaohwu.xyz/tags/unit-test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://notes.yaohwu.xyz/2019/01/31/hello-world/"/>
    <id>https://notes.yaohwu.xyz/2019/01/31/hello-world/</id>
    <published>2019-01-31T12:46:25.000Z</published>
    <updated>2021-05-14T11:14:42.732Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    <category term="blog" scheme="https://notes.yaohwu.xyz/categories/blog/"/>
    
    
    <category term="blog" scheme="https://notes.yaohwu.xyz/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>web security</title>
    <link href="https://notes.yaohwu.xyz/2018/09/13/web-security/"/>
    <id>https://notes.yaohwu.xyz/2018/09/13/web-security/</id>
    <published>2018-09-13T07:54:01.000Z</published>
    <updated>2021-05-14T11:14:42.736Z</updated>
    
    <content type="html"><![CDATA[<p>安全涉及的领域很广泛，有 web 安全、DDoS 攻防、用户隐私、加密解密、数据安全、授权和认证等等，很多。</p><p>可以逐一学习。</p><p>今天我们主要讲一下 web 安全 顺带了解一下 DDoS 防范。（因为这个比较好找资料，准备的有些仓促。</p><span id="more"></span><h2 id="web-安全"><a href="#web-安全" class="headerlink" title="web 安全"></a>web 安全</h2><h3 id="XSS-Cross-Site-Scripting-攻击"><a href="#XSS-Cross-Site-Scripting-攻击" class="headerlink" title="XSS(Cross Site Scripting) 攻击"></a>XSS(Cross Site Scripting) 攻击</h3><p>通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的。</p><h4 id="成功的条件"><a href="#成功的条件" class="headerlink" title="成功的条件"></a>成功的条件</h4><ol><li>需要向web页面注入恶意代码</li><li>恶意代码被浏览器执行</li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>依据攻击效果可以分为两类，</p><ul><li>反射性攻击</li></ul><p>恶意代码并没有保存在目标网站，通过引诱用户点击一个链接到目标网站的恶意链接来实施攻击的。</p><p>比如：</p><p><img src="https://user-images.githubusercontent.com/9320666/45463544-32542c80-b73f-11e8-9a4e-1bd48b160b90.png" alt="xssreflect"></p><ul><li>存储型攻击</li></ul><p>恶意代码被保存到目标网站的服务器中，这种攻击具有较强的稳定性和持久性。</p><p>例如 bbs 发帖，中插入了脚本，查看这个帖子就可能执行恶意脚本。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com/img/bd_logo1.png?where=super&amp;id=&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id= imageid&quot;/&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;&lt;br x=&quot; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://www.baidu.com/img/bd_logo1.png?where=super&amp;id=&quot;</span> /&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="regexp">/xsst2/</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> <span class="attr">x</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="XSS-防范方法"><a href="#XSS-防范方法" class="headerlink" title="XSS 防范方法"></a>XSS 防范方法</h4><ol><li><p>针对反射性攻击，可以在表单提交或者 url 传递参数之前，对参数进行过滤。</p></li><li><p>针对存储型攻击，控制用户输入的输出，可以采用白名单的方法使用合法的标签显示，过滤掉非法的字符。</p></li></ol><h3 id="CSRF-Cross—Site-Request-Forgery"><a href="#CSRF-Cross—Site-Request-Forgery" class="headerlink" title="CSRF (Cross—Site Request Forgery)"></a>CSRF (Cross—Site Request Forgery)</h3><p>既跨站点请求伪造，也被叫做 XSRF，和 XSS 一样也是一种比较常见的 web 攻击。CSRF攻击者会过过构造的第三方页面诱导受害者完成加载或者点击，利用受害者的权限，以其身份向合法网站发起恶意请求，通常用户发生状态改变的请求，比如虚拟货币的转账，账号信息修改，恶意发邮件等等，由于具有一定的隐蔽性，所以比较难以防范。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><img src="https://user-images.githubusercontent.com/9320666/45463565-4861ed00-b73f-11e8-8272-6bb0fcbd9bf6.png" alt="csrf"></p><p>例如，转账的请求为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get http://xxxbank.com/transfer.do?from=rommel&amp;to=alice&amp;amount=100 HTTP/1.1</span><br></pre></td></tr></table></figure><p>CSRF 的攻击过程过程图上图所示：</p><ol><li>CSRF 攻击有一个前提条件，是用户具有某个正常访问的访问权限。一般网站的访问权限都具备一定的有效期，比如1天过期，或者几个小时过期，在此期间权限信息会保留在用户浏览器的 cookie 中，例子中假设用户C刚刚登录了网站A，权限还没有过期。</li><li>攻击者利用正常网站 A 的 CSFR 漏洞，构造页面一个恶意网页 B，在页面中包含对发往正常网站 A 的请求，在用户 C 加载页面 B（或者点击某些元素时触发）时，会触发攻击请求，目的是为了实现虚拟币的转账，请求可能隐藏得很深，用户并不一定能发现，伪造的请求如下：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">widht</span>=<span class="string">0</span> <span class="attr">height</span>=<span class="string">0</span> <span class="attr">src</span>=<span class="string">&quot;http://xxxbank.com/transfer.do?from=rommel&amp;to=attacker&amp;amount=100&quot;</span> /&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="CSRF-防范方法"><a href="#CSRF-防范方法" class="headerlink" title="CSRF 防范方法"></a>CSRF 防范方法</h4><ol><li>添加 Referer 域名白名单：HTTP 的 Referer 头记录了当前请求的来源页面的URL，如果用户是通过浏览器打开的网页一般都会带有这个信息。可以验证 URL 的域名是否在网站允许的白名单内，如果不在则拒绝请求。这种方式实现比较简单，而且可以在 web 服务器层统一配置，减少了后端开发成本，但是 Referer 域可以伪造，用户浏览器的可靠性也不能完全信赖，判断 Referer 可以做为一种辅助手段，但不能根治 CSRF。</li><li>令牌 (Token) 验证：令牌验证的方式，这是目前方法CSRF的一种普遍方法，其原理是在用户正式提交数据更新之前，给用户生成一个 token，一方面 token 保存在服务端，比如 Session 或者缓存中，一方面用户提交请求时连同 token 一同提交，服务获得接收到请求之后再做 token 验证，token 不存在、或者token不一致，或者失效都算作验证失败。token 的生成具有一定的随机性，攻击者往往很难伪造。token 一般作为一个 post 字段提交，或者作为 ajax 请求的 header 信息提交。</li><li>二次验证：对于一些敏感操作，比如对涉及到交易操作的控制更加严格一些。在用户提交时可以让用户输入验证码，或者再次输入交易密码，确保是用户的真实操作，而不是机器触发的。</li><li>SameSite Cookie 属性 <a href="https://en.wikipedia.org/wiki/HTTP_cookie">Http cookie</a></li></ol><h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>利用后端程序的漏洞，针对数据库进行攻击。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;$username&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;$password&quot;;</span><br></pre></td></tr></table></figure><p>如果攻击者设定了一个 password &#x3D; anywords” OR 1&#x3D;1 的密码，那么执行的 sql 就变成了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">WHERE</span> username <span class="operator">=</span> &quot;xxx&quot; <span class="keyword">AND</span> password <span class="operator">=</span> &quot;anywords&quot; <span class="keyword">OR</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果 构造密码为 password anywords” OR 1&#x3D;1;DROP TABLE users ，那么 users 表都会被删除。</p><p><img src="https://user-images.githubusercontent.com/9320666/45463573-557edc00-b73f-11e8-8990-51c6d45c7f7e.jpg" alt="&#39;上古&#39;时代，网络上流传的搞笑图片" title="&#39;上古&#39;时代，网络上流传的搞笑图片"></p><h3 id="sql-注入防范"><a href="#sql-注入防范" class="headerlink" title="sql 注入防范"></a>sql 注入防范</h3><ul><li>预编译sql</li></ul><p>预编译 sql 的原理：</p><ol><li>基本解析：包括SQL语句的语法、语义解析，以及对应的表和列是否存在等等。</li><li>编译：将 SQL 语句编译成机器理解客理解的中间代码格式。</li><li>查询优化：编译器在所有的执行方案中选择一个最优的。</li><li>缓存：缓存优化后的执行方案。</li><li>执行阶段：执行最终查询方案并返回给用户数据。</li></ol><p>预编译语句指的是在缓存之后，在执行阶段的之前的编译后的语句，通过占位符来替代查询查询参数。同样的SQL，如果参数不同普通的SQL语句每次请求都会进行编译，而预编译语句只会编译一次，在执行阶段会从缓存中取出预编译语句并将占位符替换成查询参数数据，而在这个阶段SQL 语句已经是编译后的语句，参数数据只能最为纯数据使用，不能作为SQL语句的一部分，通过SQL字符串的拼装已经不起作用，所以可以避免SQL注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String query = <span class="string">&quot;SELECT * FROM users WHERE username = ? AND password = ?&quot;</span>;</span><br><span class="line">PreparedStatement pstmt = connection.prepareStatement( query );</span><br><span class="line">pstmt.setString( <span class="number">1</span>, username);</span><br><span class="line">pstmt.setString( <span class="number">2</span>, password);</span><br><span class="line">ResultSet results = pstmt.executeQuery( );</span><br></pre></td></tr></table></figure><ul><li>交给 ORM 框架</li></ul><h3 id="hash-DoS-Denial-of-Service"><a href="#hash-DoS-Denial-of-Service" class="headerlink" title="hash DoS (Denial of Service)"></a>hash DoS (Denial of Service)</h3><p>我们都知道，哈希表 是一个 O(1) 的数据结构，对于其中的任意元素&#x3D;可以在一个与哈希表长度无关的时间内计算出一个哈希值（key），然后在常量时间内定位到一个bucket，找到改元素。</p><p>这是理想的情况，但是存在不同的数据项，具有相同的 hash 值，这是就会发生 hash 碰撞。</p><p>哈希表的实现需要解决碰撞问题，碰撞解决大体有两种思路，第一种是根据某种原则将被碰撞数据定为到其它桶，例如线性探测——如果数据在插入时发生了碰撞，则顺序查找这个桶后面的桶，将其放入第一个没有被使用的桶；第二种策略是每个桶不是一个只能容纳单个数据项的位置，而是一个可容纳多个数据的数据结构（例如链表或红黑树），所有碰撞的数据以某种数据结构的形式组织起来。</p><p>不论使用了哪种碰撞解决策略，都导致插入和查找操作的时间复杂度不再是 O(1)。以查找为例，不能通过key定位到桶就结束，必须还要比较原始key（即未做哈希之前的key）是否相等，如果不相等，则要使用与插入相同的算法继续查找，直到找到匹配的值或确认数据不在哈希表中。</p><p>哈希表碰撞攻击就是通过精心构造数据，使得所有数据全部碰撞，人为将哈希表变成一个退化的单链表，此时哈希表各种操作的时间均提升了一个数量级，因此会消耗大量CPU资源，导致系统无法快速响应请求，从而达到拒绝服务攻击（DoS）的目的。</p><p>web 应用 大多会使用json作为数据传递的方式，在服务端拿到 json 字符串后，都会将 json 字符串转换成 json 对象，json 对象大多都是基于 hashmap 或者 hashtable 做的，因此只要能够导致 hash 碰撞，然后结合一个较大的 json 对象，就能将 hashmap 的性能降低到极致，拖垮cpu，从而达到 DoS 的目的。</p><h2 id="DDoS"><a href="#DDoS" class="headerlink" title="DDoS"></a>DDoS</h2><h3 id="DDoS的概念和发展"><a href="#DDoS的概念和发展" class="headerlink" title="DDoS的概念和发展"></a>DDoS的概念和发展</h3><h4 id="拒绝服务"><a href="#拒绝服务" class="headerlink" title="拒绝服务"></a>拒绝服务</h4><p>其实可以简单理解为：让一个公开网站无法访问。要达到这个目的的方法也很简单：不断地提出服务请求，让合法用户的请求无法及时处理。</p><h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><p>其实随着网络发展，很多大型企业具备较强的服务提供能力，所以应付单个请求的攻击已经不是问题。道高一尺，魔高一丈，于是乎攻击者就组织很多同伙，同时提出服务请求，直到服务无法访问，这就叫“分布式”。但是在现实中，一般的攻击者无法组织各地伙伴协同“作战”，所以会使用“僵尸网络”来控制N多计算机进行攻击。</p><h4 id="僵尸网络-肉鸡"><a href="#僵尸网络-肉鸡" class="headerlink" title="僵尸网络 肉鸡"></a>僵尸网络 肉鸡</h4><p>就是数量庞大的僵尸程序(Bot)通过一定方式组合，出于恶意目的，采用一对多的方式进行控制的大型网络，也可以说是一种复合性攻击方式。因为僵尸主机的数量很大而且分布广泛，所以危害程度和防御难度都很大。</p><p>僵尸网络具备高可控性，控制者可以在发布指令之后，就断开与僵尸网络的连接，而控制指令会自动在僵尸程序间传播执行。</p><p>这就像个生态系统一样，对于安全研究人员来说，通过捕获一个节点可以发现此僵尸网络的许多僵尸主机，但很难窥其全貌，而且即便封杀一些僵尸主机，也不会影响整个僵尸网络的生存。</p><h3 id="DDoS的攻击方式"><a href="#DDoS的攻击方式" class="headerlink" title="DDoS的攻击方式"></a>DDoS的攻击方式</h3><p>分布式拒绝服务攻击的精髓是：利用分布式的客户端，向目标发起大量看上去合法的请求，消耗或者占用大量资源，从而达到拒绝服务的目的。</p><p>其主要攻击方法有4种：</p><ul><li>攻击带宽</li></ul><p>当网络数据包的数量达到或者超过上限的时候，会出现网络拥堵、响应缓慢的情况。DDoS就是利用这个原理，发送大量网络数据包，占满被攻击目标的全部带宽，从而造成正常请求失效，达到拒绝服务的目的。</p><p>攻击者可以使用ICM泛洪(即发送大量ICMP相关报文)、或者UDP泛洪(即发送用户数据报协议的大包或小包)，使用伪造源IP地址方式进行隐匿，并对网络造成拥堵和服务器响应速度变慢等影响。</p><p>但是这种直接方式通常依靠受控主机本身的网络性能，所以效果不是很好，还容易被查到攻击源头。于是反射攻击就出现，攻击者使用特殊的数据包，也就是IP地址指向作为反射器的服务器，源IP地址被伪造成攻击目标的IP，反射器接收到数据包的时候就被骗了，会将响应数据发送给被攻击目标，然后就会耗尽目标网络的带宽资源。</p><ul><li>攻击系统</li></ul><p>创建TCP连接需要客户端与服务器进行三次交互，也就是常说的“三次握手”。这个信息通常被保存在连接表结构中，但是表的大小有限，所以当超过了存储量，服务器就无法创建新的TCP连接了。</p><p>攻击者就是利用这一点，用受控主机建立大量恶意的TCP连接，占满被攻击目标的连接表，使其无法接受新的TCP连接请求。如果攻击者发送了大量的TCP SYN报文，使服务器在短时间内产生大量的半开连接，连接表也会被很快占满，导致无法建立新的TCP连接，这个方式是SYN洪水攻击，很多攻击者都比较常用。</p><ul><li>攻击应用</li></ul><p>由于DNS和Web服务的广泛性和重要性，这两种服务就成为了消耗应用资源的分布式拒绝服务攻击的主要目标。</p><p>比如向DNS服务器发送大量查询请求，从而达到拒绝服务的效果，如果每一个DNS解析请求所查询的域名都是不同的，那么就有效避开服务器缓存的解析记录，达到更好的资源消耗效果。当DNS服务的可用性受到威胁，互联网上大量的设备都会受到影响而无法正常使用。</p><p>近些年，Web技术发展非常迅速，如果攻击者利用大量的受控主机不断地向Web服务器恶意发送大量HTTP请求，要求Web服务器处理，就会完全占用服务器资源，让正常用户的Web访问请求得不到处理，导致拒绝服务。一旦Web服务受到这种攻击，就会对其承载的业务造成致命的影响。</p><ul><li>混合攻击</li></ul><p>在实际的生活中，乖哦概念记者并不关心自己使用的哪种攻击方法管用，只要能够达到目的，一般就会发动其所有的攻击手段，尽其所能的展开攻势。对于被攻击目标来说，需要面对不同的协议、不同资源的分布式拒绝服务攻击，分析、响应和处理的成本就会大大增加。</p><p>随着僵尸网络向着小型化的趋势发展，为降低攻击成本，有效隐藏攻击源，躲避安全设备，同时保证攻击效果，针对应用层的小流量慢速攻击已经逐步发展壮大起来。因此，从另一个角度来说，DDoS攻击方面目前主要是两个方面：UDP及反射式大流量高速攻击、和多协议小流量及慢速攻击。</p><h3 id="DDoS防范"><a href="#DDoS防范" class="headerlink" title="DDoS防范"></a>DDoS防范</h3><ol><li>高性能设备</li><li>提高带宽</li><li>异常流量清洗</li><li>分布式防御</li></ol>]]></content>
    
    
    <summary type="html">&lt;p&gt;安全涉及的领域很广泛，有 web 安全、DDoS 攻防、用户隐私、加密解密、数据安全、授权和认证等等，很多。&lt;/p&gt;
&lt;p&gt;可以逐一学习。&lt;/p&gt;
&lt;p&gt;今天我们主要讲一下 web 安全 顺带了解一下 DDoS 防范。（因为这个比较好找资料，准备的有些仓促。&lt;/p&gt;</summary>
    
    
    
    
    <category term="security" scheme="https://notes.yaohwu.xyz/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>耦合和聚合以及软件设计的一些理论知识</title>
    <link href="https://notes.yaohwu.xyz/2018/08/23/low-coupling-and-high-cohesion-and-others/"/>
    <id>https://notes.yaohwu.xyz/2018/08/23/low-coupling-and-high-cohesion-and-others/</id>
    <published>2018-08-23T07:50:25.000Z</published>
    <updated>2021-05-14T11:14:42.734Z</updated>
    
    <content type="html"><![CDATA[<p>模块的独立性很重要，因为有效的模块化(即具有独立的模块)的软件比较容易开发出来。<br>独立的模块比较容易测试和维护。模块的独立程度可以由两个定性标准度量，这两个标准分别称为内聚和耦合。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>评价设计质量的两个条件：聚合和耦合<br>内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。<br>内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。</p><p>好的设计，应该具有高聚合，低耦合的特点。</p><p>在面向对象的设计中，有很多设计模式可以促进聚合最大化的减少无需的耦合，诸如 MVC.</p><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p>如果一个实体执行的是一个单一的，定义明确的任务，和它有关的一切都是执行这个任务的必要条件，那么我们说这个实体是聚合的。</p><p>我们可以在实体上定义聚合，这个定义也可以延伸到类，向低层次延申可以到类中某个方法，向高层次延申可以到包，甚至更高层次的子系统，系统。</p><ol><li>好的设计目标就是每一个设计的实体都有最高可能的聚合。</li><li>一个聚合的实体功能，可以用简单的一句话来描述。</li></ol><h3 id="聚合分类"><a href="#聚合分类" class="headerlink" title="聚合分类"></a>聚合分类</h3><h4 id="理想的聚合"><a href="#理想的聚合" class="headerlink" title="理想的聚合"></a>理想的聚合</h4><ul><li>功能聚合</li></ul><p>实体执行的是单一的，定义明确的任务，无任何副作用。高聚合的方法应该是功能聚合的。</p><ul><li>信息内聚</li></ul><p>实体代表一组聚合的数据和在这些数据上独立的操作。高聚合的类应该是信息内聚的。</p><h4 id="次理想的聚合"><a href="#次理想的聚合" class="headerlink" title="次理想的聚合"></a>次理想的聚合</h4><ul><li>沟通的、连续的、程序性的聚合</li></ul><p>实体执行的是必须按照一定顺序执行的一系列任务。</p><ul><li>时间上的聚合</li></ul><p>实体执行的是必须在同一时间完成的任务，比如初始化操作，或者清理释放操作。</p><ul><li>逻辑上的聚合</li></ul><p>实体负责的是一组相关的任务，由调用方决定哪些任务被执行，一般定义多个实体或者使用多态。</p><ul><li>实用的聚合</li></ul><p>实体负责的是一组相关的任务，但也仅此而已。比如 java.util 包和 java.Math 类。这种次理想的聚合是不可避免的。他们会最“聚合”的情况也就如此了。</p><h4 id="不理想的聚合"><a href="#不理想的聚合" class="headerlink" title="不理想的聚合"></a>不理想的聚合</h4><p>实体负责的是一组无关的，只是因为巧合放在一起的任务。</p><h3 id="聚合改进"><a href="#聚合改进" class="headerlink" title="聚合改进"></a>聚合改进</h3><p>任何有更好聚合方案的实体，都应该被改进。</p><ul><li>整理实体功能，修改功能描述，依据功能描述开发功能。</li></ul><p>是不是能够用简单的一句话概括这个实体的功能(without and)，如果不能，尝试换用新的语言概括这个功能。</p><p>举例子：一个方法具有 下楼，骑车，坐地铁，到公司，打卡 等功能，概括为 去上班。</p><ul><li>拆分</li></ul><p>将一个低聚合的实体拆分成多个内部具有高聚合的实体。</p><p>举例子：一个方法具有 下楼，骑车，做地铁，到公司，到公园，打卡，自拍 等功能。拆分成两个，去上班 和 去游玩。</p><h2 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h2><p>耦合是对一个软件结构内不同模块之间互连程度的度量。耦合强弱取决于模块间接口的复杂程度，进入或访问一个模块的点，以及通过接口的数据。</p><p>系统的耦合程度取决于内部各个组件间的耦合程度。有些情况，耦合是必要的。我们需要做的就是去除不必要的耦合，这样对于系统的维护和修改就更容易。</p><h3 id="识别耦合"><a href="#识别耦合" class="headerlink" title="识别耦合"></a>识别耦合</h3><ol><li>A概括了或者实现了B</li><li>A通过方法依赖了B<ul><li>有局部变量B</li><li>有参数B</li><li>有返回值B</li></ul></li><li>两个结论<ul><li>重用A需要也重用B</li><li>修改B也需要修改A</li></ul></li><li>依赖是不可避免的，而且经常是必须的，要做的就是降低耦合避免复合修改（修改B也得修改A）</li></ol><h3 id="耦合缺点"><a href="#耦合缺点" class="headerlink" title="耦合缺点"></a>耦合缺点</h3><ol><li>一个模块的修改会产生涟漪效应，其他模块也需随之修改。</li><li>由于模块之间的依赖关系，模块的组合会需要更多的精力及时间。</li><li>由于一个模块依赖很多其他模块，模块的可复用性会降低。</li></ol><h3 id="耦合分类和改进"><a href="#耦合分类和改进" class="headerlink" title="耦合分类和改进"></a>耦合分类和改进</h3><p>模块耦合分为<strong>数据耦合、特征耦合、控制耦合、公共环境耦合、内容耦合</strong>。耦合程度由低到高。</p><h4 id="数据耦合"><a href="#数据耦合" class="headerlink" title="数据耦合"></a>数据耦合</h4><p>两个模块彼此间通过<strong>参数</strong>交换信息，而且交换的信息仅仅是数据（指的是单一的原子的数据片段），那么这种耦合称为数据耦合。数据耦合是低耦合。系统中至少必须存在这种耦合。这是不可避免的。</p><h4 id="特征耦合"><a href="#特征耦合" class="headerlink" title="特征耦合"></a>特征耦合</h4><p>当把整个数据结构作为参数、局部变量或者返回值，而被调用的模块只需要使用其中一部分数据元素时，就出现了特征耦合。</p><p>比如判断一个人是否成年，只需要传递该人的出生日期即可，不必要把人传进去。</p><p>因此这种耦合，通常是可以通过修改参数、局部变量或者返回值，只使用必要的数据元素来避免。</p><h4 id="控制耦合"><a href="#控制耦合" class="headerlink" title="控制耦合"></a>控制耦合</h4><p>传递的信息中有控制信息(尽管有时这种控制信息以数据的形式出现)，则这种耦合称为控制耦合。控制耦合是中等程度的耦合。</p><p>比如，传递的参数中包含一个枚举类型的参数，在方法的具体逻辑中判断该参数实现不同的功能。<br>那么，完全可以通过将一个方法修改为多个方法改进这种耦合。</p><h4 id="公共环境耦合"><a href="#公共环境耦合" class="headerlink" title="公共环境耦合"></a>公共环境耦合</h4><p>当两个或多个模块通过一个公共数据环境相互作用时，它们之间的耦合称为公共环境耦合。<br>公共环境可以是全程变量、共享的通信区、内存的公共覆盖区、任何存储介质上的文件、物理设备等。<br>公共环境耦合的复杂程度随耦合的模块个数而变化，当耦合的模块个数增加时复杂程度显著增加。</p><p>只有两个模块有公共环境，耦合有下面两种可能。</p><ol><li>一个模块往公共环境送数据，另一个模块从公共环境取数据。这是数据耦合的一种形式，是比较松散的耦合。</li><li>两个模块都既往公共环境送数据又从里面取数据，这种耦合比较紧密，介于数据耦合和控制耦合之间。</li></ol><p>限制范围，比如如果是依赖的是汇率，提供一个统一获汇率配置的方法，限制耦合范围。</p><h4 id="内容耦合"><a href="#内容耦合" class="headerlink" title="内容耦合"></a>内容耦合</h4><p>最高程度的耦合是内容耦合。如果出现下列情况之一，两个模块间就发生了内容耦合。</p><ol><li>一个模块访问另一个模块的内部数据。</li><li>一个模块不通过正常入口而转到另一个模块的内部。</li><li>两个模块有一部分程序代码重叠(只可能出现在汇编程序中)。</li><li>一个模块有多个入口(这意味着一个模块有几种功能)。</li></ol><p>应该坚决避免使用内容耦合，重构吧。</p><h3 id="耦合总结"><a href="#耦合总结" class="headerlink" title="耦合总结"></a>耦合总结</h3><p>总之，耦合是影响软件复杂程度的一个重要因素。<br>应该采取下述设计原则：<br><strong>尽量使用数据耦合，少用控制耦合和特征耦合，限制公共环境耦合的范围，完全不用内容耦合。</strong></p><h2 id="附录-一些软件设计的相关原则"><a href="#附录-一些软件设计的相关原则" class="headerlink" title="附录 一些软件设计的相关原则"></a>附录 一些软件设计的相关原则</h2><ul><li><a href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t Repeat Yourself(DRY)</a></li></ul><p>当在两个或多个地方发现一些相似的代码的时候，它们的共性抽象出来形成一个唯一的新方法，并且改变现有地方的代码让它们以一些合适的参数调用这个新的方。<br>可以说是在我们的软件开发中最常使用的原则，也最容易理解。<br>前端时间前端圈（JS圈？）还在围着这个做讨论<a href="https://zhuanlan.zhihu.com/p/35848291">我不是很懂 Node.js 社区的 DRY 文化</a>。</p><ul><li><a href="https://en.wikipedia.org/wiki/KISS_principle">Keep It Simple, Stupid(KISS)</a></li></ul><p>在界面、操作、交互设计上，简单的东西总比复杂的更容易让人接受。甚至从家装到商业风格，都有这样的实践。</p><ul><li>Program to an interface, not an implementation</li></ul><p>注重接口而不是实现，依赖接口而不是实现，是设计模式中最根本的哲学。</p><p>tip. 面向接口而不是实现，喜欢组合而不是继承 是 23个经典设计模式的设计原则</p><ul><li><a href="https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it">You Ain’t Gonna Need It (YAGNI)</a></li></ul><p>只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后需要更多功能时，可以再进行添加。软件开发是 <a href="https://en.wikipedia.org/wiki/Trade-off">trade-off</a> 的博弈。</p><ul><li><a href="https://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter(LoD)</a></li></ul><p>又称“最少知识原则”（Principle of Least Knowledge)</p><pre><code>More formally, the Law of Demeter for functions requires that a method m of an object O may only invoke the methods of the following kinds of objects:O itselfm&#39;s parametersAny objects created/instantiated within mO&#39;s direct component objectsA global variable, accessible by O, in the scope of m</code></pre><p>如果你想让你的狗跑的话，你会对狗说还是对四条狗腿说?<br><strong>use only one dot</strong></p><ul><li><p><a href="https://en.wikipedia.org/wiki/SOLID">面向对象的S.O.L.I.D 原则</a></p><ul><li>SRP Single responsibility principle 单一职责原则。一个类，只做一件事，并把这件事做好，其只有一个引起它变化的原因。单一职责原则可以看作是低耦合、高内聚在面向对象上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</li><li>OCP Open&#x2F;Closed Principle 开闭原则。模块是可扩展的而不可更改的，对扩展开放，如果新的需求或者变化，可以对代码进行扩展，以适应新的情况；对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，不要对类进行任何修改。</li><li>LSP Liskov Substitution Principle 里氏代换原则 Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program.</li><li>ISP Interface Segregation Principle 接口隔离原则 Many client-specific interfaces are better than one general-purpose interface.</li><li>DIP Dependency Inversion Principle 依赖倒置原则 depend upon abstractions, not concretions. 依赖于抽象而不是实现。</li></ul></li><li><p>CCP Common Closure Principle 共同封闭原则</p></li></ul><p>一个包中所有的类应该对同一种类型的变化关闭。一起修改的类，应该组合在一起（同一个包里）。扩展了 OCP 的“关闭”概念。</p><ul><li>CRP Common Reuse Principle 共同重用原则</li></ul><p>包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。没有被一起重用的类不应该组合在一起。</p><p>CCP 让包尽可能大（CCP 原则加入功能相关的类），CRP 则让包尽可能小（CRP 原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。</p><ul><li>好莱坞原则 Hollywood Principle</li></ul><p>“Don’t call us, we’ll call you.” 意思是，好莱坞的经纪人不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。</p><p>简单来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在：1) 不创建对象，而是描述创建对象的方式。2）在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。好莱坞原则就是IoC（Inversion of Control） 或DI（Dependency Injection）的基础原则。</p><ul><li>高内聚，低耦合 High Cohesion &amp; Low&#x2F;Loose coupling</li></ul><p>这个原则是 UNIX 操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。<br>内聚，指一个模块内各个元素彼此结合的紧密程度；耦合指一个软件结构内不同模块之间互连程度的度量。<br>内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。</p><ul><li>CoC (Convention over Configuration) 惯例优于配置原则</li></ul><p>简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。<br>前段时间的 maven 配置修改源码路径，以及一些 maven 本身的配置。</p><ul><li>SoC (Separation of Concerns) 关注点分离</li></ul><p>SoC 是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。</p><p>正如程序员的记忆力相对于计算机知识来说那么有限一样，程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。</p><p>就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按照标准来就一定能合得上。不断地把程序的某些部分抽象并包装起来，也是实现关注点分离的好方法。一旦一个函数被抽象出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的。同样的，一旦一个类被抽象并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。诸如组件、分层、面向服务等这些概念都是在不同的层次上做抽象和包装，以使得使用者不用关心它的内部实现细节。</p><ul><li>DbC（Design by Contract）契约式设计</li></ul><p>DbC 的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。</p><p>如果在程序设计中一个模块提供了某种功能，那么它要：</p><ol><li><p>期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。</p></li><li><p>保证退出时给出特定的属性：这就是模块的后验条件（供应商的义务，显然也是客户的权利）。</p></li><li><p>在进入时假定，并在退出时保持一些特定的属性：不变式。</p></li></ol><ul><li>ADP（Acyclic Dependencies Principle 无环依赖原则</li></ul><p>包（或服务）之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？</p><p>有两种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果 A、B、C 形成环路依赖，那么把这些共同类抽出来放在一个新的包 D 里。这样就把 C 依赖 A 变成了 C 依赖 D 以及 A 依赖 D，从而打破了循环依赖关系。第二种方法是使用 DIP（依赖倒置原则）和 ISP（接口分隔原则）设计原则。无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;模块的独立性很重要，因为有效的模块化(即具有独立的模块)的软件比较容易开发出来。&lt;br&gt;独立的模块比较容易测试和维护。模块的独立程度可以由两个定性标准度量，这两个标准分别称为内聚和耦合。&lt;/p&gt;</summary>
    
    
    
    
    <category term="design pattern" scheme="https://notes.yaohwu.xyz/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>从单元测试出发看前端和前端模块化</title>
    <link href="https://notes.yaohwu.xyz/2018/06/20/from%20unit%20test%20to%20front%20end%20modularization/"/>
    <id>https://notes.yaohwu.xyz/2018/06/20/from%20unit%20test%20to%20front%20end%20modularization/</id>
    <published>2018-06-20T10:02:00.000Z</published>
    <updated>2021-05-14T11:14:42.731Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>代码是为了什么，当然是为了重复运行。如何保持unit test代码的稳定？主要靠好的API设计。API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。以后你重构的时候，只要你的unit test覆盖的够好，基本跑一遍就知道有没有改成傻逼。可以节省大量的时间。所以那些专门写不需要维护的软件的人，讨厌测试，也是情有可原的。<br>作者：vczh<br>链接：<a href="https://www.zhihu.com/question/28729261/answer/94964928">https://www.zhihu.com/question/28729261/answer/94964928</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><span id="more"></span><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><blockquote><p>代码是为了什么，当然是为了重复运行。如何保持unit test代码的稳定？主要靠好的API设计。API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。以后你重构的时候，只要你的unit test覆盖的够好，基本跑一遍就知道有没有改成傻逼。可以节省大量的时间。所以那些专门写不需要维护的软件的人，讨厌测试，也是情有可原的。<br>作者：vczh<br>链接：<a href="https://www.zhihu.com/question/28729261/answer/94964928">https://www.zhihu.com/question/28729261/answer/94964928</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><p>由于我们一年之中，超过一半的时间都是在做软件维护工作，因此我们需要单元测试帮助提高效率节省时间。而且当去重构某些模块的时候，甚至可能帮助设计 API。</p><p>对于我们后端的 java 代码，之前也是有分享过，可以使用 <a href="https://yaohwu.xyz/#/posts/4">EasyMock 单元测试</a>去做，而且 10 之后单元测试也写的如火如荼。</p><p>那么对于前端代码，应该怎么写单元测试呢？</p><h2 id="前端原有的测试方案"><a href="#前端原有的测试方案" class="headerlink" title="前端原有的测试方案"></a>前端原有的测试方案</h2><h3 id="原有分类"><a href="#原有分类" class="headerlink" title="原有分类"></a>原有分类</h3><p>我们原有的前端测试大致分为两部分。</p><p>一部分是使用 <a href="http://qunitjs.com/">Qunit</a> 通过我们自身的 servlet 处理对于测试页面的请求，加载一些写的单元测试到浏览器执行然后结果展现到页面上。</p><p>另外一部分是使用 <a href="http://casperjs.org/">casperjs</a> 框架编写一些自动化脚本持续集成到 Jenkins 中，主要完成一些在浏览器端交互方面的测试。</p><p>其实这也说明了，在前端的代码中，我们要针对两种类型的代码做测试。</p><p>一种就是对应我们使用 Qunit 写的部分单元测试，大部分是针对一些和前端 UI 不耦合的代码，包括一些工具函数，以及一些抽象的代码，和 UI 不耦合。</p><p>另外一种就是和 UI 耦合非常严重的代码，应该是我们的大部分代码，使用 casperjs 框架去完成针对 ui 交互部分的测试。</p><h3 id="原有测试下的问题"><a href="#原有测试下的问题" class="headerlink" title="原有测试下的问题"></a>原有测试下的问题</h3><p>当前前端单元测试方案可能存在的问题。</p><ol><li>使用 Qunit 写的需要在浏览器端执行，难持续集成。PS.当然可以再通过 casperjs 去针对 Qunit 部分的测试再去写测试，麻烦。</li><li>使用 casperjs 做测试，我们需要做的工作比较多。又要做模板，又要写测试。</li><li>和 UI 的耦合迫使我们只能使用 casperjs 这种复杂的方案，而不能在服务端运行 js 完成测试。</li></ol><h3 id="如何解决这些问题"><a href="#如何解决这些问题" class="headerlink" title="如何解决这些问题"></a>如何解决这些问题</h3><ol><li>借助 nodejs，我们可以非常方便的将和 UI 不耦合的代码直接在服务端运行和测试。因为没有 ui 交互的部分，这些代码其实完全是 pure js 代码，和 server-side js 代码区别很小。(很小？)</li><li>使用 casperjs 写测试，是不是能够跳过做模板的这一步？</li><li>前端的代码能不能和 UI 降低耦合，方便使用更简单的方式去写单元测试，而不是使用 caspserjs。</li></ol><h2 id="新的测试方案"><a href="#新的测试方案" class="headerlink" title="新的测试方案"></a>新的测试方案</h2><h3 id="新分类"><a href="#新分类" class="headerlink" title="新分类"></a>新分类</h3><p>其实和原有的分类没有什么大的区别。我们在 旧分类中也解释了，前端代码中一部分是我们能够使用 nodejs 运行并测试的代码，另外一部分是借助浏览器去完成运行和测试的代码。</p><ol><li>能够直接借助 nodejs 运行和测试的部分。</li><li>想办法借助 nodejs 运行和测试的部分。</li></ol><p>不同于旧有测试方案分类的主要有三点：</p><ol><li>不再使用自身的 servlet 处理测试请求然后在浏览器执行测试；而是直接借助 nodejs 完成测试。</li><li>还是使用 casperjs 来完成耦合交互的前端代码测试，但是跳过模板制作，而是直接写脚本。</li><li>降低代码同交互部分不需要的耦合，使能够直接使用 nodejs 进行测试的代码所占比例提高。</li></ol><h3 id="直接借助-nodejs-运行的代码"><a href="#直接借助-nodejs-运行的代码" class="headerlink" title="直接借助 nodejs 运行的代码"></a>直接借助 nodejs 运行的代码</h3><p>其实我们原本使用的 <a href="http://qunitjs.com/">Qunit</a> 也提供了 nodejs 运行的版本。详细见官网。</p><p>完成安装配置之后，写一段 js 代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> QUnit = <span class="built_in">require</span>(<span class="string">&quot;qunit&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&quot;assert&quot;</span>);</span><br><span class="line"></span><br><span class="line">QUnit.test(<span class="string">&quot;hello test1&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">assert</span>) </span>&#123;</span><br><span class="line">    assert.ok(<span class="number">1</span> === <span class="number">1</span>, <span class="string">&quot;Passed!&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">QUnit.test(<span class="string">&quot;hello test2&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">assert</span>) </span>&#123;</span><br><span class="line">    assert.equal(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;failed!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用 qunit 提供的 cli 运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> qunit</span></span><br><span class="line">TAP version 13</span><br><span class="line">ok 1 hello test</span><br><span class="line">not ok 2 hello test</span><br><span class="line">  ---</span><br><span class="line">  message: &quot;failed!&quot;</span><br><span class="line">  severity: failed</span><br><span class="line">  actual: 1</span><br><span class="line">  expected: 2</span><br><span class="line">  stack:     at Object.&lt;anonymous&gt; (E:\release10.0\fine-js-test\test\use-qunit-test.js:10:12)</span><br><span class="line">    at runTest (E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1530:30)</span><br><span class="line">    at Test.run (E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1516:6)</span><br><span class="line">    at E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1737:12</span><br><span class="line">    at advanceTaskQueue (E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1129:6)</span><br><span class="line">    at advance (E:\release10.0\fine-js-test\node_modules\qunit\qunit\qunit.js:1110:4)</span><br><span class="line">  ...</span><br><span class="line">1..2</span><br><span class="line"><span class="meta">#</span><span class="bash"> pass 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> skip 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> todo 0</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> fail 1</span></span><br></pre></td></tr></table></figure><p>这是 qunit 提供的运行在 node 之上的测试方案。</p><p>既然我们原本就没有使用这种，并且 qunit 是比较老的框架了，和更流行的测试框架 mocha，它存在很多的缺点，诸如扩展性差，配置项复杂，异步测试复杂等。</p><p>因此我们可以直接使用更好的测试框架 <a href="https://mochajs.org/">mocha</a>。</p><p>这边主要分享一下 mocha。</p><h4 id="mocha"><a href="#mocha" class="headerlink" title="mocha"></a>mocha</h4><h5 id="接口类型INTERFACES"><a href="#接口类型INTERFACES" class="headerlink" title="接口类型INTERFACES"></a>接口类型INTERFACES</h5><p>mocha的测试接口类型指的是集中测试用例组织模式的选择。Mocha提供了BDD(Behavior Driven Development),TDD(Test Driven Development),Exports,QUnit和Require-style几种接口。</p><ul><li>BDD</li></ul><p>BDD测试提供了describe()，context()，it()，specify()，before()，after()，beforeEach()和afterEach()这几种函数。</p><p>context()是describe()的别名，二者的用法是一样的。最大的作用就是让测试的可读性更好，组织的更好。相似地，specify()是it()的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;Array&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Array before&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    after(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Array after&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    beforeEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Array before for each&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;Array after for each&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    describe(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        describe(<span class="string">&#x27;when not present&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            it(<span class="string">&#x27;should not throw an error&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">4</span>);</span><br><span class="line">                &#125;).should.not.throw();</span><br><span class="line">            &#125;);</span><br><span class="line">            it(<span class="string">&#x27;should return -1&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">4</span>).should.equal(-<span class="number">1</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        describe(<span class="string">&#x27;when present&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            it(<span class="string">&#x27;should return the index where the element first appears in the array&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">3</span>).should.equal(<span class="number">2</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>相应的执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Array before</span><br><span class="line">Array before for each</span><br><span class="line">Array after for each</span><br><span class="line">Array before for each</span><br><span class="line">Array after for each</span><br><span class="line">Array before for each</span><br><span class="line">Array after for each</span><br><span class="line">Array after</span><br></pre></td></tr></table></figure><ul><li>TDD</li></ul><p>TDD风格的测试提供了suite(), test(), suiteSetup(), suiteTeardown(), setup(), 和 teardown()这几个函数:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">suite(<span class="string">&#x27;Array&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    suiteSetup(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;suite set up&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    suiteTeardown(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;suite tear down&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    setup(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">    teardown(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    suite(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        test(<span class="string">&#x27;should return -1 when not present&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            assert.equal(-<span class="number">1</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].indexOf(<span class="number">4</span>));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">mocha --ui tdd test/use-mocha-test.js</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  Demo</span><br><span class="line">    test1</span><br><span class="line">      √ should equal</span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">Array before</span><br><span class="line">    #indexOf()</span><br><span class="line">      when not present</span><br><span class="line">Array before for each</span><br><span class="line">        √ should not throw an error</span><br><span class="line">Array after for each</span><br><span class="line">Array before for each</span><br><span class="line">        √ should return -1</span><br><span class="line">Array after for each</span><br><span class="line">      when present</span><br><span class="line">Array before for each</span><br><span class="line">        √ should return the index where the element first appears in the array</span><br><span class="line">Array after for each</span><br><span class="line">Array after</span><br><span class="line"></span><br><span class="line">  Array</span><br><span class="line">suite set up</span><br><span class="line">    #indexOf()</span><br><span class="line">      √ should return -1 when not present</span><br><span class="line">suite tear down</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  5 passing (15ms)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ps. mocha 默认使用 bdd 接口，如果想要更换接口类型，需要使用在 cli 中提供的 –ui 参数 <em>-u, –ui &lt;name&gt;                         specify user-interface (bdd|tdd|qunit|exports)</em></p><ul><li>EXPORTS</li></ul><p>EXPORTS 的写法有的类似于 Mocha 的前身 <a href="https://github.com/visionmedia/expresso">expresso</a> ，键 before, after, beforeEach, 和afterEach都具有特殊的含义。对象值对应的是测试集合，函数值对应的是测试用例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">before</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="string">&#x27;Array&#x27;</span>: &#123;</span><br><span class="line">    <span class="string">&#x27;#indexOf()&#x27;</span>: &#123;</span><br><span class="line">      <span class="string">&#x27;should return -1 when not present&#x27;</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">4</span>).should.equal(-<span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>QUNIT</li></ul><p>QUNIT 风格的测试像TDD 接口一样支持 suite 和 test 函数，同时又像 BDD 一样支持 before(), after(), beforeEach(), 和 afterEach()等 hook 函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*qunit*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>), assert = chai.assert, should = chai.should();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ok = assert.isOk;</span><br><span class="line"></span><br><span class="line">suite(<span class="string">&#x27;Array&#x27;</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;#length&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    ok(arr.length === <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    ok(arr.indexOf(<span class="number">1</span>) === <span class="number">1</span>);</span><br><span class="line">    ok(arr.indexOf(<span class="number">2</span>) === <span class="number">1</span>);</span><br><span class="line">    ok(arr.indexOf(<span class="number">3</span>) === <span class="number">2</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">suite(<span class="string">&#x27;String&#x27;</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;#length&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ok(<span class="string">&#x27;foo&#x27;</span>.length === <span class="number">3</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">suite(<span class="string">&quot;group a&quot;</span>);</span><br><span class="line">before(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;);</span><br><span class="line">afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;after&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&quot;a basic test example&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    assert.ok(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line">test(<span class="string">&quot;a basic test example 2&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ok(<span class="literal">true</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>REQUIRE</li></ul><p>REQUIRE 可以使用 require 方法引入 describe 等函数，同时，你可以为其设置一个别名。如果你不想在测试中出现全局变量，这个方法也是十分实用的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> testCase = <span class="built_in">require</span>(<span class="string">&#x27;mocha&#x27;</span>).describe;</span><br><span class="line"><span class="keyword">var</span> pre = <span class="built_in">require</span>(<span class="string">&#x27;mocha&#x27;</span>).before;</span><br><span class="line"><span class="keyword">var</span> assertions = <span class="built_in">require</span>(<span class="string">&#x27;mocha&#x27;</span>).it;</span><br><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>).assert;</span><br><span class="line"></span><br><span class="line">testCase(<span class="string">&#x27;Array&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pre(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    testCase(<span class="string">&#x27;#indexOf()&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        assertions(<span class="string">&#x27;should return -1 when not present&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            assert.equal([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].indexOf(<span class="number">4</span>), -<span class="number">1</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这种方案，是有bug的，详见 <a href="https://github.com/mochajs/mocha/issues/956">issues&#x2F;956</a>，一个比较旧的 bug 了，如果不使用 node_modules&#x2F;mocha&#x2F;bin&#x2F;mocha 执行这样的 js ，那么 <em>require(‘mocha’).describe</em>拿到是<em>undefined</em>。</p><h6 id="同步和异步SYNCHRONOUS-CODE-AND-ASYNCHRONOUS-CODE"><a href="#同步和异步SYNCHRONOUS-CODE-AND-ASYNCHRONOUS-CODE" class="headerlink" title="同步和异步SYNCHRONOUS CODE AND ASYNCHRONOUS CODE"></a>同步和异步SYNCHRONOUS CODE AND ASYNCHRONOUS CODE</h6><p>使用 mocha 测试异步代码是再简单不过了。只需要在测试完成的时候调用一下回调函数即可。通过添加一个回调函数(通常命名为 done)给 it() 方法，Mocha 就会知道，它应该等这个函数被调用的时候才能完成测试。hook 函数也是如此。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Demo = <span class="built_in">require</span>(<span class="string">&#x27;../../src/demo.js&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> chai = <span class="built_in">require</span>(<span class="string">&#x27;chai&#x27;</span>), assert = chai.assert, should = chai.should();</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&#x27;async test&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    before(<span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test before&#x27;</span>);</span><br><span class="line">        sucCallback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// some success method</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;test before save success&#x27;</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> d = <span class="keyword">new</span> Demo().save(sucCallback);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    afterEach(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;async test after each&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    it(<span class="string">&#x27;async test #save&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">done</span>) </span>&#123;</span><br><span class="line">        sucCallback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="comment">// some success method</span></span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;save success&#x27;</span>);</span><br><span class="line">            done();</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">var</span> d = <span class="keyword">new</span> Demo().save(sucCallback);</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="借助-nodejs-模仿在浏览器运行的代码"><a href="#借助-nodejs-模仿在浏览器运行的代码" class="headerlink" title="借助 nodejs 模仿在浏览器运行的代码"></a>借助 nodejs 模仿在浏览器运行的代码</h3><p>casperjs is a navigation scripting &amp; testing utility for the PhantomJS (WebKit) and SlimerJS (Gecko) headless browsers, written in Javascript.</p><p>casperjs 需要先安装 PhantomJS 或者 SlimerJS。通过 <a href="http://casperjs.org/">get start</a> 一步一步就可以。</p><p>demo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> casper = <span class="built_in">require</span>(<span class="string">&#x27;casper&#x27;</span>).create();</span><br><span class="line">casper.start(<span class="string">&#x27;http://casperjs.org/&#x27;</span>);</span><br><span class="line"></span><br><span class="line">casper.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.echo(<span class="string">&#x27;First Page: &#x27;</span> + <span class="built_in">this</span>.getTitle());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">casper.thenOpen(<span class="string">&#x27;http://phantomjs.org&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.echo(<span class="string">&#x27;Second Page: &#x27;</span> + <span class="built_in">this</span>.getTitle());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">casper.run();</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">casperjs test/casperjs.demo.js</span><br><span class="line"></span><br><span class="line">yaohw@yaohwu MINGW64 /e/release10.0/fine-js-test (master)</span><br><span class="line"><span class="meta">$</span><span class="bash"> First Page: CasperJS, a navigation scripting and testing utility <span class="keyword">for</span> PhantomJS and SlimerJS</span></span><br><span class="line">Second Page: PhantomJS - Scriptable Headless Browser</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>惨的是：PhantomJS 已经要逐渐没人维护了。<a href="http://www.itboth.com/d/eQbUv2/phantomjs">phantomJs之殇，chrome-headless之生</a></p><p><a href="https://karma-runner.github.io/2.0/index.html">karma</a></p><p>ps. 免去制作模板的步骤指的是，可以直接在 js 中去控制生成控件以及相关 dom , 只要请求到一个能够加载进来所需 完整 js 的地址就可以。</p><h3 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h3><p>js 的模块化。</p><p>之前vito 做过一个版本的模块化，但是主要解决的是加载finereport.js 的问题。</p><p>模块化内容比较多，我不懂得也很多，这次就不怎么分享了。</p><p>可以看一下：<a href="https://huangxuan.me/js-module-7day/#/">js-module-7day</a></p><h3 id="前端的问题"><a href="#前端的问题" class="headerlink" title="前端的问题"></a>前端的问题</h3><p>上次 vuejs 分享之后，我也在不断想这个事情，就是如何能让我们的前端跟上时代。</p><p>为了解决这个问题，我了解了一下我们的 js 代码是怎么加载到浏览器端的。</p><ul><li>我们自身的模块化</li></ul><p>其实我们自身本来就有自己的模块化。</p><p>我们不同的前端组件都是散落在不同的 js 文件中，这是一个非常显著的模块化倾向。</p><p>但是我们这些又不是真正的模块化，因为我们每一个 js 文件，单独拿到浏览器端是运行不了的。没有解决各个模块之前的依赖问题，在运行单个 js 文件的时候就会有各种undefined。</p><p>为了解决这个问题，我们将每个 js 文件在启动服务器的时候拼接起来，放在服务端的一个缓存里面，每次前端发送 op cmd 就从 缓存 中去读 js 代码字符串做响应。</p><p>ps：</p><ol><li>这个拼接 js 的启动耗时算不算问题？</li><li>无论采用何种优化，在高并发场景下，对于 js 等静态资源文件的请求会不会存在锁竞争。</li></ol><p>让我们的前端跟上时代的第一步是不是就是改变这种加载方式？</p><ul><li>从jar包里面拿出来</li></ul><p>引入 webpack？ 自己完成编译</p><p>最大化的放大前端模块化的优势，同时使得 ide 能够更好的帮助进行前端开发和维护<br>会不会 更加容易做单元测试？</p><ul><li>之前的 requirejs 模块化做了什么？</li></ul><p>Asynchronous Module Definition 实现异步加载</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;代码是为了什么，当然是为了重复运行。如何保持unit test代码的稳定？主要靠好的API设计。API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。以后你重构的时候，只要你的unit test覆盖的够好，基本跑一遍就知道有没有改成傻逼。可以节省大量的时间。所以那些专门写不需要维护的软件的人，讨厌测试，也是情有可原的。&lt;br&gt;作者：vczh&lt;br&gt;链接：&lt;a href=&quot;https://www.zhihu.com/question/28729261/answer/94964928&quot;&gt;https://www.zhihu.com/question/28729261/answer/94964928&lt;/a&gt;&lt;br&gt;来源：知乎&lt;br&gt;著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="unit-test" scheme="https://notes.yaohwu.xyz/tags/unit-test/"/>
    
    <category term="front-end" scheme="https://notes.yaohwu.xyz/tags/front-end/"/>
    
  </entry>
  
  <entry>
    <title>hibernate demo</title>
    <link href="https://notes.yaohwu.xyz/2018/05/01/hibernate-demo/"/>
    <id>https://notes.yaohwu.xyz/2018/05/01/hibernate-demo/</id>
    <published>2018-05-01T15:44:14.000Z</published>
    <updated>2021-05-14T11:14:42.732Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做远程设计，因为涉及到权限部分，所以看了看决策平台的代码，发现数据库操作都是用 hibernate，很成熟的技术了，但是我们之前的开发中可能用的很少，恰好之后可能会用，因此就炒炒冷饭，分享下这个，顺便理一下决策平台是怎么使用 hibernate 的。</p><span id="more"></span><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>对于 ORM(Object-Relational Mapping) 对象关系映射，相信大家或多或少都用过 ORM 的框架。</p><blockquote><p>面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象，对象关系映射技术应运而生。</p></blockquote><p>是将面向关系概念转化成面向对象概念的一种思想。</p><table><thead><tr><th align="center">面向对象概念</th><th align="center">面向关系概念</th></tr></thead><tbody><tr><td align="center">类</td><td align="center">表</td></tr><tr><td align="center">对象</td><td align="center">行(记录)</td></tr><tr><td align="center">属性</td><td align="center">列(字段)</td></tr></tbody></table><p>将 <strong>关系数据库</strong> 中表中的 <strong>记录</strong> 映射成为 <strong>对象</strong>，以对象的形式展现，可以将对数据库的操作转化为对对象的操作。</p><p>可以方便开发人员以面向对象的思想来实现对数据库的操作。</p><p>从思想上来说，当然是很方便，同一种面向对象的思想，简单不过弯子。但是从代码上来说，这个方便不方便也是看场景的。简单的demo 当然还是直接写 sql 更快。</p><h3 id="java的一些-ORM-框架"><a href="#java的一些-ORM-框架" class="headerlink" title="java的一些 ORM 框架"></a>java的一些 ORM 框架</h3><p>Hibernate,MyBatis 等。</p><p>稍后我们对这两个框架做一下对比。</p><h2 id="Hibernate-ORM"><a href="#Hibernate-ORM" class="headerlink" title="Hibernate ORM"></a>Hibernate ORM</h2><p><a href="https://zh.wikipedia.org/wiki/Hibernate">wikipedia 地址</a></p><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><p>我们先通过一个 demo 来了解一下 hibernate ORM。</p><p>搭环境，可以各种方式，无论是导入 jar包 或者 maven 创建，用 idea 在一个空项目上右键 添加框架 也可以。</p><ul><li>创建一个user表，有三个字段，分别是 id,username,password.</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> NAMES utf8mb4;</span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="comment">-- Table structure for user</span></span><br><span class="line"><span class="comment">-- ----------------------------</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>`  (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB AUTO_INCREMENT <span class="operator">=</span> <span class="number">5</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li>映射的实体类 User.java</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>User 类有三个属性，id,username,password 分别对应 User 表中的三个字段。</p><ul><li>创建映射文件User.hbm.xml。完成数据表到实体类的映射</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-mapping</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//Hibernate/Hibernate Mapping DTD 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span> <span class="attr">package</span>=<span class="string">&quot;xyz.yaohwu.entity&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">&quot;User&quot;</span> <span class="attr">table</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">&quot;native&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">column</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">column</span>=<span class="string">&quot;password&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指明映射关系。User 类对应 user 表，每种属性各自对应的字段。</p><ul><li>hibernate配置文件</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">hibernate-configuration</span> <span class="meta-keyword">PUBLIC</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;-//Hibernate/Hibernate Configuration DTD//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">&quot;http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.url&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;connection.driver_class&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.driver_class&quot;</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.url&quot;</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate_demo?useSSL=false<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.username&quot;</span>&gt;</span>yaohwu<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.connection.password&quot;</span>&gt;</span>******<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.dialect&quot;</span>&gt;</span>org.hibernate.dialect.MySQLDialect<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">&quot;xyz/yaohwu/entity/User.hbm.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一些数据库的基本配置和指明有哪些映射文件。更详细的配置可以参考<a href="https://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/Hibernate_User_Guide.html#configurations-database-connection">官方文档</a></p><ul><li>工具类，依据配置生成Session</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.HibernateException;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SessionFactory ourSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">            configuration.configure();</span><br><span class="line">            ourSessionFactory = configuration.buildSessionFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> HibernateException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ourSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编写 DAO 和其实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.entity.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> xyz.yaohwu.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.dao.UserDAO;</span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.entity.User;</span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.util.HibernateUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Session session = getSession()) &#123;</span><br><span class="line">            Transaction ts = session.beginTransaction();</span><br><span class="line">            session.save(user);</span><br><span class="line">            ts.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">findUserById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Session session = getSession()) &#123;</span><br><span class="line">            <span class="keyword">return</span> session.get(User.class, id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Session <span class="title">getSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> HibernateUtil.getSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>demo 测试一下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUsername(<span class="string">&quot;yaohwu&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;password&quot;</span>);</span><br><span class="line"></span><br><span class="line">        UserDAO dao = <span class="keyword">new</span> UserDAOImpl();</span><br><span class="line"></span><br><span class="line">        dao.save(user);</span><br><span class="line"></span><br><span class="line">        user = dao.findUserById(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;所查询ID的姓名是: &quot;</span> + user.getUsername());</span><br><span class="line">        &#125;</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是网上找到的非常简单的 hibernate demo，回顾一下关键的步骤就两点，一个是配置对象关系映射，二是依据配置文件生成Session供调用。</p><p>对于配置对象关系映射来说，我们上文中用到的是写配置文件的方式，hibernate 还提供了别的方式，比如使用 Java Persistence API 提供的注解方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.entity;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.UniqueConstraint;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaohwu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="meta">@Table(name = &quot;book&quot;, uniqueConstraints = &#123;</span></span><br><span class="line"><span class="meta">        @UniqueConstraint(columnNames = &#123;</span></span><br><span class="line"><span class="meta">                &quot;id&quot;,</span></span><br><span class="line"><span class="meta">                &quot;author&quot;</span></span><br><span class="line"><span class="meta">        &#125;)</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@Column(name = &quot;id&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column(name = &quot;author&quot;, nullable = false)</span></span><br><span class="line">    <span class="keyword">private</span> String author;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAuthor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> author;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.author = author;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">补充，即使属性并非基本数据类型，也可以进行配置[<span class="meta">@Convert</span>](https:<span class="comment">//docs.oracle.com/javaee/7/api/javax/persistence/Convert.html)。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>相应的配置文件 hibernate.cfg.xml 添加:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">class</span>=<span class="string">&quot;xyz.yaohwu.entity.Book&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>同样的，也可以不在 hibernate.cfg.xml 中写对象关系映射，而是更灵活的在创建 session 之前添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">            configuration.configure();</span><br><span class="line">            <span class="comment">// here</span></span><br><span class="line">            configuration.addResource(<span class="string">&quot;/xyz/yaohwu/entity/User.hbm.xml&quot;</span>);</span><br><span class="line">            configuration.addAnnotatedClass(Book.class);</span><br><span class="line">            ourSessionFactory = configuration.buildSessionFactory();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ExceptionInInitializerError(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过研究 org.hibernate.cfg.Configuration 类的源码，我们可以发现 hibernate 的配置是非常灵活的。hibernate.cfg.xml 中一些数据库的基本配置可以通过各种方式进行配置。</p><p>通过这个 demo，我们可以大致了解 hibernate 在这个应用中的架构：</p><p><img src="https://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/images/architecture/data_access_layers.svg" alt="Architecture"></p><p>上面就是完整的 demo 展示，我们新的决策平台就是通过这样的方式，完成对于内置数据的增删改查。</p><h3 id="处理复杂SQL的逻辑"><a href="#处理复杂SQL的逻辑" class="headerlink" title="处理复杂SQL的逻辑"></a>处理复杂SQL的逻辑</h3><p>实际应用场景中肯定不止是一个 findSomeById 这样的查询逻辑，因此我们需要在复杂 SQL 的时候有解决方案。</p><p>org.hibernate.Criteria 提供了灵活的 API。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">findBooksWrittenByAuthor</span><span class="params">(String author)</span> </span>&#123;</span><br><span class="line">        Criteria criteria = getSession().createCriteria(Book.class);</span><br><span class="line">        criteria.add(Restrictions.eq(<span class="string">&quot;author&quot;</span>, author));</span><br><span class="line">        criteria.setMaxResults(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> criteria.list();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>虽然</p><blockquote><p>This appendix covers the legacy Hibernate <strong>org.hibernate.Criteria</strong> API, which should be considered deprecated.New development should focus on the JPA <strong>javax.persistence.criteria.CriteriaQuery</strong> API. Eventually, Hibernate-specific criteria features will be ported as extensions to the JPA javax.persistence.criteria.CriteriaQuery.</p></blockquote><p>但，决策平台还是使用这种方案，进行了封装之后供业务逻辑调用。提供了诸多的方案供调用，具体 API 可以参考<a href="https://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/Hibernate_User_Guide.html#appendix-legacy-criteria">文档</a>。可以实现几乎所有的 sql 查询逻辑，非常的灵活。</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>鉴于 deprecated，我们这边再看一下 <strong>javax.persistence.criteria.CriteriaQuery</strong> 的查询方案，我发现一个 EntityManager，他是完全不同的两个架构设计。</p><p>EntityManager 是 hibernate 对于 JPA 中接口的实现。</p><p>javax.persistence.Persistence   给EntityManagerFactory的创建提供一种静态方法的启动类;<br>javax.persistence.EntityManagerFactory 相当于hibernate的SessionFactory;<br>javax.persistence.EntityManager 相当与hibernate的Session;<br>javax.persistence.Query 相当与hibernate的Query,跟hibernate使用hql一样，同样可以使用对象化的查询语言;<br>javax.persistence.EntityTransaction 相当于hibernate的Transaction;</p><p>hibernate ORM 可能未来会更注重对于 JPA 的实现。</p><p>通过 JPA API 和 Hibernate API 可以看一下 session 和 entitymanager 两者的关系。</p><p><img src="https://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/images/architecture/JPA_Hibernate.svg" alt="JPA API vs hibernate API"></p><p>看<a href="https://www.uml-diagrams.org/index-examples.html">这里</a> 解释一下 UML 图。 <a href="https://www.cnblogs.com/firstcsharp/p/5327659.html">或者</a>。</p><h2 id="和-mybatis-的对比"><a href="#和-mybatis-的对比" class="headerlink" title="和 mybatis 的对比"></a>和 mybatis 的对比</h2><p>再研究下 mybatis 之后再出吧。<br>比较的话，也没有深入研究，都是入门级别的了解，挖个坑，深入理解之后比较一下两者内部实现的不同。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.jboss.org/hibernate/orm/5.1/userguide/html_single/Hibernate_User_Guide.html">Hibernate_User_Guide</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在做远程设计，因为涉及到权限部分，所以看了看决策平台的代码，发现数据库操作都是用 hibernate，很成熟的技术了，但是我们之前的开发中可能用的很少，恰好之后可能会用，因此就炒炒冷饭，分享下这个，顺便理一下决策平台是怎么使用 hibernate 的。&lt;/p&gt;</summary>
    
    
    
    
    <category term="database" scheme="https://notes.yaohwu.xyz/tags/database/"/>
    
    <category term="orm" scheme="https://notes.yaohwu.xyz/tags/orm/"/>
    
    <category term="hibernate" scheme="https://notes.yaohwu.xyz/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个 RPC 框架</title>
    <link href="https://notes.yaohwu.xyz/2018/03/27/how-to-implement-an-RPC-framework/"/>
    <id>https://notes.yaohwu.xyz/2018/03/27/how-to-implement-an-RPC-framework/</id>
    <published>2018-03-27T07:33:23.000Z</published>
    <updated>2021-05-14T11:14:42.733Z</updated>
    
    <content type="html"><![CDATA[<p>上次分享会也提到过，Socket 是 Client-Server 网络中的基本组成部分，它个提供了一种相对简单的机制，让一个应用程序建立一个到另外一个应用程序的连接，来回发送消息。</p><p>后来，两位大佬设计了一种新的机制。<br>机器 A 上的一个进程可以调用在机器 B 上一个过程，当它这样做时，A 的进程被暂停执行，继续执行 B。当 B 返回时，返回值被传递给 A，A 继续执行，这种机制被称作 RPC。这个过程非常类似与本地调用，但是和本地调用又有着明显的区别。</p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一方面，在之前的分享会上，有人提过 rpc，我对这个也感兴趣，因为我完全不知道这个技术；<br>另外，数据挖掘还没什么显著的成果，不好意思分享。因此就趁着这个机会，学习一下 RPC。</p><h2 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a>什么是RPC</h2><p>上次分享会也提到过，Socket 是 Client-Server 网络中的基本组成部分，它个提供了一种相对简单的机制，让一个应用程序建立一个到另外一个应用程序的连接，来回发送消息。</p><p>后来，两位大佬设计了一种新的机制。<br>机器 A 上的一个进程可以调用在机器 B 上一个过程，当它这样做时，A 的进程被暂停执行，继续执行 B。当 B 返回时，返回值被传递给 A，A 继续执行，这种机制被称作 RPC。这个过程非常类似与本地调用，但是和本地调用又有着明显的区别。</p><p>RPC 是指远程过程调用。</p><p>如果两台服务器 A 和 B，部署在服务器 A 上的应用希望调用部署在服务器 B 上应用程序的函数，但是由于不能共享内存空间，不能直接调用，需要通过网络表达调用的语义和传达调用的数据。</p><p>RPC 在各大互联网公司中被广泛使用，如阿里巴巴的hsf、dubbo（开源）、Facebook的thrift（开源）、Google grpc（开源）、Twitter的finagle（开源）等等。</p><p>大致介绍了 RPC，接下来我们通过写一个简单的 RPC 框架来深入理解一下。在写之前，我们需要了解一下 RPC 的调用流程和通信细节。</p><h2 id="RPC-的调用流程和通信细节"><a href="#RPC-的调用流程和通信细节" class="headerlink" title="RPC 的调用流程和通信细节"></a>RPC 的调用流程和通信细节</h2><p>为了实现 RPC 的网络细节对使用者透明，我们需要对网络通信细节进行封装。先了解一下 RPC 调用的流程，以及有哪些通信细节。</p><p><img src="https://raw.githubusercontent.com/yaohwu/rpc-demo/master/resources/rpc-flow.png" alt="RPC flow"></p><ol><li>客户端以本地调用的方式调用一个服务；</li><li>client stub 接收到调用后将参数打包成一个甚至多个网络传输的消息体，打包过程需要编组和序列化数据。并将这些消息体交给给基于 socket 设计的通信接口；</li><li>通信接口通过协议（无连接或者面向连接的协议）传输这些消息体；</li><li>服务端或者远程接收到消息体后将消息体转交给 server stub；</li><li>server stub 反序列化参数，然后调用 “本地方法” server functions；</li><li>server functions 执行完后将结果返回给 server stub；</li><li>server stub 将结果打包成消息体，序列化，编组交给 server 端的通信接口；</li><li>客户端收到返回的结果后，将结果交给 client stub；</li><li>client stub 将结果解码，返回给调用方；</li><li>完成调用，得到结果。</li></ol><p>为了实现细节对使用者透明，RPC 就要将 2-9 的过程封装起来。</p><p>封装过程中要解决这些问题：</p><ol><li>通信的问题，在客户端和服务器直接建立连接，RPC 所有数据的交换都要在这个连接里面传输。可以按需连接，调用结束后就断开；也可以是长连接，多个远程调用共享一个连接。</li><li>寻址问题，A 服务器上的应用要让底层的 RPC 框架知道怎么调用到 B 服务器上的特定方法。</li><li>网络传输中的数据要进行序列化或者编组，接收到的数据要进行反序列化，恢复成为内存中的表达方式。</li></ol><p>问题1，建立连接，我们可以直接使用socket。<br>问题2，寻址方式，可以建立一个服务注册中心，将服务注册进来，保证可以调用。<br>问题3，序列化的方案更是非常多，Protobuf、Kryo、Hessian、Jackson 等，出于简单，我们使用 Java 默认的序列化。</p><h2 id="封装细节"><a href="#封装细节" class="headerlink" title="封装细节"></a>封装细节</h2><p>使用 Java 的 socket 来建立通信、默认的序列化方法实现序列化，服务注册中心可以先直接写死。</p><p>要让使用者像以本地调用方式调用远程服务，可以使用 java 的动态代理可以做到这一点。<br>关于动态代理的知识，可以看<a href="https://yaohwu.xyz/#/posts/4">mock 从动态代理到单元测试</a>;<br>动态代理可以有反射或者生成字节码来实现。</p><p>借助反射，实现动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Add delegate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddInvocationHandler</span><span class="params">(Add delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;add&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            Integer x = (Integer) args[<span class="number">0</span>];</span><br><span class="line">            Integer y = (Integer) args[<span class="number">1</span>];</span><br><span class="line">            System.out.print(<span class="string">&quot;x=&quot;</span> + x + <span class="string">&quot; y=&quot;</span> + y + <span class="string">&quot; result=&quot;</span>);</span><br><span class="line">            Integer result = delegate.add(x, y);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdderProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Add <span class="title">createAdderProxy</span><span class="params">(Add delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Add) Proxy.newProxyInstance(</span><br><span class="line">                delegate.getClass().getClassLoader(),</span><br><span class="line">                delegate.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> AddInvocationHandler(delegate));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者借用其他类库生成字节码，来实现动态代理。</p><p>出于简单，使用反射。</p><h3 id="编写服务接口"><a href="#编写服务接口" class="headerlink" title="编写服务接口"></a>编写服务接口</h3><p>类似于动态代理要求被代理的对象和代理类都实现同一个接口，远程调用和本地调用都应该实现一个共同的接口，例子中我们这样写这个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.provider.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * say</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word something</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">say</span><span class="params">(String word)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写服务接口的实现类"><a href="#编写服务接口的实现类" class="headerlink" title="编写服务接口的实现类"></a>编写服务接口的实现类</h3><p>编写一个服务端针对接口的实现类，供客户端调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.provider.service;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteHelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String words)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">&quot;hello, this is remote hello: &quot;</span> + words;</span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现一个-RPC-服务器"><a href="#实现一个-RPC-服务器" class="headerlink" title="实现一个 RPC 服务器"></a>实现一个 RPC 服务器</h3><p>大致接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.core.server;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动rpc服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 停止rpc服务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把服务注册进rpc</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name  name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">register</span><span class="params">(String name, Class clazz)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rpc 服务是否存活</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> isAlive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAlive</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体实现可以看代码。</p><h3 id="组装传输的消息实体"><a href="#组装传输的消息实体" class="headerlink" title="组装传输的消息实体"></a>组装传输的消息实体</h3><p>由于我们要使用 Java 默认提供的序列化，因此需要实现 Serializable 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcContext</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 接口名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] argumentTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] arguments;</span><br></pre></td></tr></table></figure><h3 id="实现-RPC-代理"><a href="#实现-RPC-代理" class="headerlink" title="实现 RPC 代理"></a>实现 RPC 代理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.core.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时等待时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TIMEOUT = <span class="number">10000L</span>;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; service;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程调用地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> InetSocketAddress remoteAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8989</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHandler</span><span class="params">(Class&lt;?&gt; service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object object, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//准备传输的对象</span></span><br><span class="line">        RpcContext rpcContext = <span class="keyword">new</span> RpcContext();</span><br><span class="line">        rpcContext.setService(service.getName());</span><br><span class="line">        rpcContext.setMethod(method.getName());</span><br><span class="line">        rpcContext.setArguments(args);</span><br><span class="line">        rpcContext.setArgumentTypes(method.getParameterTypes());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.request(rpcContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 远程调用请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcContext rpc 请求上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 调用结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException e</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">req</span><span class="params">(RpcContext rpcContext)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        ObjectInputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket = <span class="keyword">new</span> Socket(remoteAddress.getAddress(), remoteAddress.getPort());</span><br><span class="line">            os = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">            <span class="comment">// 直接使用 java 默认的对象序列化方式</span></span><br><span class="line">            os.writeObject(rpcContext);</span><br><span class="line">            <span class="comment">// 传输完毕</span></span><br><span class="line">            socket.shutdownOutput();</span><br><span class="line">            <span class="comment">// 阻塞等待服务器响应</span></span><br><span class="line">            is = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">            result = is.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            release(socket, os, is);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务注册和服务发现"><a href="#服务注册和服务发现" class="headerlink" title="服务注册和服务发现"></a>服务注册和服务发现</h3><p>出于简单的目的，就直接写死了（代码中有一个假的服务注册方案）。<br>主要要实现服务地址，端口，接口和方法名的注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo</span></span><br></pre></td></tr></table></figure><h3 id="运行demo"><a href="#运行demo" class="headerlink" title="运行demo"></a>运行demo</h3><p>启动 provider:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.provider;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.core.server.RpcServer;</span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.core.server.Server;</span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.provider.service.HelloService;</span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.provider.service.RemoteHelloServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        Server rpcServer = <span class="keyword">new</span> RpcServer(<span class="number">8989</span>, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;Cloud&quot;</span>, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">//暴露HelloService接口，具体实现为HelloServiceImpl</span></span><br><span class="line">        rpcServer.register(HelloService.class.getName(), RemoteHelloServiceImpl.class);</span><br><span class="line">        <span class="comment">//启动rpc服务</span></span><br><span class="line">        rpcServer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行 consumer:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.yaohwu.consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.core.proxy.RemoteServiceFactory;</span><br><span class="line"><span class="keyword">import</span> xyz.yaohwu.provider.service.HelloService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取动态代理的HelloService的“真实对象（其实内部不是真实的，被换成了调用远程方法）”</span></span><br><span class="line">        <span class="keyword">final</span> HelloService helloService = RemoteServiceFactory.newRemoteProxyObject(HelloService.class);</span><br><span class="line">        String result = helloService.say(<span class="string">&quot;demo&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;rpc result: &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>provider 日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RPC服务启动成功...</span><br><span class="line">执行一次响应..Tue Mar 27 15:16:21 CST 2018</span><br><span class="line">执行任务需要消耗：400 RpcContext&#123;service=&#x27;xyz.yaohwu.provider.service.HelloService&#x27;, method=&#x27;say&#x27;, argumentTypes=[class java.lang.String], arguments=[demo], localAddress=null, remoteAddress=null, timeout=10000&#125;</span><br><span class="line">hello, this is remote hello: demo</span><br></pre></td></tr></table></figure><p>consumer 日志：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc result: hello, this is remote hello: demo</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/yaohwu/rpc-demo/master/resources/RPC-module-dependencies.png" alt="rpc demo"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一个非常简单的 RPC 框架就完成了。<br>太过简单了，有很多的部分可以补充和完善。<br>例如，服务注册和发现，现在是完全没有实现，我们可以引入zookeeper来提供服务注册和发现，并且提供分布式支持。<br>在 demo 中，我们使用的是传统的阻塞式的 IO,可以替换成 NIO 去做高并发需求，或者进一步引入Netty。<br>序列化方面，可以替换更优秀的序列化框架，Protobuf、Kryo、Hessian、Jackson等，提供更优秀的性能。</p><h2 id="RPC-和-HTTP-的比较"><a href="#RPC-和-HTTP-的比较" class="headerlink" title="RPC 和 HTTP 的比较"></a>RPC 和 HTTP 的比较</h2><p>首先，RPC 和 HTTP 不是一个并行的概念。</p><p>RPC 远程过程调用，它的调用协议通常包含编码协议和传输协议。</p><h3 id="编码协议"><a href="#编码协议" class="headerlink" title="编码协议"></a>编码协议</h3><p>编码协议规定的是如何完成消息体对象和二进制之间的转换，也就是序列化和反序列化。<br>大多数 rpc 框架的编码协议都是可以选择的，甚至支持定制序列化方案。<br>http 的编码协议在一定程度上也是可以更换的，比如 http 也可以使用 protobuf 这种二进制编码协议对内容进行编码。</p><h3 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h3><p>传输协议指的是被转换成的二进制数据怎么在网络上传输，demo 中我们直接使用的 Socket，那么对应的协议应该是 TCP。<br>我们也可以使用 http 作为 RPC 的传输协议，<a href="https://grpc.io/">gRPC</a>使用传输协议是基于 http2 协议的，甚至也可以自定义 tcp 协议，dubbo 默认使用的就是自定义 tcp 协议。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>所以说，两个不是一个并行的概念。<br>从 rpc 希望达到的目的上来讲，可以说 http 是 rpc 的一种实现，然而 rpc 有着更强的语义， rpc 也可以使用 http 作为传输协议。</p><p>其实只要理解 rpc 的概念就可以，可定制性更强，可以更精简，保密。</p><h2 id="几种主流的-java-RPC-框架"><a href="#几种主流的-java-RPC-框架" class="headerlink" title="几种主流的 java RPC 框架"></a>几种主流的 java RPC 框架</h2><p>凑字数。</p><table><thead><tr><th>name</th><th>com</th><th>code address</th></tr></thead><tbody><tr><td>dubbo</td><td>alibaba,apache</td><td><a href="https://github.com/apache/incubator-dubbo">dubbo</a></td></tr><tr><td>motan</td><td>weibocom</td><td><a href="https://github.com/weibocom/motan">motan</a></td></tr><tr><td>thrift</td><td>facebook, apache</td><td><a href="https://thrift.apache.org/download">thrift</a></td></tr><tr><td>finagle</td><td>twitter</td><td><a href="https://github.com/twitter/finagle">finagle</a></td></tr><tr><td>Avro</td><td>apache</td><td><a href="https://github.com/apache/avro">Avro</a></td></tr><tr><td>grpc</td><td>google</td><td><a href="https://github.com/grpc/">grpc</a></td></tr><tr><td>hessian</td><td>caucho</td><td><a href="http://hessian.caucho.com/#Java">hessian</a></td></tr><tr><td>等等</td><td></td><td></td></tr></tbody></table><h3 id="dubbo"><a href="#dubbo" class="headerlink" title="dubbo"></a>dubbo</h3><p>Alibaba开源的分布式服务框架，功能强大，属于服务治理框架。支持多种注册中心，支持多种网络通信框架，支持多种传输协议，支持多种序列化方式。</p><p><img src="https://raw.githubusercontent.com/yaohwu/rpc-demo/master/resources/dubbo-relation.png" alt="dubbo-relation"><br><img src="https://raw.githubusercontent.com/yaohwu/rpc-demo/master/resources/dubbo-extension.png" alt="dubbo-extension"></p><h3 id="motan"><a href="#motan" class="headerlink" title="motan"></a>motan</h3><p>weibo开源的分布式服务框架，功能也很强，属于服务治理框架。主要模块都提供了多种不同的实现，例如支持多种注册中心，支持多种rpc协议等。<a href="https://github.com/weibocom/motan/wiki/zh_userguide">user guide</a></p><h3 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h3><p>由Fackbook开发的可伸缩、跨语言的服务开发框架，该框架已经开源并且加入的Apache项目。Thrift主要功能是：通过自定义的Interface Definition Language(IDL)，可以创建基于RPC的客户端和服务端的服务代码。数据和服务代码的生成是通过Thrift内置的代码生成器来实现的。Thrift 的跨语言性体现在，它可以生成C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, OCaml , Delphi等语言的代码，且它们之间可以进行透明的通信。</p><h3 id="Finagle"><a href="#Finagle" class="headerlink" title="Finagle"></a>Finagle</h3><p>Finagle是Twitter基于Netty开发的支持容错的、协议无关的RPC框架。也支持多种协议。Finagle  is written in Scala, but provides both Scala and Java idiomatic APIs.</p><h3 id="Avro"><a href="#Avro" class="headerlink" title="Avro"></a>Avro</h3><p>Avro是Hadoop中的一个子项目，也是Apache中一个独立的项目。主要用在Hadoop中。类似于Thrift，支持跨编程语言实现（C, C++, C#，Java, Python, Ruby, PHP）。用来支持数据密集型应用，适合于远程或本地大规模数据的存储和交换。</p><h3 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h3><p>由Google主导开发的RPC框架，使用HTTP&#x2F;2协议并用ProtoBuf作为序列化工具。</p><h3 id="hessian"><a href="#hessian" class="headerlink" title="hessian"></a>hessian</h3><h2 id="产品中的应用场景"><a href="#产品中的应用场景" class="headerlink" title="产品中的应用场景"></a>产品中的应用场景</h2><p>也不好说，RPC 是建立在服务调用的基础上的。</p><p>目前我们产品中的服务调用有哪些呢？</p><p>集群环境下的分发？也用不到，直接分发就好了。</p><p>集群环境下的事务一致性？也不能解决一致性的问题。</p><p>这方面能替代的也就只有 http，就看需不需要。</p><p>预览等用户直接使用的，这肯定走 http 了，没有什么疑问。</p><p>集群环境下的同步，嗯，好像可以走 rpc。不过还是需要解事务一致性问题。</p><p>远程设计问题，可以走 rpc。</p><p>与云中心的一些接口调用，例如发送短信等，可以走 rpc。</p><p>另外，我们可以暴露 rpc 接口，供客户进行第三方集成，应该也能算是一个业务方向。</p><p>场景还是有点儿，主要看替代 http 之后能不能有比较好的效果，安全性，性能等方面。</p><p>了解了一下 rpc，还是不错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// todo</span></span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cs.rutgers.edu/~pxk/417/notes/03-rpc.html">Remote Procedure Calls</a><br><a href="https://gitee.com/huangyong/rpc">轻量级分布式 RPC 框架</a><br><a href="https://github.com/anxpp/Java-IO">java io</a></p><h2 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h2><p><a href="https://github.com/yaohwu/rpc-demo">rpc-demo</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;上次分享会也提到过，Socket 是 Client-Server 网络中的基本组成部分，它个提供了一种相对简单的机制，让一个应用程序建立一个到另外一个应用程序的连接，来回发送消息。&lt;/p&gt;
&lt;p&gt;后来，两位大佬设计了一种新的机制。&lt;br&gt;机器 A 上的一个进程可以调用在机器 B 上一个过程，当它这样做时，A 的进程被暂停执行，继续执行 B。当 B 返回时，返回值被传递给 A，A 继续执行，这种机制被称作 RPC。这个过程非常类似与本地调用，但是和本地调用又有着明显的区别。&lt;/p&gt;</summary>
    
    
    
    
    <category term="rpc" scheme="https://notes.yaohwu.xyz/tags/rpc/"/>
    
  </entry>
  
  <entry>
    <title>Database Change Notification</title>
    <link href="https://notes.yaohwu.xyz/2018/02/03/database-change-notification/"/>
    <id>https://notes.yaohwu.xyz/2018/02/03/database-change-notification/</id>
    <published>2018-02-03T08:30:00.000Z</published>
    <updated>2021-05-14T11:14:42.731Z</updated>
    
    <content type="html"><![CDATA[<p>应用端对于数据变更通知是有着较多需求场景的，例如数据更新后的提醒、预警；web 端展现数据对于实时性的要求等。大部分产品对于数据库中数据变更信息的获取只能通过轮询的方式实现，轮询的时间间隔太短会有性能问题，太长会损害实时性。因此，考虑实现数据库中数据变更后主动向应用程序发送通知，针对不同的数据库都有哪些可用方案呢？</p><span id="more"></span><h2 id="Oracle-Database"><a href="#Oracle-Database" class="headerlink" title="Oracle Database"></a>Oracle Database</h2><p><a href="https://docs.oracle.com/cd/E11882_01/java.112/e16548/dbchgnf.htm#JJDBC28815">database change notification</a></p><h3 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h3><p>表级别的增、删或改通知，例如，针对数据库表 A 有变更通知， 那么 A 中发生的增、删或改 都会通知，不能具体到某个字段或者某条记录，需要在被通知端判断。</p><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="UDF-Trigger"><a href="#UDF-Trigger" class="headerlink" title="UDF + Trigger"></a>UDF + Trigger</h3><p>使用的是 MySQL 的用户自定义函数 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-function-udf.html">User-Defined Functions</a>；</p><p><code>A user-defined function (UDF) is a way to extend MySQL with a new function that works like a native (built-in) MySQL function such as ABS() or CONCAT().</code></p><p><code>For the UDF mechanism to work, functions must be written in C or C++ (or another language that can use C calling conventions), your operating system must support dynamic loading and you must have compiled mysqld dynamically (not statically).</code></p><p>UDF 是一种 MySQL 扩展，自定义一个类似原生内置的函数，可以被同样使用。为了能达到这样的效果，这种函数必须使用能被 C 语言调用的语言编写，并且编译成动态链接库。Linux 上是 .so 文件，Windows 上是 .dll 文件。</p><p>我们使用这个 <a href="https://github.com/y-ken/mysql-udf-http">mysql-udf-http</a> 来实现发送通知的效果，一个开源项目，8年多没人维护了。这是中文说明 <a href="http://zyan.cc/mysql-udf-http/">使用说明</a>。</p><p>我在 Ubuntu 上安装的 MySQL ，再编译这个东西 是可以成功使用的。Windows 上没有尝试，应该也可以，只不过编译起来稍微麻烦一些。</p><p>MySQL 的触发器 <a href="https://dev.mysql.com/doc/refman/5.7/en/create-trigger.html">create-trigger</a> 可以在 数据的增、删、改前后触发 trigger_body 的执行，可以执行多条 SQL 语句。</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Trigger</span></span><br><span class="line">String createTrigger =</span><br><span class="line">        <span class="string">&quot;CREATE TRIGGER test_update AFTER UPDATE ON `user` FOR EACH ROW &quot;</span> +</span><br><span class="line">                <span class="string">&quot;BEGIN &quot;</span> +</span><br><span class="line">                <span class="string">&quot;SET @tt_res = ( SELECT http_get ( &#x27;http://192.168.1.123:8099/WebReport/ReportServer?op=notification&amp;cmd=update&#x27; ) ); &quot;</span> +</span><br><span class="line">                <span class="string">&quot;END &quot;</span>;</span><br></pre></td></tr></table></figure><p>其实就是触发器触发一下我们自定义的函数，向指定的接口发送一个请求，通知到应用层面数据被修改、新增、删除。</p><h4 id="UDF-Trigger-适用范围"><a href="#UDF-Trigger-适用范围" class="headerlink" title="UDF+Trigger 适用范围"></a>UDF+Trigger 适用范围</h4><p>触发器针对的是表，每一行的变动都能被检测到；不能只监测指定字段的变动。<br>针对不同的平台，linux、windows 需要分别编译动态链接库，复制到MySQL插件文件夹下。<br>需要创建函数，创建触发器的权限。<br>如果数据变更非常频繁，那么会向指定的接口发送很多的请求，不知道web服务会不会挂。<br>触发器尽量简单只有一个，防止对数据库性能产生过多的影响。</p><p>表级别的增、删或改通知，例如，针对数据库表 A 有变更通知， 那么 A 中发生的增、删或改 都会通知，不能具体到某个字段或者某条记录，需要在被通知端判断。</p><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p><a href="https://www.jianshu.com/p/be3f62d4dce0">MySQL binlog 增量数据解析服务</a></p><p>数据库为了主从复制结构和容灾，都会有一份提交日志 (commit log)，通过解析这份日志，理论上说可以获取到每次数据库的数据更新操作。</p><p>以下皆以 MySQL 为例：</p><p>两种方式获取 MySQL bin-log 的方式：</p><ol><li>如果是同一台主机，那么直接使用获取本地文件即可解析；</li><li>如果是远程，那么可以通过 MySQL master 和 slave 的结构，伪装成一个 slave 来获取 master 的 bin-log 来解析。</li></ol><p>上面那篇文章介绍的比较复杂，是关于集群数据同步的解决方案，我们不需要那么复杂，只需要当数据发生变更时解析到变更通知到应用即可。</p><h4 id="协议解析方案"><a href="#协议解析方案" class="headerlink" title="协议解析方案"></a>协议解析方案</h4><p>时至今日， 已经有很多大厂开源了自己的 MySQL binlog 解析方案，Java 语言可选的有：</p><ol><li><a href="https://github.com/shyiko/mysql-binlog-connector-java">mysql-binlog-connector-java</a></li><li><a href="https://github.com/alibaba/canal">Canal</a></li><li><a href="https://github.com/dianping/puma">Puma</a></li></ol><p>想自己造轮子实现协议的，也可以参考 <a href="https://dev.mysql.com/doc/internals/en/replication-protocol.html">MySQL 官方文档</a></p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>一个使用 mysql-binlog-connector-java 的 demo。</p><ul><li>修改 MySQL 配置 my.cnf（Linux）或者my.ini（Windows）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">       log-bin=mysql-bin   //[必须]启用二进制日志</span><br><span class="line">       server-id=1      //[必须]服务器唯一ID，默认是1</span><br></pre></td></tr></table></figure><p>为了防止权限混乱，一般都是建立一个单独用于复制的账户。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create user rep;</span><br><span class="line">grant replication slave on *.* to rep identified by <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure><p>需重启数据库服务。</p><ul><li>Tapping into MySQL replication stream</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">BinaryLogClient client = <span class="keyword">new</span> BinaryLogClient(<span class="string">&quot;192.168.1.123&quot;</span>,</span><br><span class="line">            <span class="number">3306</span>,<span class="comment">//端口</span></span><br><span class="line">            <span class="string">&quot;yaohwu&quot;</span>,<span class="comment">//数据库</span></span><br><span class="line">            <span class="string">&quot;yaohwu&quot;</span>,<span class="comment">//用户名</span></span><br><span class="line">            <span class="string">&quot;*******&quot;</span>);<span class="comment">//密码</span></span><br><span class="line"></span><br><span class="line">    client.registerLifecycleListener(<span class="keyword">new</span> BinaryLogClient.AbstractLifecycleListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnect</span><span class="params">(BinaryLogClient client)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onConnect(client);</span><br><span class="line">            System.out.println(<span class="string">&quot;connect success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCommunicationFailure</span><span class="params">(BinaryLogClient client, Exception ex)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onCommunicationFailure(client, ex);</span><br><span class="line">            System.out.println(<span class="string">&quot;communication failure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEventDeserializationFailure</span><span class="params">(BinaryLogClient client, Exception ex)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onEventDeserializationFailure(client, ex);</span><br><span class="line">            System.out.println(<span class="string">&quot;event deserialize failure&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnect</span><span class="params">(BinaryLogClient client)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.onDisconnect(client);</span><br><span class="line">            System.out.println(<span class="string">&quot;disconnect success&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    client.registerEventListener(<span class="keyword">new</span> BinaryLogClient.EventListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(Event event)</span> </span>&#123;</span><br><span class="line">            System.out.println(event.getHeader().getEventType().name());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.connect();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">connect success</span><br><span class="line">二月 03, 2018 4:11:49 下午 com.github.shyiko.mysql.binlog.BinaryLogClient connect</span><br><span class="line">信息: Connected to 192.168.1.123:3306 at mysql-bin.000001/1444 (sid:65535, cid:9)</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=0, eventType=ROTATE, serverId=1, headerLength=19, dataLength=28, nextPosition=0, flags=32&#125;, data=RotateEventData&#123;binlogFilename=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, binlogPosition=1444&#125;&#125;</span><br><span class="line">ROTATE</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517626550000, eventType=FORMAT_DESCRIPTION, serverId=1, headerLength=19, dataLength=100, nextPosition=0, flags=0&#125;, data=FormatDescriptionEventData&#123;binlogVersion=4, serverVersion=<span class="string">&#x27;5.7.20-log&#x27;</span>, headerLength=19&#125;&#125;</span><br><span class="line">FORMAT_DESCRIPTION</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645538000, eventType=ANONYMOUS_GTID, serverId=1, headerLength=19, dataLength=46, nextPosition=1509, flags=0&#125;, data=null&#125;</span><br><span class="line">ANONYMOUS_GTID</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645538000, eventType=QUERY, serverId=1, headerLength=19, dataLength=55, nextPosition=1583, flags=8&#125;, data=QueryEventData&#123;threadId=6, executionTime=0, errorCode=0, database=<span class="string">&#x27;yaohwu&#x27;</span>, sql=<span class="string">&#x27;BEGIN&#x27;</span>&#125;&#125;</span><br><span class="line">QUERY</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645538000, eventType=TABLE_MAP, serverId=1, headerLength=19, dataLength=44, nextPosition=1646, flags=0&#125;, data=TableMapEventData&#123;tableId=245, database=<span class="string">&#x27;yaohwu&#x27;</span>, table=<span class="string">&#x27;user&#x27;</span>, columnTypes=15, 15, 15, 15, 15, columnMetadata=765, 765, 765, 765, 765, columnNullability=&#123;2, 3, 4&#125;&#125;&#125;</span><br><span class="line">TABLE_MAP</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645538000, eventType=EXT_WRITE_ROWS, serverId=1, headerLength=19, dataLength=32, nextPosition=1697, flags=0&#125;, data=WriteRowsEventData&#123;tableId=245, includedColumns=&#123;0, 1, 2, 3, 4&#125;, rows=[</span><br><span class="line">[1, 1, 1, 1, 1]</span><br><span class="line">]&#125;&#125;</span><br><span class="line">EXT_WRITE_ROWS</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645538000, eventType=XID, serverId=1, headerLength=19, dataLength=12, nextPosition=1728, flags=0&#125;, data=XidEventData&#123;xid=88&#125;&#125;</span><br><span class="line">XID</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645543000, eventType=ANONYMOUS_GTID, serverId=1, headerLength=19, dataLength=46, nextPosition=1793, flags=0&#125;, data=null&#125;</span><br><span class="line">ANONYMOUS_GTID</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645543000, eventType=QUERY, serverId=1, headerLength=19, dataLength=55, nextPosition=1867, flags=8&#125;, data=QueryEventData&#123;threadId=6, executionTime=0, errorCode=0, database=<span class="string">&#x27;yaohwu&#x27;</span>, sql=<span class="string">&#x27;BEGIN&#x27;</span>&#125;&#125;</span><br><span class="line">QUERY</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645543000, eventType=TABLE_MAP, serverId=1, headerLength=19, dataLength=44, nextPosition=1930, flags=0&#125;, data=TableMapEventData&#123;tableId=245, database=<span class="string">&#x27;yaohwu&#x27;</span>, table=<span class="string">&#x27;user&#x27;</span>, columnTypes=15, 15, 15, 15, 15, columnMetadata=765, 765, 765, 765, 765, columnNullability=&#123;2, 3, 4&#125;&#125;&#125;</span><br><span class="line">TABLE_MAP</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645543000, eventType=EXT_DELETE_ROWS, serverId=1, headerLength=19, dataLength=32, nextPosition=1981, flags=0&#125;, data=DeleteRowsEventData&#123;tableId=245, includedColumns=&#123;0, 1, 2, 3, 4&#125;, rows=[</span><br><span class="line">[1, 1, 1, 1, 1]</span><br><span class="line">]&#125;&#125;</span><br><span class="line">EXT_DELETE_ROWS</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645543000, eventType=XID, serverId=1, headerLength=19, dataLength=12, nextPosition=2012, flags=0&#125;, data=XidEventData&#123;xid=91&#125;&#125;</span><br><span class="line">XID</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645554000, eventType=ANONYMOUS_GTID, serverId=1, headerLength=19, dataLength=46, nextPosition=2077, flags=0&#125;, data=null&#125;</span><br><span class="line">ANONYMOUS_GTID</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645554000, eventType=QUERY, serverId=1, headerLength=19, dataLength=55, nextPosition=2151, flags=8&#125;, data=QueryEventData&#123;threadId=6, executionTime=0, errorCode=0, database=<span class="string">&#x27;yaohwu&#x27;</span>, sql=<span class="string">&#x27;BEGIN&#x27;</span>&#125;&#125;</span><br><span class="line">QUERY</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645554000, eventType=TABLE_MAP, serverId=1, headerLength=19, dataLength=44, nextPosition=2214, flags=0&#125;, data=TableMapEventData&#123;tableId=245, database=<span class="string">&#x27;yaohwu&#x27;</span>, table=<span class="string">&#x27;user&#x27;</span>, columnTypes=15, 15, 15, 15, 15, columnMetadata=765, 765, 765, 765, 765, columnNullability=&#123;2, 3, 4&#125;&#125;&#125;</span><br><span class="line">TABLE_MAP</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645554000, eventType=EXT_UPDATE_ROWS, serverId=1, headerLength=19, dataLength=129, nextPosition=2362, flags=0&#125;, data=UpdateRowsEventData&#123;tableId=245, includedColumnsBeforeUpdate=&#123;0, 1, 2, 3, 4&#125;, includedColumns=&#123;0, 1, 2, 3, 4&#125;, rows=[</span><br><span class="line">&#123;before=[yaohwu, ......, 13771717626, Software Engineer, China], after=[yaohwu, ......, 13771717629, Software Engineer, China]&#125;</span><br><span class="line">]&#125;&#125;</span><br><span class="line">EXT_UPDATE_ROWS</span><br><span class="line">Event&#123;header=EventHeaderV4&#123;timestamp=1517645554000, eventType=XID, serverId=1, headerLength=19, dataLength=12, nextPosition=2393, flags=0&#125;, data=XidEventData&#123;xid=93&#125;&#125;</span><br><span class="line">XID</span><br><span class="line">communication failure</span><br><span class="line">disconnect success</span><br></pre></td></tr></table></figure><h3 id="Binlog-适用范围"><a href="#Binlog-适用范围" class="headerlink" title="Binlog 适用范围"></a>Binlog 适用范围</h3><ol><li>监控整个数据库，不针对单个表或者字段，需要自己在代码中判断；</li><li>删除、修改、添加都能够监听到。<br>大部分数据库变更通知都是基于数据库同步服务的，因此最细的角度就是表级别，不能到具体的字段或者记录，需要在被同步端也就是被通知端自行判断。</li></ol><h2 id="扩展方案"><a href="#扩展方案" class="headerlink" title="扩展方案"></a>扩展方案</h2><p><a href="https://github.com/debezium/debezium">debezium</a></p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><p><a href="https://my.oschina.net/guol/blog/100179">MySql 主从复制及配置实现</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;应用端对于数据变更通知是有着较多需求场景的，例如数据更新后的提醒、预警；web 端展现数据对于实时性的要求等。大部分产品对于数据库中数据变更信息的获取只能通过轮询的方式实现，轮询的时间间隔太短会有性能问题，太长会损害实时性。因此，考虑实现数据库中数据变更后主动向应用程序发送通知，针对不同的数据库都有哪些可用方案呢？&lt;/p&gt;</summary>
    
    
    
    
    <category term="database" scheme="https://notes.yaohwu.xyz/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>mock-test 1 从动态代理到单元测试</title>
    <link href="https://notes.yaohwu.xyz/2018/01/24/mock-test-1-from%20dynamic%20proxy%20to%20unit%20test/"/>
    <id>https://notes.yaohwu.xyz/2018/01/24/mock-test-1-from%20dynamic%20proxy%20to%20unit%20test/</id>
    <published>2018-01-24T15:13:51.000Z</published>
    <updated>2021-05-14T11:14:42.734Z</updated>
    
    <content type="html"><![CDATA[<p>单元测试目的是针对应用中某些模块进行功能验证。<br>但是在单元测试中我们可能会遇到一些问题:</p><ol><li>其他的协同模块没有开发完，单元测试进行不下去</li><li>被测试模块需要和一些不容易构造、比较复杂的对象进行交互，测试和测试边界很难划分</li><li>不能肯定其它模块的正确性，无法准确的定位问题</li></ol><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>单元测试目的是针对应用中某些模块进行功能验证。<br>但是在单元测试中我们可能会遇到一些问题:</p><ol><li>其他的协同模块没有开发完，单元测试进行不下去</li><li>被测试模块需要和一些不容易构造、比较复杂的对象进行交互，测试和测试边界很难划分</li><li>不能肯定其它模块的正确性，无法准确的定位问题</li></ol><p>情况1，我们这边很少会遇到，最好是能够测试驱动。<br>情况2，这种现象非常多，比如 actionCMD 的方法的测试就需要构造 HttpServletRequest 和HttpServletResponse 对象，或者说其他的诸如 Calculator 等复杂对象。<br>情况3，由于我们的部分代码耦合很严重，因此这类情况也很普遍。</p><p>我们需要构造一种稳定的对象，简单，内部逻辑都对，能和被测试模块完成配合，形成一个孤立的测试环境。打桩，篱笆。</p><p>我们先来看一种最简单的测试。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>我们有一个计算器 Calculator 类，里面依赖了一个 int 计算模块的加法器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Add adder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do something special</span></span><br><span class="line">        <span class="keyword">return</span> adder.add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdder</span><span class="params">(Add adder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adder = adder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算x+y</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> x+y</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>加法器 Add 的实现在别的模块中，在 Calculator 类中我们只是调用了 Add 的接口。</p><p>现在我们想对 Calculator 类进行测试，不想因为Add实现的错误或者别的因素影响我们针对 Calculator 的测试。</p><h3 id="普通测试方案"><a href="#普通测试方案" class="headerlink" title="普通测试方案"></a>普通测试方案</h3><p>一般的情况下，我们要针对这个做测试，就只能去实现一下 Add 接口，确定 Add 的内部实现是正确的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="comment">//给一个Add的实现类</span></span><br><span class="line">    calculator.setAdder(<span class="keyword">new</span> Add() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> x + y;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    assertEquals(<span class="number">3</span>, calculator.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做就会有遇到问题的风险，一个是例子中的 Add 接口比较简单，容易构造，如果是复杂的对象，比如我们前面说到的 HttpServletRequest，就会非常麻烦；<br>其次是我们还要保证Add实现的逻辑得是完全正确的，针对一个 Calculator 的测试变成了针对 Calculator 测试并实现一个 Add 并对该 Add 实现进行测试。</p><p>因此一般我们不采用这种方案，付出的成本很大效果又不好。<br>因为我们不关心 Add 的实现，那么如果我们在Add内部方法调用之前就返回一个指定的值不就好了么。我们可以借助代理模式来实现这种方案。</p><h3 id="静态代理测试方案"><a href="#静态代理测试方案" class="headerlink" title="静态代理测试方案"></a>静态代理测试方案</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式是为其他对象提供一种代理以便控制对这个对象的访问。</p><p>可以详细控制访问某个类的方法，可以在调用被代理对象的方法前做一些前置处理，<br>在调用被代理对象的方法后做一些后置处理。</p><p>比如 明星的经纪人（滑稽）。</p><p>假设我们有一个 Add 接口的默认实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdder</span> <span class="keyword">implements</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在我想有一个加法器，可以在打印出加数和被加数，以及在计算结束后打印出结果。这种需求就包含了前置处理和后置处理，利用代理模式我们可以这样实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdderProxy</span> <span class="keyword">implements</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DefaultAdder defaultAdder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DefaultAdderProxy</span><span class="params">(DefaultAdder defaultAdder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultAdder = defaultAdder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//do before</span></span><br><span class="line">        System.out.print(<span class="string">&quot;x: &quot;</span> + x + <span class="string">&quot; y: &quot;</span> + y + <span class="string">&quot;= &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> result = defaultAdder.add(x, y);</span><br><span class="line">        <span class="comment">//do after</span></span><br><span class="line">        System.out.println(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中就包括了静态代理模式一般会包含的三个角色：</p><ol><li>抽象角色：Add 接口</li><li>真实角色：DefaultAdder 类</li><li>代理角色：DefaultAdderProxy 类</li></ol><p>这只是一个静态代理，这个代理 DefaultAdderProxy 类是需要我们自己编码的。</p><p>基于这种方式，我们可以给出一个静态代理测试方案。</p><p>首先我们得实现一个代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdderProxyForTest</span> <span class="keyword">implements</span> <span class="title">Add</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Add adder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdderProxyForTest</span><span class="params">(Add adder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adder = adder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span> &amp;&amp; y == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adder.add(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useStaticProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AdderProxyForTest adderProxyForTest = <span class="keyword">new</span> AdderProxyForTest(<span class="keyword">new</span> Add() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//随意写，因为我们是用来测试的，注定走不到被代理类的方法。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    calculator.setAdder(adderProxyForTest);</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">3</span>, calculator.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做确实可以不顾及 Add 内部是如何实现的了，上面那个“随意写”的注释也说明了这一点，但是这样你还是得去构造一个复杂的对象，只不过完全可以不再用仔细的去实现其内部方法，同时还得自己去实现一个代理类。麻烦程度还是不小。</p><h3 id="动态代理测试方案"><a href="#动态代理测试方案" class="headerlink" title="动态代理测试方案"></a>动态代理测试方案</h3><p>上面说了静态代理，在测试的时候需要自己去构建代理类。我们可以使用动态代理来避免这个麻烦。</p><p>动态代理通过代码生成代理类，可以使用 java 原生的动态代理，也可以使用 javaassist 或者 cglib 等类库实现这样的操作。</p><p>还是原来的需求，在计算前打印加数和被加数，在计算后打印结果。</p><p>由于无法直接定义代理类，我们需要借助 java.lang.reflect.InvocationHandler 来定义我们需要的代理行为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Add delegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AddInvocationHandler</span><span class="params">(Add delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delegate = delegate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;add&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            Integer x = (Integer) args[<span class="number">0</span>];</span><br><span class="line">            Integer y = (Integer) args[<span class="number">1</span>];</span><br><span class="line">            System.out.print(<span class="string">&quot;x=&quot;</span> + x + <span class="string">&quot; y=&quot;</span> + y + <span class="string">&quot; result=&quot;</span>);</span><br><span class="line">            Integer result = delegate.add(x, y);</span><br><span class="line">            System.out.println(result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(delegate, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个工厂来生成代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> yaoh.wu</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdderProxyFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Add <span class="title">createAdderProxy</span><span class="params">(Add delegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Add) Proxy.newProxyInstance(</span><br><span class="line">                delegate.getClass().getClassLoader(),</span><br><span class="line">                delegate.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> AddInvocationHandler(delegate));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这样使用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Add adder = AdderProxyFactory.createAdderProxy(<span class="keyword">new</span> DefaultAdder());</span><br><span class="line">        adder.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>好了，我们可以使用动态代理的方式进行测试，在使用之前，我们可以完善一下功能使其更加易用。<br>比如说，我想自定义调用哪些方法（我们的例子中 Add 接口就只有一个方法），方法的参数，方法的返回值或者抛出的异常；我想在测试最终验证方法的调用的种类，顺序，次数等。</p><p>完全可以自己造轮子了。</p><p>太麻烦了，理是这个理，我也写不出来，写出来也很容易出错。</p><p>我们还是引进轮子吧，哦，我们内部已经引进过了，EasyMock.</p><h3 id="EasyMock测试方案"><a href="#EasyMock测试方案" class="headerlink" title="EasyMock测试方案"></a>EasyMock测试方案</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>EasyMock 是一套用于通过简单的方法对于给定的接口生成 Mock 对象的类库。它提供对接口的模拟，能够通过录制、回放、检查三步来完成大体的测试过程，可以验证方法的调用种类、次数、顺序，可以令 Mock 对象返回指定的值或抛出指定异常。通过 EasyMock，我们可以方便的构造 Mock 对象从而使单元测试顺利进行。</p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>开源的 github 地址：<a href="https://github.com/easymock/easymock">EasyMock</a></p><h4 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h4><p>用 easymock 来进行单元测试大致有几个步骤：</p><ol><li>使用 EasyMock 生成 Mock 对象；</li><li>设定Mock对象的预期行为和输出；&#x2F;&#x2F;录制</li><li>将 Mock 对象切换为 replay 状态；&#x2F;&#x2F;回放</li><li>使用 Mock 对象进行单元测试；</li><li>对 Mock 对象行为进行验证。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用Mock的测试方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useMock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Calculator calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    <span class="comment">//创建Mock对象</span></span><br><span class="line">    Add adder = createMock(Add.class);</span><br><span class="line">    calculator.setAdder(adder);</span><br><span class="line">    <span class="comment">//录制</span></span><br><span class="line">    expect(adder.add(<span class="number">1</span>, <span class="number">2</span>)).andReturn(<span class="number">3</span>).anyTimes();</span><br><span class="line">    <span class="comment">//切换为回放状态</span></span><br><span class="line">    replay(adder);</span><br><span class="line">    <span class="comment">//进行单元测试</span></span><br><span class="line">    assertEquals(<span class="number">3</span>, calculator.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">    <span class="comment">//验证Mock对象调用</span></span><br><span class="line">    verify(adder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="详细"><a href="#详细" class="headerlink" title="详细"></a>详细</h3><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>上面的例子中我们使用了静态方法 <code>EasyMock#createMock()</code> 来创建的对象,其实他是通过 <code>createControl().createMock(toMock)</code>来实现的，先创建一个MocksControl对象用于管理 Mock 对象，然后在调用createMock() 方法生成一个动态代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">createMock</span><span class="params">(String name, Class&lt;T&gt; toMock, ConstructorArgs constructorArgs,</span></span></span><br><span class="line"><span class="params"><span class="function">            Method... mockedMethods)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (toMock.isInterface() &amp;&amp; mockedMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Partial mocking doesn&#x27;t make sense for interface&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            state.assertRecordState();</span><br><span class="line">            IProxyFactory proxyFactory = toMock.isInterface()</span><br><span class="line">                    ? interfaceProxyFactory</span><br><span class="line">                    : getClassProxyFactory();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//实际上也是一个动态代理</span></span><br><span class="line">                <span class="keyword">return</span> proxyFactory.createProxy(toMock, <span class="keyword">new</span> ObjectMethodsFilter(toMock,</span><br><span class="line">                        <span class="keyword">new</span> MockInvocationHandler(<span class="keyword">this</span>), name), mockedMethods, constructorArgs);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">                <span class="keyword">if</span>(e.getMessage().startsWith(<span class="string">&quot;org/objenesis&quot;</span>)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeExceptionWrapper(<span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">&quot;Class mocking requires to have Objenesis library in the classpath&quot;</span>, e));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeExceptionWrapper e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> (RuntimeException) e.getRuntimeException().fillInStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>所以说，我们在创建Mock对象的时候，也可以自己先建立一个MocksControl来管理，然后再创建Mock对象。<code>EasyMock#createMock()</code>只不过是使用了一个默认的Control。</p><h4 id="录制行为"><a href="#录制行为" class="headerlink" title="录制行为"></a>录制行为</h4><p>Mock对象有两种状态，一种是 Record，一种是 Replay。<br>当Mock对象被创建后会自动进入 Record 状态，这时候我们可以对他的行为进行定义。</p><p>定义行为大致分为三步：</p><ol><li>对 Mock 对象的特定方法作出调用；</li><li>通过 org.easymock.EasyMock 提供的静态方法 expectLastCall 获取上一次方法调用所对应的 IExpectationSetters 实例；</li><li>通过 IExpectationSetters 实例设定 Mock 对象的预期输出。</li></ol><p>这里的源码我没有看懂，IExpectationSetters 这个写法很神奇。<br>好像每一次调用都被放在ThreadLocal里面，调用之后我就可以拿到对应的调用的方法和参数列表，然后我就可以在当前状态针对这个方法和参数列表去自定义返回值。</p><p>EasyMock 在对参数值进行匹配时，默认采用 Object.equals() 方法。</p><h5 id="设定预期返回值"><a href="#设定预期返回值" class="headerlink" title="设定预期返回值"></a>设定预期返回值</h5><p>Mock 对象的行为可以简单的理解为 Mock 对象方法的调用和方法调用所产生的输出。对 Mock 对象行为的添加和设置是通过接口 IExpectationSetters 来实现的。Mock 对象方法的调用可能产生两种类型的输出：（1）产生返回值；（2）抛出异常。接口 IExpectationSetters 提供了多种设定预期输出的方法，其中和设定返回值相对应的是 andReturn 方法：</p><p><code>IExpectationSetters&lt;T&gt; andReturn(T value);</code></p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">adder.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">expectLastCall().andReturn(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//相当于</span></span><br><span class="line">expect(adder.add(<span class="number">1</span>, <span class="number">2</span>)).andReturn(<span class="number">3</span>)；</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以设定一个默认返回值。</p><p><code>void andStubReturn(Object value);</code></p><h5 id="设定预期抛出的异常"><a href="#设定预期抛出的异常" class="headerlink" title="设定预期抛出的异常"></a>设定预期抛出的异常</h5><p><code>IExpectationSetters&lt;T&gt; andThrow(Throwable throwable);</code><br><code>void andStubThrow(Throwable throwable);</code></p><h5 id="设定预期方法的调用次数"><a href="#设定预期方法的调用次数" class="headerlink" title="设定预期方法的调用次数"></a>设定预期方法的调用次数</h5><p>常用的设置调用次数的：</p><p><code>IExpectationSetters&lt;T&gt;times(int count);</code></p><p>除此之外：</p><p>once(): 默认的，被调用一次。<br>times(int minTimes, int maxTimes): 该方法最少被调用 minTimes 次，最多被调用 maxTimes 次。<br>atLeastOnce()：该方法至少被调用一次。<br>anyTimes()：该方法可以被调用任意次。<br>等。</p><h4 id="回放"><a href="#回放" class="headerlink" title="回放"></a>回放</h4><p>在生成 Mock 对象和设定 Mock 对象行为两个阶段，Mock 对象的状态都是 Record 。在这个阶段，Mock 对象会记录用户对预期行为和输出的设定。</p><p>在使用 Mock 对象进行实际的测试前，我们需要将 Mock 对象的状态切换为 Replay。在 Replay 状态，Mock 对象能够根据设定对特定的方法调用作出预期的响应。</p><p>如果是使用默认 Control，那么需要使用 EasyMock#replay(toMock) 来进行；<br>如果是自定义 Control，那么 control.replay() 就能将该控制器下所有 Mock对象切换为 replay 状态。</p><h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><p>就不说了。</p><h4 id="验证-verify"><a href="#验证-verify" class="headerlink" title="验证 verify"></a>验证 verify</h4><p>同 replay 一致，使用对应的 verify() 方法即可完成验证。</p><p>默认的Mock对象好像只有调用次数验证。</p><p>比如，如果之前 times(2), 但是实际上只是调用了1次，那么在 verify 的时候就会报错。</p><h4 id="Mock-对象的重用"><a href="#Mock-对象的重用" class="headerlink" title="Mock 对象的重用"></a>Mock 对象的重用</h4><p>同 replay 一致，使用对应的 reset() 方法即可重新是 Mock对象回到 Record状态。</p><h4 id="预期调用方法的参数匹配"><a href="#预期调用方法的参数匹配" class="headerlink" title="预期调用方法的参数匹配"></a>预期调用方法的参数匹配</h4><p>在使用 Mock 对象进行实际的测试过程中，EasyMock 会根据方法名和参数来匹配一个预期方法的调用。EasyMock 对参数的匹配默认使用 equals() 方法进行比较。</p><p>除此之外，还有一些内置的参数匹配逻辑，比如说指定类型的对象，一些常用的字符串匹配逻辑，基本的数据类型，大于小于等于，为空不为空等等。</p><p>还支持自定义参数匹配器。</p><p>只要实现 IArgumentMatcher 接口即可，matches(Object actual) 方法应当实现输入值和预期值的匹配逻辑，而在 appendTo(StringBuffer buffer) 方法中，你可以添加当匹配失败时需要显示的信息。</p><h4 id="特殊的Mock对象"><a href="#特殊的Mock对象" class="headerlink" title="特殊的Mock对象"></a>特殊的Mock对象</h4><p>我们所创建的 Mock 对象都属于 EasyMock 默认的 Mock 对象类型，它对预期方法的调用次序不敏感，对非预期的方法调用抛出 AssertionError。除了这种默认的 Mock 类型以外，EasyMock 还提供了一些特殊的 Mock 类型用于支持不同的需求。</p><h5 id="Strick-Mock-对象"><a href="#Strick-Mock-对象" class="headerlink" title="Strick Mock 对象"></a>Strick Mock 对象</h5><p>如果 Mock 对象是通过 EasyMock.createMock() 或是 IMocksControl.createMock() 所创建的，那么在进行 verify 验证时，方法的调用顺序是不进行检查的。如果要创建方法调用的先后次序敏感的 Mock 对象（Strick Mock），应该使用 createStrickMock() 来创建。</p><h5 id="Nice-Mock-对象"><a href="#Nice-Mock-对象" class="headerlink" title="Nice Mock 对象"></a>Nice Mock 对象</h5><p>使用 createMock() 创建的 Mock 对象对非预期的方法调用默认的行为是抛出 AssertionError，如果需要一个默认返回0，null 或 false 等”无效值”的 “Nice Mock” 对象，可以通过 createNiceMock() 方法创建。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>前面通过源码，我们已经发现 EasyMock 后台处理的主要原理是利用 java.lang.reflect.Proxy 为指定的接口创建一个动态代理，这个动态代理，就是我们在编码中用到的 Mock 对象。EasyMock 还为这个动态代理提供了一个 InvocationHandler 接口的实现，这个实现类的主要功能就是将动态代理的预期行为记录在某个映射表中和在实际调用时从这个映射表中取出预期输出。</p><p>MocksControl 类中包含了两个重要的成员变量，分别是接口 IMocksBehavior 和 IMocksControlState 的实例。</p><p>IMocksBehavior 的实现类 MocksBehavior 是 EasyMock 的核心类，它保存着一个 ExpectedInvocationAndResult 对象的一个列表，而 ExpectedInvocationAndResult 对象中包含着 Mock 对象方法调用和预期结果的映射。MocksBehavior 类提供了 addExpected 和 addActual 方法用于添加预期行为和实际调用。</p><p>MocksControl 类中包含的另一个成员变量是 IMocksControlState 实例。IMocksControlState 拥有两个不同的实现类：RecordState 和 ReplayState。顾名思义，RecordState 是 Mock 对象在 Record 状态时的支持类，它提供了 invoke 方法在 Record 状态下的实现。此外，它还提供了 andReturn、andThrow、times 等方法的实现。ReplayState 是 Mock 对象在 Replay 状态下的支持类，它提供了 invoke 方法在 Replay 状态下的实现。</p><p>有兴趣的可以研究下，在创建 Mock 对象，记录 Mock 对象预期行为，在 Replay 状态下调用 Mock 对象方法 的代码调用时序图。</p><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><p>EasyMock 不可以实现对静态方法、构造方法、私有方法、final 方法模拟；<br>不过还有对应的扩展 PowerMock。<br>PowerMock 也是一个单元测试模拟框架，它是在其它单元测试模拟框架的基础上做出的扩展。通过提供定制的类加载器以及一些字节码篡改技巧的应用，PowerMock 现了对静态方法、构造方法、私有方法以及 final 方法的模拟支持，对静态初始化过程的移除等强大的功能。</p><p>我大致试了一下，但是在一些模块上由于我们插件加载机制的问题，好像 PowerMock 测试这些模块的时候会出现问题。</p><p>有机会也可以再介绍一下。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单元测试是非常重要的，对于我们稳定性的提高具有非常重要的帮助，相信在 EasyMock 和 PowerMock 的帮助先，我们的单元测试覆盖率可以达到 100%。</p><p>同时关于代理模式的解释也希望能够给大家在代码结构方面带来思考。</p><p>今天的 1+2&#x3D;3 的例子就讲完了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://shlteater.iteye.com/blog/394191" title="EASYMOCK原理浅析">EASYMOCK原理浅析</a></p><p><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-easymock/" title="EasyMock 使用方法与原理剖析">EasyMock 使用方法与原理剖析</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;单元测试目的是针对应用中某些模块进行功能验证。&lt;br&gt;但是在单元测试中我们可能会遇到一些问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;其他的协同模块没有开发完，单元测试进行不下去&lt;/li&gt;
&lt;li&gt;被测试模块需要和一些不容易构造、比较复杂的对象进行交互，测试和测试边界很难划分&lt;/li&gt;
&lt;li&gt;不能肯定其它模块的正确性，无法准确的定位问题&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="unit-test" scheme="https://notes.yaohwu.xyz/tags/unit-test/"/>
    
  </entry>
  
</feed>
